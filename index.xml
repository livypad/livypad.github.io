<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>zhh's blog</title><link>https://livypad.github.io/</link><description>Recent content on zhh's blog</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Mon, 08 May 2023 00:40:00 +0800</lastBuildDate><atom:link href="https://livypad.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>笔记：Computer Architecture A Quantatative Approach（更新到第5章）</title><link>https://livypad.github.io/post/2023-03-23-caaqa/</link><pubDate>Mon, 08 May 2023 00:40:00 +0800</pubDate><guid>https://livypad.github.io/post/2023-03-23-caaqa/</guid><description>Computer architecture: a quantitative approach ch 1 Fundamentals ch 2/B Memory Hierarchy Design 基础知识 cache 性能优化 虚拟存储 virtual machine Fallacy Pitfall ch 3/C Instruction-Level Parallelism and Its Exploitation 编译器优化 ILP 循环展开 5 级流水 前递 乱序 Scoreboard Tomasulo 硬件预测 多发射 VLIW 分支预测 静</description><content:encoded><![CDATA[<ul>
<li><a href="#computer-architecture-a-quantitative-approach">Computer architecture: a quantitative approach</a>
<ul>
<li><a href="#ch-1-fundamentals">ch 1 Fundamentals</a></li>
<li><a href="#ch-2b-memory-hierarchy-design">ch 2/B Memory Hierarchy Design</a>
<ul>
<li><a href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">基础知识</a></li>
<li><a href="#cache-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">cache 性能优化</a></li>
<li><a href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8">虚拟存储</a></li>
<li><a href="#virtual-machine">virtual machine</a></li>
<li><a href="#fallacy">Fallacy</a></li>
<li><a href="#pitfall">Pitfall</a></li>
</ul>
</li>
<li><a href="#ch-3c-instruction-level-parallelism-and-its-exploitation">ch 3/C Instruction-Level Parallelism and Its Exploitation</a>
<ul>
<li><a href="#%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96-ilp">编译器优化 ILP</a>
<ul>
<li><a href="#%E5%BE%AA%E7%8E%AF%E5%B1%95%E5%BC%80">循环展开</a></li>
</ul>
</li>
<li><a href="#5-%E7%BA%A7%E6%B5%81%E6%B0%B4">5 级流水</a>
<ul>
<li><a href="#%E5%89%8D%E9%80%92">前递</a></li>
</ul>
</li>
<li><a href="#%E4%B9%B1%E5%BA%8F">乱序</a>
<ul>
<li><a href="#scoreboard">Scoreboard</a></li>
<li><a href="#tomasulo">Tomasulo</a></li>
<li><a href="#%E7%A1%AC%E4%BB%B6%E9%A2%84%E6%B5%8B">硬件预测</a></li>
</ul>
</li>
<li><a href="#%E5%A4%9A%E5%8F%91%E5%B0%84">多发射</a>
<ul>
<li><a href="#vliw">VLIW</a></li>
</ul>
</li>
<li><a href="#%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B">分支预测</a>
<ul>
<li><a href="#%E9%9D%99%E6%80%81%E9%A2%84%E6%B5%8B">静态预测</a></li>
<li><a href="#2-bitn-bit">2-bit/n-bit</a></li>
<li><a href="#mn%E9%A2%84%E6%B5%8B%E5%99%A8">(m,n)预测器</a></li>
<li><a href="#g-share-%E9%A2%84%E6%B5%8B%E5%99%A8">g-share 预测器</a></li>
<li><a href="#tournament%E9%94%A6%E6%A0%87%E8%B5%9B%E9%A2%84%E6%B5%8B%E5%99%A8">Tournament（锦标赛）预测器</a></li>
<li><a href="#tagged-hybridtage-%E9%A2%84%E6%B5%8B%E5%99%A8">Tagged Hybrid/TAGE 预测器</a></li>
</ul>
</li>
<li><a href="#%E5%A4%9A%E5%91%A8%E6%9C%9F%E6%8C%87%E4%BB%A4">多周期指令</a></li>
<li><a href="#%E4%B8%AD%E6%96%AD%E5%BC%82%E5%B8%B8">中断/异常</a></li>
<li><a href="#pitfall-1">Pitfall</a></li>
<li><a href="#fallacy-1">Fallacy</a></li>
</ul>
</li>
<li><a href="#ch-4-data-level-parallelism-in-vector-simd-and-gpu-architectures">ch 4 Data-Level Parallelism in Vector, SIMD, and GPU Architectures</a>
<ul>
<li><a href="#roofline-model">Roofline-Model</a></li>
<li><a href="#%E5%90%91%E9%87%8F%E6%9E%B6%E6%9E%84">向量架构</a></li>
<li><a href="#%E9%9D%A2%E5%90%91%E5%A4%9A%E5%AA%92%E4%BD%93%E7%9A%84-simd-%E6%89%A9%E5%B1%95">面向多媒体的 SIMD 扩展</a></li>
<li><a href="#gpu">GPU</a>
<ul>
<li><a href="#cuda">CUDA</a></li>
<li><a href="#%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84">层次结构</a></li>
<li><a href="#%E5%AF%B9%E7%85%A7">对照</a></li>
</ul>
</li>
<li><a href="#loop-level-parallelism-%E6%94%B9%E8%BF%9B">Loop-level parallelism 改进</a>
<ul>
<li><a href="#%E4%BE%9D%E8%B5%96%E6%A3%80%E6%B5%8B">依赖检测</a></li>
<li><a href="#%E5%8F%A6%E4%B8%80%E7%A7%8D%E4%BE%9D%E8%B5%96%E6%B6%88%E9%99%A4">另一种依赖消除</a></li>
</ul>
</li>
<li><a href="#fallacy-2">Fallacy</a></li>
<li><a href="#pitfall-2">Pitfall</a></li>
</ul>
</li>
<li><a href="#ch-5-thread-level-parallelism">ch 5 Thread-Level Parallelism</a>
<ul>
<li><a href="#memory-consistency-%E6%A8%A1%E5%9E%8B">Memory Consistency 模型</a></li>
<li><a href="#centralized-shared-memory-architectures">Centralized Shared-Memory Architectures</a></li>
<li><a href="#snooping">Snooping</a></li>
<li><a href="#directory-based">Directory based</a></li>
<li><a href="#%E5%90%8C%E6%AD%A5%E6%93%8D%E4%BD%9C">同步操作</a></li>
<li><a href="#fallacy-3">Fallacy</a></li>
<li><a href="#pitfall-3">Pitfall</a></li>
</ul>
</li>
<li><a href="#ch-a-instruction-set-principles">ch A Instruction Set Principles</a>
<ul>
<li><a href="#isa-%E7%89%B9%E6%80%A7">ISA 特性</a></li>
<li><a href="#%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96">编译器优化</a></li>
<li><a href="#isa-%E7%BB%9F%E8%AE%A1%E5%92%8C%E5%AF%B9%E5%BA%94%E7%9A%84-risc-v-%E8%AE%BE%E8%AE%A1">ISA 统计和对应的 RISC-V 设计</a></li>
<li><a href="#fallacy-4">Fallacy</a></li>
<li><a href="#pitfall-4">Pitfall</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="computer-architecture-a-quantitative-approach">Computer architecture: a quantitative approach</h1>
<h2 id="ch-1-fundamentals">ch 1 Fundamentals</h2>
<ul>
<li>Internet of Things/Embedded Computers：缺乏量化基准</li>
<li>Personal Mobile Device：soft real time（对实时性的要求），功耗优化</li>
<li>Desktop Computing：性价比</li>
<li>Servers：可用性，可拓展性，有效吞吐</li>
<li>Warehouse：性价比，功耗</li>
</ul>
<h2 id="ch-2b-memory-hierarchy-design">ch 2/B Memory Hierarchy Design</h2>
<h3 id="基础知识">基础知识</h3>
<p>cache 基本配置有</p>
<ol>
<li>
<p>block 可放置位置</p>
<ol>
<li>direct mapped：直接映射，$(Block\ Address)\mod(Number\ of\ blocks)$</li>
<li>fully associative：全相联，cache 中任意位置</li>
<li>set associative：组相联，在对应组中的任意位置，$(Block\ Address)\mod(Number\ of\ sets)$</li>
</ol>
</li>
<li>
<p>替换算法</p>
<ol>
<li>random：效果不差，但是缺乏确定性，对程序优化不友好</li>
<li>FIFO：first-in-first-out，可能导致抖动</li>
<li>LRU：Least recently used，较优，但算法复杂，一般采用简化版，如 clock 算法</li>
</ol>
</li>
<li>
<p>写策略</p>
<ul>
<li>写命中 cache 时候
<ol>
<li>write through：写穿透，cache 和底层都写，保持一致性容易</li>
<li>write back：写回，只写 cache，之后 cache 写回底层，性能较好</li>
</ol>
</li>
<li>写不命中时候，常常使用<code>write buffer</code>减少写带来的 stall
<ol>
<li>write allocate：写分配</li>
<li>No-write allocate：写不分配</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="cache-性能优化">cache 性能优化</h3>
<p>优化目标为平均访问时间，有</p>
<p>$$
\mathrm{Average\ memory\ access\ time}=\mathrm{Hit\ time} + \mathrm{Miss\ rate}\times \mathrm{Miss\ penalty}
$$</p>
<p>当中，可以把 miss 分类有</p>
<ol>
<li>compulsory miss：第一次访存必然 miss</li>
<li>capacity miss：cache 容量有限，一些 block 被丢弃后再被访问</li>
<li>conflict miss：cache 不是全相联，set 满而部分 block 被丢弃后再被访问</li>
<li>coherence miss：多核时候，其他核修改导致数据过时而失效</li>
</ol>
<p>简单优化有</p>
<ol>
<li>增大 block ，减少 miss rate
<ul>
<li>利用 spacial locality：空间局部性，可以减少 compulsory miss</li>
<li>可能增大 miss penalty</li>
<li>在 cache 大小固定时候，过大的 block 大小会增加 conflict miss</li>
</ul>
</li>
<li>增大 cache ，减少 miss rate
<ul>
<li>可能增加 hit time</li>
<li>可能增加成本和功耗</li>
</ul>
</li>
<li>增加关联度
<ul>
<li>比较电路设计麻烦，可能提高 hit time</li>
<li>8-way 组相联和全相联一般表现类似</li>
<li>
<blockquote>
<p>2:1 cache rule of thumb</p>
<p>大小 N 的 direct mapped 和$\frac{N}{2}$的 2-way set associative 一般 miss rate 相似（经验公式）</p>
</blockquote>
</li>
<li>可能增加 hit time，高关联性会要求更低的时钟频率</li>
</ul>
</li>
<li>多级 cache
<ul>
<li>multilevel inclusion/ multilevel exclusion</li>
<li>平衡 fast hit 和 few misses</li>
</ul>
</li>
<li>read miss 优先于 write miss， 减少 miss penalty
<ul>
<li>read miss 一般和取指，取数计算有关，优先可以减少程序的 stall</li>
<li>写缓存可能导致数据不一致，等写回内存用时过长</li>
</ul>
</li>
<li>在 cache 内索引时避开地址翻译， 降低 hit time
<ul>
<li>VIVT 对于保护,重名不利</li>
<li>VIPT 需要如 page coloring 页着色等消除重名/使用 PID 进程号来记录 cache 对应关系</li>
<li>加大相联度，强行保证无需地址翻译</li>
<li>对于 L2 以下的 cache 不重要,因为访问 L2 时候必然已经经过了地址翻译</li>
</ul>
</li>
</ol>
<p>复杂优化有</p>
<ol>
<li>简单的 L1 缓存， 减少 hit time 和功耗
<ul>
<li>为了更高的时钟频率和功耗限制</li>
<li>高相联性有助于不加大尺寸提高性能，但会提高功耗
<ol>
<li>处理器本身 cache 访问慢</li>
<li>为了不地址翻译，cache 大小受限于页大小</li>
<li>多线程程序容易引发 conflict miss</li>
</ol>
</li>
<li>加大 block 大小减少行数以减少索引能耗，但会提高 miss rate</li>
<li>组织 banks， 分块激活</li>
</ul>
</li>
<li>预测组相联的具体 way，加速访问速度，降低 conflict miss
<ul>
<li>I-cache 更容易被预测</li>
<li>way-selection：使用预测结果决定实际 cache 访问，适用于低功耗</li>
</ul>
</li>
<li>流水线化缓存访问，多 banks 独立
<ul>
<li>流水线可提高 L1 时钟频率，会增加延迟，一般针对 I-cache</li>
<li>多 banks 独立针对，对于下级缓存，可以同时处理多个上级缓存缺失</li>
</ul>
</li>
<li>nonblocking cache， 提高带宽
<ul>
<li>
<blockquote>
<p><strong>hit under miss</strong> 允许乱序执行规避 stall</p>
</blockquote>
</li>
<li>乱序执行刻意部分掩盖高层次的 cache miss，但对于高延迟的低层 miss 无效</li>
<li>
<blockquote>
<p><code>Miss Status Handling Registers(MSHRs)</code>记录缓存 miss 信息，一对一处理</p>
</blockquote>
</li>
</ul>
</li>
<li>关键词优先，更快重启
<ul>
<li>cache line 比起一次 cache miss 要求的 word 更大，因此只要需要的数据可用，立即返回</li>
</ul>
</li>
<li>融合写缓存
<ul>
<li>写相近地址的多字比多次写一个字快速</li>
<li><strong>内存映射的 IO 不能写融合</strong></li>
</ul>
</li>
<li>编译器优化
<ul>
<li>循环展开</li>
<li>blocking 访问</li>
</ul>
</li>
<li>硬件预取
<ul>
<li>注意预取可能会遇到虚拟内存缺页、权限错误等问题</li>
<li>可能取来无用数据而影响功耗，在高负载下影响性能</li>
</ul>
</li>
<li>编译器控制预取
<ul>
<li>不能干扰程序执行（比如 register perfetch）</li>
</ul>
</li>
<li>HBM：high bandwidth memory
<ul>
<li>大的 L4 缓存：
<ol>
<li>大 block：内部碎片，使用 subblocking 只激活一部分缓解</li>
<li>tag 存储开销大：tag 和数据放在 HBM 同一行中，使用 memory 的行缓存加速访问</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="虚拟存储">虚拟存储</h3>
<ol>
<li>保护，保护机制在 page 上</li>
<li>共享,如系统库</li>
<li>管理内存使用和硬盘的 swap</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>Page</th>
<th>Segment</th>
</tr>
</thead>
<tbody>
<tr>
<td>Words per address</td>
<td>One</td>
<td>Two (segment and offset)</td>
</tr>
<tr>
<td>Programmer visible?</td>
<td>Invisible to application programmer</td>
<td>May be visible to application programmer</td>
</tr>
<tr>
<td>Replacing a block</td>
<td>Trivial (all blocks are the same size)</td>
<td>Difficult (must find contiguous, variable-size, unused portion of main memory)</td>
</tr>
<tr>
<td>Memory use</td>
<td>inefficiency Internal fragmentation (unused portion of page)</td>
<td>External fragmentation (unused pieces of main memory)</td>
</tr>
<tr>
<td>Efficient disk traffic</td>
<td>Yes (adjust page size to balance access time and transfer time)</td>
<td>Not always (small segments may transfer just a few bytes)</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Translation Look Aside buffer</p>
<p>TLB，快表，作为页表的缓存</p>
</blockquote>
<table>
<thead>
<tr>
<th>bit</th>
<th>usage</th>
</tr>
</thead>
<tbody>
<tr>
<td>Presence</td>
<td>page is present in memory</td>
</tr>
<tr>
<td>Read/write</td>
<td>whether page is read-only or read-write</td>
</tr>
<tr>
<td>User/supervisor</td>
<td>whether a user can access the page or if it is limited to the upper three privilege levels</td>
</tr>
<tr>
<td>Dirty</td>
<td>if page has been modified</td>
</tr>
<tr>
<td>Accessed</td>
<td>if page has been read or written since the bit was last cleared</td>
</tr>
<tr>
<td>Page size</td>
<td>whether the last level is for 4 KiB pages or 4 MiB pages; if it&rsquo;s the latter, then the Opteron only uses three instead of four levels of pages</td>
</tr>
<tr>
<td>No execute</td>
<td>Not found in the 80386 protection scheme, this bit was added to prevent code from executing in some pages</td>
</tr>
<tr>
<td>Page level cache disable</td>
<td>whether the page can be cached or not</td>
</tr>
<tr>
<td>Page level write through</td>
<td>whether the page allows write back or write through for data caches</td>
</tr>
</tbody>
</table>
<h3 id="virtual-machine">virtual machine</h3>
<ol>
<li>用虚拟机隔离 os
<ol>
<li>可能有 bug 的操作系统</li>
<li>云用户</li>
<li>芯片性能足够开销</li>
</ol>
</li>
<li>兼容和管理软件</li>
<li>管理硬件（可以跨越单台机器）</li>
</ol>
<p>ISA 设计最好考虑虚拟机，<strong>virtualizable</strong>。保证特权指令在裸 os 和虚拟机的 os 下效果一致。也可以设计更多的特权级（RISCV 的 M、S、U 三态）。TLB 带进程号防止切换 os 频繁刷新。IO 设备也需要 vmm 来划分（如网络）和虚拟化（如硬盘）</p>
<blockquote>
<p>shadow page table</p>
<p>减少 软件-os-vmm 2 次地址翻译开销，os-vmm 之间直接映射。需要 trap 所有的 os 对页表的改写</p>
</blockquote>
<blockquote>
<p>software guard extension</p>
<p>由进程定义的对内存的加密。上层 os 和 vmm 可以移动数据，不能解密数据</p>
</blockquote>
<h3 id="fallacy">Fallacy</h3>
<ol>
<li>使用一个程序的访存推断其他程序。程序之间差异很大</li>
</ol>
<h3 id="pitfall">Pitfall</h3>
<ol>
<li>地址空间太小
<ul>
<li>程序寻址空间大小$2^\text{address}$，太小的地址空间限制大程序</li>
<li>地址空间和<code>PC</code>，寄存器等多方面相关，难以后期改变</li>
</ul>
</li>
<li>忽略 os 对存储的性能影响，os 也会造成存储负载</li>
<li>依赖 os 智能调整页大小。os 一般只会针对如数据库和内存映射使用大页，os 不够智能</li>
<li>模拟指令来衡量访存性能
<ol>
<li>cache 尺寸对于一小部分指令来说太大</li>
<li>程序不同阶段局部性不一样</li>
<li>程序对于不同输入局部性不一样</li>
</ol>
</li>
<li>用 cache 但是内存带宽不够</li>
<li>在<strong>virtualizable</strong>有问题的 ISA 上设计虚拟机
<ul>
<li>eg，80x86 的<code>POPF</code>指令，在 user mode 下不改变<code>IE</code>；在 system mode 下改变。但<code>POPF</code>不是特权级指令，vmm 无法 trap 来保证虚拟化</li>
</ul>
</li>
</ol>
<h2 id="ch-3c-instruction-level-parallelism-and-its-exploitation">ch 3/C Instruction-Level Parallelism and Its Exploitation</h2>
<p>主要关注的是 basic block（只在代码块出入口有跳转，平均几行规模）和多个 basic block 级别的并行性。程序天然的存在依赖关系。优化需要保证依赖关系以保证正确的输出</p>
<ol>
<li>data dependence（RAW）
<ul>
<li>前一条指令的结果是后一条指令的输入</li>
<li>有传递性</li>
<li>存在于内存的 data depedence 比起寄存器之间的更难检测</li>
</ul>
</li>
<li>name dependence，在指令使用相同的寄存器（一般靠寄存器重命名消除）/内存地址（称为 name）时候出现
<ol>
<li>antidepedence：前一条指令写后一条指令的读（WAR）</li>
<li>output dependence：两条指令同时写一个寄存器/内存地址（WAW）</li>
</ol>
</li>
<li>control depedence：指令的执行条件不能被更改，不一定会被完美保持，而是保持能维护正确性的重要的 dependence
<ol>
<li>exception behavior：保证修改指令序列不会导致异常的行为变动（eg，发生本来没有的异常）</li>
<li>data flow：保证指令的数据来自正确的前面的指令，即使可能有多条指令和其有潜在的 data dependence（eg，正确选择来自某个分支的结果）</li>
</ol>
</li>
</ol>
<p>如果有依赖关系的指令距离很近，导致不能并行/重叠执行等，就会造成 hazard 使得处理器必须特别处理</p>
<ol>
<li>structural hazard：功能部件不能满足同时访问</li>
<li>data hazard：数据依赖（按照正确执行应该保持的顺序来命名）
<ol>
<li>Read After Write：RAW，真相关</li>
<li>Write After Read：WAR，只有乱序时候出现</li>
<li>Write After Write：WAW，只有乱序时候出现</li>
</ol>
</li>
<li>control hazard：跳转和其他改变<code>pc</code>的指令</li>
</ol>
<h3 id="编译器优化-ilp">编译器优化 ILP</h3>
<ol>
<li>对于指针和引用，编译期的依赖关系难以检测</li>
<li>硬件预测一般能保证精确异常</li>
<li>有些程序的<a href="#%E9%9D%99%E6%80%81%E9%A2%84%E6%B5%8B">静态预测分支</a>效果很差（整数控制程序，如数据库）</li>
<li>硬件预测不需要使用额外代码而增加代码体积</li>
<li>编译器可以调度更大范围内的依赖关系</li>
<li>硬件预测不需要对不同处理器架构针对性优化</li>
<li>硬件预测会导致复杂的控制逻辑，更多晶体管面积和能耗</li>
</ol>
<h4 id="循环展开">循环展开</h4>
<p>loop unrolling。减少循环判断次数，一个循环体里执行原先多个循环的内容。如果是未知的需要迭代$n$次，展开尺寸$k$，那么需要$\frac{n}{k}$次循环展开，$n\mod k$次原本的循环</p>
<ol>
<li>减少判断和跳转的指令数目，以及其潜在的延迟</li>
<li>在更大的循环体里调度指令消除 data hazard 更容易
<ol>
<li>尽量用不同寄存器防止 name dependence</li>
<li>更改<code>load,store</code>顺序来遮盖访存延迟</li>
</ol>
</li>
<li>会增加代码体积；过度展开会导致 cache 性能差；通用寄存器数目有限，展开次数有上限</li>
</ol>
<h3 id="5-级流水">5 级流水</h3>
<table>
<thead>
<tr>
<th>全称</th>
<th>简称</th>
<th>效果</th>
<th>伪代码</th>
</tr>
</thead>
<tbody>
<tr>
<td>instruction fetch cycle</td>
<td>IF</td>
<td>按照<code>pc</code>取指令，并<code>pc+=4</code></td>
<td><code>IR&lt;-Mem[PC],NPC&lt;-PC+4</code></td>
</tr>
<tr>
<td>instruction decode/register fetch cycle</td>
<td>ID</td>
<td>指令译码，符号拓展偏移值，预测<code>pc</code>跳转地址，读寄存器（RISCV 的寄存器和立即数位置固定，可以在不在意功耗场合默认读取）</td>
<td><code>A&lt;-Regs[rs1],B&lt;-Regs[rs2], Imm&lt;-sign-extended immediate field of IR;</code></td>
</tr>
<tr>
<td>execution/effective address cycle</td>
<td>EX</td>
<td>1. 内存访问：ALU 计算基址+偏移 2. 寄存器-寄存器 ALU 3. 寄存器-立即数 ALU 4. 条件跳转：判断是否跳转。 对于 load-store 的 ISA（如 RISCV）执行和计算地址可以合并为一个周期</td>
<td><code>ALUOutput&lt;- A + Imm;ALUOutput&lt;-A func B;ALUOutput&lt;-A op Imm;ALUOutput&lt;-NPC+(Imm&lt;&lt;2),Cond&lt;-(A?=B)</code></td>
</tr>
<tr>
<td>memory access</td>
<td>MEM</td>
<td>访存</td>
<td><code>LMD&lt;-Mem[ALUOutput] or Mem[ALUOutput]&lt;-B;if(Cond)PC&lt;-ALUOutput else PC&lt;-NPC</code></td>
</tr>
<tr>
<td>write-back cycle</td>
<td>WB</td>
<td>访存/ALU 运算结果写回寄存器文件</td>
<td><code>Regs[rd]&lt;-ALUOutput;Regs[rd]&lt;-LMD</code></td>
</tr>
</tbody>
</table>
<p>有一些注意事项</p>
<ol>
<li>分开 Icache 和 Dcache 保证一个 cycle 内取指和访存指令的访存不冲突</li>
<li>对于流水的 CPU，访存频率更高，要求更高的内存带宽</li>
<li>寄存器文件在 ID 时候需要 2 个读端口，WB 时候 1 个写端口</li>
<li>中间结果需要 pipeline registers 缓存下来，<code>IF/ID,ID/EX,EX/MEM,MEM/WB</code></li>
<li>流水线的单一指令延迟会增加
<ol>
<li>最慢的阶段限制整体时钟频率</li>
<li>pipeline register 读写和传播时间</li>
</ol>
</li>
</ol>
<p>流水线会遭遇 hazard 使得性能不如理论值。（暂停，清空等）</p>
<h4 id="前递">前递</h4>
<p>forwarding，bypassing，short-circuiting。</p>
<p>把已经计算出来的被依赖的结果不等 WB 写回寄存器，直接传给需要的功能部件。</p>
<table>
<thead>
<tr>
<th>目标 pipeline register</th>
<th>目标指令类型</th>
<th>源 Pipeline register</th>
<th>源指令类型</th>
<th>前递位置</th>
<th>前递的条件</th>
</tr>
</thead>
<tbody>
<tr>
<td>EX/MEM</td>
<td>寄存器-寄存器，立即数</td>
<td>ID/EX</td>
<td>寄存器-寄存器，立即数, load, store, branch</td>
<td>ALU 操作数 1</td>
<td><code>EX/MEM.IR[rd] == ID/EX.IR[rs1]</code></td>
</tr>
<tr>
<td>EX/MEM</td>
<td>寄存器-寄存器，立即数</td>
<td>ID/EX</td>
<td>寄存器-寄存器</td>
<td>ALU 操作数 2</td>
<td><code>EX/MEM.IR[rd] == ID/EX.IR[rs2]</code></td>
</tr>
<tr>
<td>MEM/WB</td>
<td>寄存器-寄存器，立即数, Load</td>
<td>ID/EX</td>
<td>寄存器-寄存器，立即数, load, store, branch</td>
<td>ALU 操作数 1</td>
<td><code>MEM/WB.IR[rd] == ID/EX.IR[rs1]</code></td>
</tr>
<tr>
<td>MEM/WB</td>
<td>寄存器-寄存器，立即数, Load</td>
<td>ID/EX</td>
<td>寄存器-寄存器</td>
<td>ALU 操作数 2</td>
<td><code>MEM/WB.IR[rd] == ID/EX.IR[rs2]</code></td>
</tr>
</tbody>
</table>
<p>前递不是万能的。如果是上下两条指令之间依赖，需要比如在 ID 阶段暂停流水线。比如对于依赖 load 指令结果的 RAW 依赖，需要实现<strong>load interlock</strong></p>
<table>
<thead>
<tr>
<th>需要 stall 的 IF/ID 指令类型</th>
<th>判断条件</th>
</tr>
</thead>
<tbody>
<tr>
<td>寄存器-寄存器, load, store, 立即数, branch</td>
<td><code>ID/EX.IR[rd]== IF/ID.IR[rs1]</code></td>
</tr>
<tr>
<td>寄存器-寄存器, branch</td>
<td><code>ID/EX.IR[rd]==IF/ID.IR[rs2]</code></td>
</tr>
</tbody>
</table>
<h3 id="乱序">乱序</h3>
<ol>
<li>减轻对特定架构编译的依赖，二进制分发有效率</li>
<li>应对编译期未知的依赖</li>
<li>应对不可预计的停顿，如 cache miss</li>
</ol>
<h4 id="scoreboard">Scoreboard</h4>
<p>CDC6600 开始采用的乱序执行机制。scoreboard 会记录和管理依赖关系。指令会首先顺序被 scoreboard issue（发射）。这套方法没有<a href="#%E5%89%8D%E9%80%92">前递</a>，因为是乱序执行，指令不需要等到自己的 WB 才能写进寄存器。但写寄存器和读之间还是需要 stall 一个周期。而且需要处理读写寄存器的总线的 structural hazards。</p>
<ol>
<li>issue：直到没有 structural hazard 和 WAW，功能部件空闲时候指令发射。暂停时候，指令队列可以接着取值</li>
<li>read operands：没有指令会写 operands 时候读寄存器，这样动态解决 RAW</li>
<li>excution：执行指令</li>
<li>write result：直到没有 WAR 时候写完成的结果</li>
</ol>
<h4 id="tomasulo">Tomasulo</h4>
<p>动态决定指令开始执行的时机以及寄存器重命名来消除 WAW、WAR。</p>
<blockquote>
<p>register renaming</p>
<p>寄存器重命名。将目的寄存器重命名，避免乱序完成影响实际的操作数。既可以编译器实现（在逻辑寄存器充足时），也可以硬件实现（在物理寄存器多于逻辑寄存器时）</p>
</blockquote>
<blockquote>
<p>reservation stations</p>
<p>保留站。缓存指令的类型，操作数，结果等信息，有：</p>
<ul>
<li>Op：操作</li>
<li>Qj,Qk：操作数来源的保留站号，为 0 表示操作数就绪/不需要</li>
<li>Vj,Vk：操作数的值。对于<code>load</code>指令，Vk 表示偏移</li>
<li>A：访存计算出来的地址</li>
<li>Busy：表示保留站和对应功能部件占用中</li>
</ul>
<p>对应的，寄存器文件有：</p>
<ul>
<li>Qi：表示结果来源的保留站号，如果为空/0，目前没有指令目标寄存器是自己</li>
</ul>
</blockquote>
<blockquote>
<p>common data bus</p>
<p>CDB。在 360/91 上，允许多个部件同时读可用的操作数，以实现<a href="#%E5%89%8D%E9%80%92">前递</a></p>
</blockquote>
<ol>
<li>issue：从 FIFO 的指令队列里面，取第一条指令。这一步会完成寄存器重命名解决 WAW、WAR，有时该阶段被称为 <em>dispatch</em>
<ol>
<li>对应保留站空闲，发射指令</li>
<li>对应操作数就绪，读寄存器文件，否则追踪对应的功能部件，等结果</li>
<li>对应保留站忙碌，出现 structural hazard，stall 指令</li>
</ol>
</li>
<li>execute：等操作数以解决 RAW
<ol>
<li>如果操作数还不可用，一直监听 CDB 直到可用</li>
<li>可用时候上到功能部件执行</li>
<li>如果多条指令同时可以执行，任选一条</li>
<li>如果是访存指令，按照程序顺序执行，并且把地址传到 load/store buffer 里等访存部件可用</li>
<li>访存指令可以简化按照程序顺序计算访存地址，但 <code>load</code> 之间是可以乱序的</li>
</ol>
</li>
<li>write result：在 CDB 上广播结果，写寄存器，如果是<code>store</code>指令，把地址和值写到 store buffer 中，等访存部件可用</li>
</ol>
<p><img loading="lazy" src="/assets/img/note/caaqa/tomasuloctrl.png" alt="tomasulo ctrl"  />
</p>
<p>Tomasulo 模式需要高速的集成的 cache 来保存大量消息，需要复杂的控制逻辑，需要高速高带宽的 CDB（多条 CDB 能提高带宽，但一致性需要解决）。Tomasulo 模式适合于多级 cache 的体系结构，因为可以掩盖不可控的 cache 延迟。对于程序员和编译器优化更友好。</p>
<h4 id="硬件预测">硬件预测</h4>
<p>为了应对 control hazard，虽然有<a href="#%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B">分支预测技术</a>，分支指令过于频繁，或者是多发射处理器一次应对很多条指令，因此需要引入硬件预测。处理器执行犹如分支预测一直成功一样。</p>
<blockquote>
<p>reorder buffer</p>
<p>ROB。在执行完成和 commit 之间缓存结果</p>
<ol>
<li>指令类型</li>
<li>目标地址</li>
<li>值</li>
<li>Ready</li>
</ol>
</blockquote>
<ol>
<li>issue：从指令队列有序发射，只要 ROB 和保留站空</li>
<li>exectue：等 CDB 直到操作数全部就绪</li>
<li>write result：把结果暂存进 ROB</li>
<li>commit：有序提交
<ol>
<li>把结果写到寄存器文件</li>
<li>实际进行<code>store</code>的访存</li>
<li>分支预测错误的 ROB 项清空</li>
</ol>
</li>
</ol>
<p><img loading="lazy" src="/assets/img/note/caaqa/dynspeculation.png" alt="Dyn Speculation"  />
</p>
<p>由于有序 commit，而改写寄存器和内存的值只在 commit 时候实现。因此可以保证只有在指令确定下来时候才实际更改机器状态。而且这也可以保证精确异常。而<code>load</code>的安全通过，1）在地址和某条 ROB 中地址重合时候不执行；2）按程序顺序计算访存地址来保证。</p>
<p>预测可能会导致出现本来不出现的异常和 cache miss。一般的，为了性能，预测阶段只会处理高级别 cache miss，其他的异常都等到指令确定性时候才触发。特别是比如权限的异常（不必要的终止，meltdown 漏洞等）。对于结构性较差的程序（比如数据库查询），预测执行可能会遇到大量嵌套的跳转。出于能耗和复杂度，一般不会对多分支多做优化。对于访存还可以通过 Address aliasing prediction，进一步发掘指令级并行度。</p>
<blockquote>
<p>Address aliasing prediction</p>
<p>预测访存地址是否冲突，从而允许访存相对乱序执行。相对简单，可以用简单的预测器实现</p>
</blockquote>
<blockquote>
<p>value prediction</p>
<p>预测指令的结果，进一步消除数据流之间的限制关系。过于复杂，目前没有实用性</p>
</blockquote>
<p>另一种方法是不使用 ROB，而是实际实现大量物理寄存器（对比 ISA 规定的逻辑寄存器，architectural register），使用 renaming map 管理寄存器重命名。只需要保证逻辑寄存器有关操作的正确，实际对应关系一直变动是不重要的。</p>
<h3 id="多发射">多发射</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>发射结构</th>
<th>Hazard 检测</th>
<th>调度策略</th>
<th>特点</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>静态超标量</td>
<td>动态</td>
<td>硬件检测</td>
<td>静态调度</td>
<td>顺序执行</td>
<td>嵌入式芯片，如 MIPS，ARM，包括 Cortex-A53</td>
</tr>
<tr>
<td>动态超标量</td>
<td>动态</td>
<td>硬件检测</td>
<td>动态调度</td>
<td>乱序执行，不带推断</td>
<td>现在不存在</td>
</tr>
<tr>
<td>推断超标量</td>
<td>动态</td>
<td>硬件检测</td>
<td>动态调度</td>
<td>带推断的乱序执行</td>
<td>Intel Core i3, i5, i7; AMD Phenom；IBM Power</td>
</tr>
<tr>
<td>VLIW/LIW</td>
<td>静态</td>
<td>主要靠软件</td>
<td>静态调度</td>
<td>靠编译器检测和隐式提示 hazard</td>
<td>信号处理器，如 TI C6x</td>
</tr>
<tr>
<td>EPIC</td>
<td>大多数静态</td>
<td>主要靠软件</td>
<td>大多数静态调度</td>
<td>靠编译器检测和显式提示 hazard</td>
<td>Itanium</td>
</tr>
</tbody>
</table>
<ol>
<li>半周期发射指令。缺乏拓展性，只适用于双发射</li>
<li>在一个发射周期内，检查所有指令间的和与已发射指令的依赖关系。控制逻辑复杂</li>
</ol>
<p>多发射的处理器需要更好的取指部件，保证指令来源不成为瓶颈。常见的对取指部件优化有：</p>
<ol>
<li>在取指时候集成 <a href="#%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B">分支预测</a></li>
<li>预取指令</li>
<li>提供取来的指令的缓存</li>
</ol>
<h4 id="vliw">VLIW</h4>
<blockquote>
<p>VLIW</p>
<p>very long instruction word。超长指令字。一条打包不同功能的指令</p>
</blockquote>
<h3 id="分支预测">分支预测</h3>
<p>在跳转指令到 EX 之前就猜测出跳转目标，就可以减少因为跳转带来的停顿。如果错误预测则需要清空流水线。</p>
<p>现实中的分支预测器极其影响性能。因此商业处理器的分支预测策略消息很少。</p>
<blockquote>
<p>Branch-Target Buffer</p>
<p>缓存历史的分支指令 PC 和 taken 对应预测目标的 PC。减少 PC 计算，下个周期直接取分支部位指令。如果分支预测正确，可以完全不停顿</p>
</blockquote>
<blockquote>
<p>branch folding</p>
<p>对于无条件跳转，可以给 Branch-Target Buffer 加一位 bit 提示，这样不再需要预测</p>
</blockquote>
<p>程序中存在跳转地址不固定的跳转指令，比如多处调用同一个函数，函数的返回地址就会变化。可以使用一个小的函数调用栈 cache，优化函数返回的跳转。</p>
<h4 id="静态预测">静态预测</h4>
<p>使用编译期信息进行分支预测。不同程序对于 taken 的概率对 50%有明显的偏移</p>
<h4 id="2-bitn-bit">2-bit/n-bit</h4>
<blockquote>
<p>branch-prediction buffer/branch history table</p>
<p>低位指令地址+预测器，如最简单的 1-bit 是否选择分支</p>
</blockquote>
<p>1-bit 的预测器可以扩展到 2-bit 状态机，防止偶发的 taken 变化造成 2 次错误预测。若为 n-bit，大于等于 $\frac{2^n-1}{2}$ 取 taken，反之 not taken。二者性能差异不大</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain"><span class="line"><span class="cl">   11 -NT-&gt; 10
</span></span><span class="line"><span class="cl">   |        |
</span></span><span class="line"><span class="cl">   T        NT
</span></span><span class="line"><span class="cl">   |        |
</span></span><span class="line"><span class="cl">   01 &lt;-T-- 00
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="mn预测器">(m,n)预测器</h4>
<p>$$\text{bits used}=2^m\times n \times \text{Number of prediction entries selected by the branch address}$$</p>
<p>一个 m 位移位寄存器记录全局历史，当前跳转的前 m 个实际分支行为历史，每一位用来记录该分支是否实际被执行，1 对应实际执行，0 对应实际未执行。 $2^m$ 的可能性分别对应 $2^m$ 个 n-bit 简单预测器。因此，2-bit 相当于(0,2)预测器</p>
<h4 id="g-share-预测器">g-share 预测器</h4>
<p>把分支历史和分支地址异或（类似于 hash 的功效）索引一个 2-bit 预测器</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-plaintext" data-lang="plaintext"><span class="line"><span class="cl">   10-bit shift regester
</span></span><span class="line"><span class="cl">|-[branch history]
</span></span><span class="line"><span class="cl">|
</span></span><span class="line"><span class="cl">|   10-bit
</span></span><span class="line"><span class="cl">|-[branch address]
</span></span><span class="line"><span class="cl">|
</span></span><span class="line"><span class="cl">|-[XOR]- 2^10*[2-bit predictor]-&gt;
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="tournament锦标赛预测器">Tournament（锦标赛）预测器</h4>
<p>结合局部 local 和全局 global 的 2-bit 预测器，并使用 branch address 选择 local/global 预测器。注意，预测错误时需要同时更新选择器和预测器。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-plaintext" data-lang="plaintext"><span class="line"><span class="cl">   branch history
</span></span><span class="line"><span class="cl">|-[2-bit global predictors]
</span></span><span class="line"><span class="cl">|
</span></span><span class="line"><span class="cl">|   branch address
</span></span><span class="line"><span class="cl">|-[local predictors]
</span></span><span class="line"><span class="cl">|
</span></span><span class="line"><span class="cl">|-[MUX]-&gt;
</span></span><span class="line"><span class="cl">    |
</span></span><span class="line"><span class="cl">    | branch address
</span></span><span class="line"><span class="cl">[2-bit selector]
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="tagged-hybridtage-预测器">Tagged Hybrid/TAGE 预测器</h4>
<p><img loading="lazy" src="/assets/img/note/caaqa/taggedhybrid.png" alt="TAGE 预测器"  />
</p>
<p>使用不同历史记录长度的预测器$P(0),P(1)$ 。$P(i)$ 使用<code>PC</code>的一部分和（用移位寄存器记录）的最近 i 条分支历史的 hash 结果索引，包括 2-bit 预测器（实际中 3-bit 更好一点）+ 4-8bit 的 tag。<code>PC</code>和 tag 比较（$P(0)$不比较，作为默认使用预测器），决定使用本级的预测器还是上一级结果。</p>
<p>预测器可以包含一个 bit 用来表示该级是否最近使用过，并以此决定刷新频率。预测器内容的初始化有多种方式，而且对于短的程序，初始化的性能表现很重要。</p>
<ol>
<li>随机初始化</li>
<li>使用 valid bit 标记尚未初始化的条目</li>
<li>使用指令自带的偏向的 hint 初始化（如果不做动态预测器，那处理器就会使用 hint 作为预测</li>
<li>向后跳转指令可能用于循环，因此初始化为 taken</li>
</ol>
<h3 id="多周期指令">多周期指令</h3>
<p>比如浮点运算对比整数 ALU 运算慢很多。如果希望浮点指令运算和整数指令运算都能在一个周期内完成，需要极大降低频率而损害性能。一般有额外的浮点功能部件：</p>
<ol>
<li>整数的 ALU，load，store，branch 功能部件</li>
<li>浮点数和整数乘法器</li>
<li>浮点加法器</li>
<li>浮点和整数除法器</li>
</ol>
<p>多周期指令会带来额外的复杂度。可以通过分离整数寄存器和浮点数寄存器简化依赖检测（只有浮点数 load-store 和浮点寄存器移动可能出现依赖）和减少 structural hazard （端口自然分离）发生。</p>
<ol>
<li>structural hazard：
<ol>
<li>除法器不能完美流水化（额外除法器占晶体管资源）</li>
<li>多指令同时写回对寄存器文件写端口
<ol>
<li>在 ID 阶段检测冲突并引入 stall，保持只在 ID 检测 interlock 和停止发射指令</li>
<li>在进入 MEM、WB 之前暂停指令，一般选择长周期指令优先（减少可能的 RAW），检测冲突更容易，但是流水线控制不好做</li>
</ol>
</li>
</ol>
</li>
<li>多周期要求多种中间寄存器</li>
<li>不同周期指令之间执行用时不一而 WAW（WAR 不可能，因为只有在 ID 阶段才读寄存器，ID 阶段进入是有序的）
<ol>
<li>如果两条指令之间出现异常，连续写同一寄存器的 WAW 就会暴露出来。</li>
<li>可以 stall 顺序在后的指令</li>
<li>可以不执行前一条指令的写寄存器（注意精确异常的要求）</li>
</ol>
</li>
<li>不同周期指令的 out-of-order completion 对于精确异常的要求
<ol>
<li>放弃精确异常/两种工作模式：早期机器和科学计算机器，但不符合 ieee 标准</li>
<li>缓存结果，有序提交（类似乱序处理器），可能空间占用大，而且<a href="#%E5%89%8D%E9%80%92">前递</a>复杂
<ol>
<li>history file，记录历史值来回滚</li>
<li>future file，记录新值来更新</li>
</ol>
</li>
<li>不精确异常+回溯信息：异常恢复后模拟之前没完成指令的执行效果，适合简单处理器，整数指令一定执行完，只需考虑少数重叠的浮点指令</li>
<li>stall 直到肯定不出现不精确的异常</li>
</ol>
</li>
<li>长延迟对 RAW 有影响</li>
</ol>
<h3 id="中断异常">中断/异常</h3>
<blockquote>
<p>precise exception</p>
<p>精确异常：异常之前的指令都生效，异常之后的指令都没生效（执行到一半就要回滚已经产生的影响）</p>
</blockquote>
<p>精确异常符合程序员和编程语言的直觉，但一般会有一些困难。有可能处理器提供高性能计算模式而异常不精确的工作模式。但一般来说，page 相关异常和 ieee 整数运算异常一般都会被精确处理。</p>
<ol>
<li>指令中间状态需要回滚</li>
<li>指令执行中修改内存：异常时候保存工作寄存器，之后重新开始</li>
<li>隐式的修改状态寄存器：如同追踪寄存器依赖一样追踪潜在的 data hazard</li>
<li>长指令（如浮点运算指令，参见<a href="#%E5%A4%9A%E5%91%A8%E6%9C%9F%E6%8C%87%E4%BB%A4">多周期指令</a> ）</li>
</ol>
<table>
<thead>
<tr>
<th>Exception Type</th>
<th>Synchronous（和具体代码、数据有关） vs Asynchronous</th>
<th>User Request vs Coerced</th>
<th>User Maskable vs Nonmaskable</th>
<th>within（指令本身引发，需要重启指令） vs between Instructions</th>
<th>Resume vs Terminate</th>
</tr>
</thead>
<tbody>
<tr>
<td>I/O device request</td>
<td>Asynchronous</td>
<td>Coerced</td>
<td>Nonmaskable</td>
<td>Between</td>
<td>Resume</td>
</tr>
<tr>
<td>Invoke operating system</td>
<td>Synchronous</td>
<td>User request</td>
<td>Nonmaskable</td>
<td>Between</td>
<td>Resume</td>
</tr>
<tr>
<td>Tracing instruction execution</td>
<td>Synchronous</td>
<td>User request</td>
<td>User maskable</td>
<td>Between</td>
<td>Resume</td>
</tr>
<tr>
<td>Breakpoint</td>
<td>Synchronous</td>
<td>User request</td>
<td>User maskable</td>
<td>Between</td>
<td>Resume</td>
</tr>
<tr>
<td>Integer arithmetic overflow</td>
<td>Synchronous</td>
<td>Coerced</td>
<td>User maskable</td>
<td>Within</td>
<td>Resume</td>
</tr>
<tr>
<td>Floating-point arithmetic overflow or underflow</td>
<td>Synchronous</td>
<td>Coerced</td>
<td>User maskable</td>
<td>Within</td>
<td>Resume</td>
</tr>
<tr>
<td>Page fault</td>
<td>Synchronous</td>
<td>Coerced</td>
<td>Nonmaskable</td>
<td>Within</td>
<td>Resume</td>
</tr>
<tr>
<td>Misaligned memory accesses</td>
<td>Synchronous</td>
<td>Coerced</td>
<td>User maskable</td>
<td>Within</td>
<td>Resume</td>
</tr>
<tr>
<td>Memory protection violations</td>
<td>Synchronous</td>
<td>Coerced</td>
<td>Nonmaskable</td>
<td>Within</td>
<td>Resume</td>
</tr>
<tr>
<td>Using undefined instructions</td>
<td>Synchronous</td>
<td>Coerced</td>
<td>Nonmaskable</td>
<td>Within</td>
<td>Terminate</td>
</tr>
<tr>
<td>Hardware malfunctions</td>
<td>Asynchronous</td>
<td>Coerced</td>
<td>Nonmaskable</td>
<td>Within</td>
<td>Terminate</td>
</tr>
<tr>
<td>Power failure</td>
<td>Asynchronous</td>
<td>Coerced</td>
<td>Nonmaskable</td>
<td>Within</td>
<td>Terminate</td>
</tr>
</tbody>
</table>
<h3 id="pitfall-1">Pitfall</h3>
<ol>
<li>未预料的执行顺序会导致未预料的冲突
<ul>
<li>即使是顺序处理器，浮点指令周期不同，两条指令之间出现异常，连续写同一寄存器而有可能产生 WAW</li>
</ul>
</li>
<li>过度设计的流水线会影响整个处理器设计，可能损害性价比
<ul>
<li>VAX 系列，流水过深过于复杂导致主频低，而且消耗大量晶体管资源</li>
</ul>
</li>
<li>使用优化等级低的代码衡量处理器调度能力
<ul>
<li>现实中代码一般都是<code>-O2</code>优化的；未优化代码存在大量冗余，不能充分考验处理器的硬件调度能力</li>
</ul>
</li>
<li>有时候加面积+不那么智能也很好
<ul>
<li>把做复杂逻辑的晶体管面积直接做成 cache，根本上减少 cache 的延迟</li>
</ul>
</li>
<li>有时候更聪明更好
<ul>
<li>高效的分支预测很重要，更低的错误率意味更少的清空流水线</li>
<li>对比<a href="#g-share-%E9%A2%84%E6%B5%8B%E5%99%A8">简单的 g-share 预测器</a>，更好的算法记录 tags，可以避免混淆不同地方的分支预测结果</li>
</ul>
</li>
<li>不存在永远可待挖掘的 ILP 的潜力
<ul>
<li>即使采用非常理想的配置，现实中的程序（特别是整数程序）能并行的也是有限的</li>
</ul>
</li>
</ol>
<h3 id="fallacy-1">Fallacy</h3>
<ol>
<li>对于同一套指令集的不同版本，容易预测其性能和能耗
<ul>
<li>Intel 的 i7 920 和 Atom 230 对比实验，性能差 4 倍，功耗差 10 倍</li>
<li>带推断的动态乱序执行有利于性能，但会极大提高功耗</li>
</ul>
</li>
<li>更低的 CPI，更快</li>
<li>更高的时钟频率，更快
<ul>
<li>CPI 和时钟频率乘积共同决定性能，偏废会导致短板效应。</li>
</ul>
</li>
</ol>
<h2 id="ch-4-data-level-parallelism-in-vector-simd-and-gpu-architectures">ch 4 Data-Level Parallelism in Vector, SIMD, and GPU Architectures</h2>
<blockquote>
<p>SIMD</p>
<p>single instruction multiple data</p>
</blockquote>
<blockquote>
<p>DLP</p>
<p>data level parallelism</p>
</blockquote>
<h3 id="roofline-model">Roofline-Model</h3>
<p>可以定义计算强度，用来衡量程序内计算部分的占比。只有计算强度高的程序，才更容易被 SIMD/GPU 等加速</p>
<blockquote>
<p>arithmetric intensity</p>
<p>每 byte 内存访问对应的浮点运算次数。可用于预测 vector 支持对程序性能的提升</p>
</blockquote>
<p>给定的系统，不同计算强度的程序被不同因素限制住。计算强度低的程序，访存多而计算少，内存带宽跟不上，被带宽限制；计算强度高的程序，计算多而访存少，被浮点部件性能限制。因此，表现到图上就是 roofline 形状：随着计算强度增加，程序的 $\text{GFLOP/s}$ 提升；提升到了浮点性能极限时候，再改变计算强度，能实现的 $\text{GFLOP/s}$ 也是一条平行线。</p>
<p>$$
\begin{aligned}
\text{Attainable GFLOP/s}=\min( &amp;\text{Peak Memory BW}\times\text{Arithmetic Intensity}, \\
&amp; \text{Peak Floating-Point Perf})
\end{aligned}
$$</p>
<h3 id="向量架构">向量架构</h3>
<ol>
<li>向量寄存器：长的寄存器（eg，RV64V，64bit），一次存一个向量，支持不同数据类型（<code>i8,i16,i32,i64,f16,f32,f64</code>）</li>
<li>向量功能部件</li>
<li>向量访存部件</li>
<li>辅助的标量寄存器</li>
</ol>
<blockquote>
<p>dynamic register typing</p>
<p>每个向量寄存器配置不同的数据类型和长度，而不是在指令中区分</p>
<ol>
<li>简化向量指令的实现</li>
<li>允许关闭不用的寄存器，扩展使用的寄存器位数</li>
<li>不同类型的操作数之间</li>
</ol>
</blockquote>
<blockquote>
<p>convoy</p>
<p>一组可以同时执行的向量指令（必须不存在 structural hazard）。其用时为 chime</p>
</blockquote>
<p>可以简化的认为，通过 convoy 数目表征向量程序用时。同一个 convoy 里面可以出现 RAW，因为向量的一部分元素在一个部件完成后可以直接前递到其他部件。一个 convoy 会处理多个元素，仍然有很高的并行度。</p>
<ul>
<li>RV64V 只允许位置相同的元素进行向量间运算，因此多条流水线可以并行处理各个元素</li>
<li><code>vl</code>寄存器用于标记长度（必然 $\le \rm{mvl}$，maximum vector length）。可以在运行时动态指定（strip mining），只对<code>vl</code>长度进行处理</li>
<li>
<blockquote>
<p>vector-mask control</p>
<p>用一个 mask 条件执行来完成分支</p>
</blockquote>
</li>
<li>向量功能部件要求更好的访存
<ol>
<li>每个周期允许多个访存</li>
<li>支持不连续的访存</li>
<li>允许多核间共享内存</li>
</ol>
</li>
<li>
<blockquote>
<p>stride</p>
<p>对于没有分块缓存的，先按 stride(nonunit strides)预读入向量，将空间不相邻元素转换为逻辑相邻。由于跨 stride 步长加载元素，有可能短时间 GCD 访问同一内存单元，造成阻塞，条件如下$\frac{\text{numbers of banks}}{\text{GCD(stride, number of banks)}}&lt;\text{bank busy time}$</p>
</blockquote>
</li>
<li>
<blockquote>
<p>gather-scatter</p>
<p>对索引访存（eg 稀疏矩阵）进行优化，需要额外的索引寄存器，比起其他访存更慢</p>
</blockquote>
</li>
</ul>
<h3 id="面向多媒体的-simd-扩展">面向多媒体的 SIMD 扩展</h3>
<p>一般不支持 mask registers、gather-scatter 以及 stride 等向量化高级优化手段，一般要求固定的向量长度和类型（从而导致指令集膨胀，每种数据类型对应一条指令），因此向量化程序不容易编写，编译器不容易优化，一般只针对专门的多媒体库（音视频的数据表示一般不需要全长度）或者是手写内嵌汇编。实例有 intel 的 MMX，SSE，AVX（开始支持高级操作）等。SIMD 扩展可能带来历史兼容性的问题。</p>
<ol>
<li>再增加基本运算单元花销小（模式简单，MMX 用原先的 64bit 浮点寄存器支持$8\times 8$-bit 或$4\times 16$-bit 的操作），容易支持</li>
<li>比起专门的 vector 架构，添加 SIMD 支持给处理器带来额外的状态，需要在上下文切换时候保存</li>
<li>vector architecture 需要内存带宽支持发挥最大性能</li>
<li>一般的 SIMD 扩展要求内存对齐访问，对于虚拟内存实现方便，不会跨页 page fault</li>
<li>向量长度定长，便于加入新的向量操作来支持新的多媒体应用需求</li>
</ol>
<h3 id="gpu">GPU</h3>
<h4 id="cuda">CUDA</h4>
<p>Nvidia 为其 GPU 提供了兼容 C/C++的编程解决方案，CUDA。</p>
<ul>
<li>GPU 上运行的函数标识 <code>__device__</code> <code>__global__</code> ；CPU 上运行的函数标识<code> __host__</code></li>
<li>CUDA 变量 <code>__device__</code> ，分配在 GPU Memory 上，所有的 multithreaded SIMD Processors 可访问</li>
<li>函数调用形式为 <code>name&lt;&lt;&lt;dimGrid, dimBlock&gt;&gt;&gt; (… parameter list…)</code>
<ul>
<li><code>dimGrid</code>规定 thread block 数目，用<code>blockIdx</code>索引</li>
<li><code>dimBlock</code>规定一个 block 内 thread 数目，用<code>threadIdx</code>索引</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// Invoke DAXPY
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">daxpy</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// DAXPY in C
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">daxpy</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="o">*</span><span class="n">y</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Invoke DAXPY with 256 threads per Thread Block
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">__host__</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">nblocks</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span> <span class="mi">255</span><span class="p">)</span> <span class="o">/</span> <span class="mi">256</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">daxpy</span><span class="o">&lt;&lt;&lt;</span><span class="n">nblocks</span><span class="p">,</span> <span class="mi">256</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// DAXPY in CUDA
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">daxpy</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="o">*</span><span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="o">*</span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>CUDA 会编译成 PTX（Parallel Thread Execution）指令集，有如下格式</p>
<pre tabindex="0"><code class="language-x86asm" data-lang="x86asm">opcode.type d, a, b, c;
</code></pre><ul>
<li>type 类型，bits/整形/浮点</li>
<li>d 目标</li>
<li>a，b，c 源</li>
</ul>
<p>原先的<code>DAXPY</code>对应的汇编如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">shl.u32</span> <span class="no">R8</span><span class="p">,</span> <span class="no">blockIdx</span><span class="p">,</span> <span class="mi">8</span> <span class="c">; Thread Block ID * Block size ;(256 or 28)
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">add.u32</span> <span class="no">R8</span><span class="p">,</span> <span class="no">R8</span><span class="p">,</span> <span class="no">threadIdx</span> <span class="c">; R8 = i = my CUDA Thread ID
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">shl.u32</span> <span class="no">R8</span><span class="p">,</span> <span class="no">R8</span><span class="p">,</span> <span class="mi">3</span> <span class="c">; byte offset
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">ld.global.f64</span> <span class="no">RD0</span><span class="p">,</span> <span class="p">[</span><span class="no">X</span><span class="err">+</span><span class="no">R8</span><span class="p">]</span><span class="c">; RD0 = X[i]
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">ld.global.f64</span> <span class="no">RD2</span><span class="p">,</span> <span class="p">[</span><span class="no">Y</span><span class="err">+</span><span class="no">R8</span><span class="p">]</span><span class="c">; RD2 = Y[i]
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">mul.f64</span> <span class="no">RD0</span><span class="p">,</span> <span class="no">RD0</span><span class="p">,</span> <span class="no">RD4</span> <span class="c">; Product in RD0 = RD0 * RD4 (scalar a)
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">add.f64</span> <span class="no">RD0</span><span class="p">,</span> <span class="no">RD0</span><span class="p">,</span> <span class="no">RD2</span> <span class="c">; Sum in RD0 = RD0 + RD2 (Y[i])
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">st.global.f64</span> <span class="p">[</span><span class="no">Y</span><span class="err">+</span><span class="no">R8</span><span class="p">],</span> <span class="no">RD0</span><span class="c">; Y[i] = sum (X[i]*a + Y[i])
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>PTX 的所有访存模式都是 gather-scatter。为了加速顺序访问，要求访存遵守 Address Coalescing 的规则，以便合并为块访存。</p>
<p>GPU 使用 mask(编译器和硬件隐性设置，而不是显式有指令设置)和 branch synchronization stack（线程私有，每个条目一个标识符，一个目标地址，一个 mask）显式执行分支。预先算出 mask，压栈，使用 IF-THEN-ELSE 模式执行（要么执行 THEN 要么执行分支 ELSE）。除非全 0/1，会跳过其中一个分支，否则分支永远带来额外开销。因为 GPU Thread 之间强依赖，同一个 Thread Block 内的 lane 要么执行相同的指令，要么闲置，不能像操作系统线程那样分别执行。该机制同样适用于向量长度不是整数倍情况。</p>
<p>对于以下代码，对应 PTX 汇编</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">   <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Z</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">ld.global.f64</span> <span class="no">RD0</span><span class="p">,</span> <span class="p">[</span><span class="no">X</span><span class="err">+</span><span class="no">R8</span><span class="p">]</span> <span class="c">; RD0 = X[i]
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">setp.neq.s32</span> <span class="no">P1</span><span class="p">,</span> <span class="no">RD0</span><span class="p">,</span> <span class="c">#0 ;P1 is predicate reg 1
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="err">@</span><span class="p">!</span><span class="no">P1</span><span class="p">,</span> <span class="no">bra</span> <span class="no">ELSE1</span><span class="p">,</span> <span class="p">*</span><span class="no">Push</span> <span class="c">; Push old mask, set new
</span></span></span><span class="line"><span class="cl"><span class="c"></span>						<span class="c">; mask bits if P1 false, go to ELSE1
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">ld.global.f64</span> <span class="no">RD2</span><span class="p">,</span> <span class="p">[</span><span class="no">Y</span><span class="err">+</span><span class="no">R8</span><span class="p">]</span><span class="c">; RD2 = Y[i]
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">sub.f64</span> <span class="no">RD0</span><span class="p">,</span> <span class="no">RD0</span><span class="p">,</span> <span class="no">RD2</span><span class="c">; Difference in RD0
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">st.global.f64</span> <span class="p">[</span><span class="no">X</span><span class="err">+</span><span class="no">R8</span><span class="p">],</span> <span class="no">RD0</span><span class="c">; X[i] = RD0
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="err">@</span><span class="no">P1</span><span class="p">,</span> <span class="no">bra</span> <span class="no">ENDIF1</span><span class="p">,</span> <span class="p">*</span><span class="no">Comp</span><span class="c">; complement mask bits
</span></span></span><span class="line"><span class="cl"><span class="c"></span>						<span class="c">; if P1 true, go to ENDIF1
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">ELSE1</span><span class="p">:</span> <span class="no">ld.global.f64</span> <span class="no">RD0</span><span class="p">,</span> <span class="p">[</span><span class="no">Z</span><span class="err">+</span><span class="no">R8</span><span class="p">]</span> <span class="c">; RD0 = Z[i]
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">st.global.f64</span> <span class="p">[</span><span class="no">X</span><span class="err">+</span><span class="no">R8</span><span class="p">],</span> <span class="no">RD0</span> <span class="c">; X[i] = RD0
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">ENDIF1</span><span class="p">:</span><span class="err">&lt;</span><span class="no">next</span> <span class="no">instruction</span><span class="err">&gt;</span><span class="p">,</span> <span class="p">*</span><span class="no">Pop</span>
</span></span><span class="line"><span class="cl"><span class="c">; pop to restore old mask
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="层次结构">层次结构</h4>
<p>代码组织成 3 层：</p>
<ol>
<li>Grid：一段并行的任务</li>
<li>Thread Block：在一个处理器（Streaming Multiprocessor）上并行的代码段，共用 local memory 和一组寄存器（<strong>数目有限</strong>）</li>
<li>Thread：串行执行的代码段，寄存器<strong>有上限</strong>的从共用寄存器按需分配</li>
</ol>
<p>两层调度</p>
<ol>
<li>Thread Block Scheduler：把 Gird 或多个 Thread Block 在处理器之间调度</li>
<li>SIMD Thread Scheduler：单个 Thread Block 在处理器内调度，内部类似 SIMD 指令，彼此独立，可以使用 <a href="#scoreboard">scoreboard 乱序追踪指令</a>以掩盖访存延迟</li>
</ol>
<p>存储层次</p>
<ol>
<li>private memory：在片外 DRAM 上，thread 私有一小部分</li>
<li>local memory：片内的高带宽低延迟存储，对 multiprocessor 内私有，但如果多个 Thread Block 同时执行，不能在之间共享状态</li>
<li>GPU memory：片外 DRAM 上，host 能读写</li>
</ol>
<h4 id="对照">对照</h4>
<table>
<thead>
<tr>
<th>方面</th>
<th>vector architecture</th>
<th>GPU</th>
</tr>
</thead>
<tbody>
<tr>
<td>隐藏访存延迟</td>
<td>深流水线，不同流水级之间重叠执行</td>
<td>多 thread</td>
</tr>
<tr>
<td>分支</td>
<td>显式设置 mask</td>
<td>硬件和汇编器隐式设置 mask 和 stack</td>
</tr>
<tr>
<td>控制</td>
<td>专门的 control processor：调度、算标量、算地址</td>
<td>只有 scheduler，自己计算地址（之后 Address Coalescing）、算标量</td>
</tr>
<tr>
<td>标量计算</td>
<td>专门的 scalar 部分，片上网络连接</td>
<td>靠 CPU，PCIe 总线连接，开销更大</td>
</tr>
<tr>
<td>并行部件</td>
<td>lane 数目少，寄存器少</td>
<td>lane 很多，multiprocessor 也多，寄存器空间大</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>More Descriptive Name used in this Book</th>
<th>Closest old term outside of GPUs</th>
<th>Official CUDA/ NVIDIA Term</th>
<th>Book Definition and OpenCL Terms</th>
<th>Official CUDA/NVIDIA Definition</th>
</tr>
</thead>
<tbody>
<tr>
<td>Vectorizable Loop</td>
<td>Vectorizable Loop</td>
<td>Grid</td>
<td>A vectorizable loop, executed on the GPU, made up of 1 or more “Thread Blocks” (or bodies of vectorized loop) that can execute in parallel.OpenCL name is “index range.”</td>
<td>A Grid is an array of Thread Blocks that can execute concurrently, equentially, or a mixture.</td>
</tr>
<tr>
<td>Body of Vectorized Loop</td>
<td>Body of a (Strip-Mined) Vectorized Loop</td>
<td>Thread Block</td>
<td>A vectorized loop executed on a “Streaming Multiprocessor” (multithreaded SIMD processor), made up of 1 or more “Warps” (or threads of SIMD instructions). These “Warps” (SIMD Threads) can communicate via “Shared Memory” (Local Memory). OpenCL calls a thread block a “work group.”</td>
<td>A Thread Block is an array of CUDA threads that execute concurrently together and can cooperate and communicate via Shared Memory and barrier synchronization. A Thread Block has a Thread Block ID within its Grid.</td>
</tr>
<tr>
<td>Sequence of SIMD Lane Operations</td>
<td>One iteration of a Scalar Loop</td>
<td>CUDA Thread</td>
<td>A vertical cut of a “Warp” (or thread of SIMD instructions) corresponding to one element executed by one “Thread Processor” (or SIMD lane). Result is stored depending on mask. OpenCL calls a CUDA thread a “work item.”</td>
<td>A CUDA Thread is a lightweight thread that executes a sequential program and can cooperate with other CUDA threads executing in the same Thread Block. A CUDA thread has a thread ID within its Thread Block.</td>
</tr>
<tr>
<td>A Thread of SIMD Instructions</td>
<td>Thread of Vector Instructions</td>
<td>Warp</td>
<td>A traditional thread, but it contains just SIMD instructions that are executed on a “Streaming Multiprocessor” (multithreaded SIMD processor). Results stored depending on a per element mask.</td>
<td>A Warp is a set of parallel CUDA Threads (e.g., 32) that execute the same instruction together in a multithreaded SIMT/SIMD processor.</td>
</tr>
<tr>
<td>SIMD Instruction</td>
<td>Vector Instruction</td>
<td>PTX Instruction</td>
<td>A single SIMD instruction executed across the “Thread Processors” (SIMD lanes).</td>
<td>A PTX instruction specifies an instruction executed by a CUDA Thread.</td>
</tr>
<tr>
<td>Multithreaded SIMD Processor</td>
<td>(Multithreaded) Vector Processor</td>
<td>Streaming Multiprocessor</td>
<td>Multithreaded SIMD processor that executes “Warps” (thread of SIMD instructions), independent of other SIMD processors. OpenCL calls it a “Compute Unit.” However, CUDA programmer writes program for one lane rather than for a “vector” of multiple SIMD lanes.</td>
<td>A Streaming Multiprocessor (SM) is a multithreaded SIMT/SIMD processor that executes Warps of CUDA Threads. A SIMT program specifies the execution of one CUDA thread, rather than a vector of multiple SIMD lanes.</td>
</tr>
<tr>
<td>Thread Block Scheduler</td>
<td>Scalar Processor</td>
<td>Giga Thread Engine</td>
<td>Assigns multiple “Thread Blocks” (or body of vectorized loop) to “Streaming Multiprocessors” (multithreaded SIMD processors).</td>
<td>Distributes and schedules Thread Blocks of a Grid to Streaming Multiprocessors as resources become available.</td>
</tr>
<tr>
<td>SIMD Thread Scheduler</td>
<td>Thread Scheduler in a Multithread CPU</td>
<td>Warp Scheduler</td>
<td>Hardware unit that schedules and issues “Warps” (threads of SIMD instructions) when they are ready to execute; includes a scoreboard to track “Warp” (SIMD thread) execution.</td>
<td>A Warp Scheduler in a Streaming Multiprocessor schedules Warps for execution when their next instruction is ready to execute.</td>
</tr>
<tr>
<td>SIMD Lane</td>
<td>Vector Lane</td>
<td>Thread Processor</td>
<td>Hardware SIMD Lane that executes the operations in a “Warp” (thread of SIMD instructions) on a single element. Results stored depending on mask. OpenCL calls it a “Processing Element.”</td>
<td>A Thread Processor is a datapath and register file portion of a Streaming Multiprocessor that executes operations for one or more lanes of a Warp.</td>
</tr>
<tr>
<td>GPU Memory</td>
<td>Main Memory</td>
<td>Global memory</td>
<td>DRAM memory accessible by all “Streaming Multiprocessors” (or multithreaded SIMD processors) in a GPU. OpenCL calls it “Global Memory.”</td>
<td>Global Memory is accessible by all CUDA Threads in any Thread Block in any Grid. Implemented as a region of DRAM, and may be cached.</td>
</tr>
<tr>
<td>Private Memory</td>
<td>Stack / Thread Local Storage(OS)</td>
<td>Local Memory</td>
<td>Portion of DRAM memory private to each “Thread Processor” (SIMD lane). OpenCL calls it “Private Memory.”</td>
<td>Private “thread-local” memory for a CUDA Thread. Implemented as a cached region of DRAM.</td>
</tr>
<tr>
<td>Local Memory</td>
<td>Local Memory</td>
<td>Shared Memory</td>
<td>Fast local SRAM for one “Streaming Multiprocessor” (multithreaded SIMD processor), unavailable to other Streaming Multiprocessors. OpenCL calls it “Local Memory.”</td>
<td>Fast SRAM memory shared by the CUDA Threads composing a Thread Block, and private to that Thread Block. Used for communication among CUDA Threads in a Thread Block at barrier synchronization points.</td>
</tr>
<tr>
<td>SIMD Lane Registers</td>
<td>Vector Lane Registers</td>
<td>Registers</td>
<td>Registers in a single “Thread Processor” (SIMD lane) allocated across full “Thread Block” (or body of vectorized loop).</td>
<td>Private registers for a CUDA Thread. Implemented as multithreaded register file for certain lanes of several warps for each thread processor.</td>
</tr>
</tbody>
</table>
<h3 id="loop-level-parallelism-改进">Loop-level parallelism 改进</h3>
<p>在源码（或者接近源码级别检测）</p>
<blockquote>
<p>loop-carried dependence</p>
<p>循环依赖于之前的结果</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">//没有 loop-carried dependence
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">999</span><span class="p">;</span> <span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">   <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//有 loop-carried dependence
</span></span></span><span class="line"><span class="cl"><span class="c1">// S1 S2 都有对自身的循环依赖（有自环，无法消除）
</span></span></span><span class="line"><span class="cl"><span class="c1">// S2 还有循环内对S1的依赖
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="cm">/* S1 */</span>
</span></span><span class="line"><span class="cl">   <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span> <span class="cm">/* S2 */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//有 loop-carried dependence也可以改进
</span></span></span><span class="line"><span class="cl"><span class="c1">// S2 不是成环依赖 S1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="cm">/* S1 */</span>
</span></span><span class="line"><span class="cl">   <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="cm">/* S2 */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 可以改成能并行的版本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">99</span><span class="p">;</span> <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">   <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">B</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span> <span class="o">=</span> <span class="n">C</span><span class="p">[</span><span class="mi">99</span><span class="p">]</span> <span class="o">+</span> <span class="n">D</span><span class="p">[</span><span class="mi">99</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 特殊的 recurrence 形式的循环依赖
</span></span></span><span class="line"><span class="cl"><span class="c1">// 一些架构/语言对 recurrence 有专门支持
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">;</span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="依赖检测">依赖检测</h4>
<blockquote>
<p>Affine</p>
<p>当一维数组的索引可以写成 $a\times i +b$的形式，当中$a,b$为常数，$i$为循环变量，索引可认为 affine。当多维数组中每一维的索引满足 affine，索引可认为 affine</p>
<p>一般的稀疏访问<code>x[y[i]]</code>，一般不是 affine 的</p>
</blockquote>
<p>对应 affine 的索引，同一个数组分别按照$a\times i +b$ 、 $c\times i+d$进行索引，$i\in [m,n]$时，有依赖关系</p>
<ol>
<li>两个索引$m\le j\le n,m\le k \le n$</li>
<li>存在$a\times j+b=c\times k+d$的访问</li>
</ol>
<p>可以简化的使用 GCD（最大公因数）法检测。只保证充分性；因为未考虑边界条件，所以不满足必要性。事实上，检测依赖属于 $\mathcal{NP}-Complete$ 问题</p>
<p>$$(d-b)\mod\rm{GCD}(c,a)=0$$</p>
<h4 id="另一种依赖消除">另一种依赖消除</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 有循环依赖
</span></span></span><span class="line"><span class="cl"><span class="c1">// 具有 reduction 形式，有些语言/硬件有特殊支持
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">9999</span><span class="p">;</span> <span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">sum</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//改进为
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">9999</span><span class="p">;</span> <span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">sum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">9999</span><span class="p">;</span> <span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">finalsum</span> <span class="o">=</span> <span class="n">finalsum</span> <span class="o">+</span> <span class="n">sum</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 假设10核，可以分摊到多核上处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">9999</span><span class="p">;</span> <span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">finalsum</span> <span class="o">=</span> <span class="n">finalsum</span> <span class="o">+</span> <span class="n">sum</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="fallacy-2">Fallacy</h3>
<ol>
<li>GPU 和 CPU 分离不好
<ul>
<li>分离主内存和 GPU 内存有劣势（eg，需要专门的内存复制<code>cudaMemcpy()</code>）</li>
<li>PTX 指令集和硬件可以根据环境需求动态增减特性，而且不影响 CPU 端的体系结构</li>
<li>同时 GPU 端也和 CPU 端的体系结构变动解耦</li>
</ul>
</li>
<li>不给 vector architecture 提供足够的访存带宽
<ul>
<li>记住<a href="#roofline-model">roofline 模型</a>，足够的内存带宽才能有足够数据喂饱计算能力</li>
</ul>
</li>
<li>如果 GPU 访存性能不好，无脑增加 thread 数目
<ul>
<li>thread 之间需要能够访存融合，否则会导致单独的大量访存反而影响性能</li>
<li>thread 本身也需要足够好的访存局部性</li>
</ul>
</li>
</ol>
<h3 id="pitfall-2">Pitfall</h3>
<ol>
<li>忽略启动开销来对比 vector architecture 之间的峰值性能
<ul>
<li>早期向量架构启动很慢，短向量（eg，$\le 100$）还不如直接用标量处理器</li>
</ul>
</li>
<li>只关注 vector architecture 的向量性能，不关注标量性能
<ul>
<li>注意 Amdahl 定律，标量性能很有用（eg，strip mining，不满长的向量的下标索引）</li>
<li>增加 SIMD lane 数目同时，需要响应提升标量部分性能</li>
</ul>
</li>
</ol>
<h2 id="ch-5-thread-level-parallelism">ch 5 Thread-Level Parallelism</h2>
<p>本章主要关注 TLP（Thread-Level Parallelism），通过 MIMD 形式的并行。注意，SMP 和 NUMA 的地址空间都是统一的，都可以通过 shared memory 共享和通信，而不是只能通过网络连接。但是，发掘 TLP 有很多困难：</p>
<ol>
<li>Amdahl 定律下，程序并行部分有限</li>
<li>共享内存访问延迟很高</li>
<li>Dennard scaling 失效，芯片有功耗限制，不能无限制堆核</li>
</ol>
<blockquote>
<p>Dennard scaling</p>
<p>在晶体管特征尺寸缩小同时，供应电压降低。使得单位面积的功耗近似不变</p>
</blockquote>
<blockquote>
<p>SMP</p>
<p>symmetric (shared-memory) multiprocessors，或者是 centralized shared-memory multiprocessors。所有核平等共享一个中心的内存</p>
<p>UMA</p>
<p>uniform memory access (UMA) multiprocessors</p>
</blockquote>
<blockquote>
<p>NUMA</p>
<p>Nonuniform Memory Access。对内存的访问时间不是相同的</p>
<p>NUCA</p>
<p>Nonuniform Cache Access。对 cache 的访问时间不是相同的</p>
<p>DSM</p>
<p>distributed shared memory，为了支持更多核/处理器，物理上划分内存为多个</p>
</blockquote>
<h3 id="memory-consistency-模型">Memory Consistency 模型</h3>
<p>对于程序员，主要依赖可靠的并行库提供的同步操作来保证正确性，因为为了确保底层体系结构确实实现同步</p>
<blockquote>
<p>synchronized/data-race-free</p>
<p>对于程序，所有共享部分访问都被同步操作排序</p>
</blockquote>
<p>最简单也直观的 Memory Consistency 模型是 Sequential Consistency。但是该模型性能不好。</p>
<blockquote>
<p>Sequential Consistency</p>
<p>（执行结果就像，可以实际上不是）每个处理器的访存保持顺序，处理器之间访存可以任意交叉</p>
</blockquote>
<p>为了提高性能，可以放松访存一致性的要求。使用$\to$ 表示顺序，不同的一致性模型对不同操作之间的顺序有不同的要求。</p>
<ul>
<li>$R$为一般的读操作</li>
<li>$W$为一般的写操作</li>
<li>$S$为任意的同步操作</li>
<li>$S_A$为取得的同步操作（类似<code>lock()</code>）</li>
<li>$S_R$为释放的同步操作（类似<code>unlock()</code>）</li>
</ul>
<table>
<thead>
<tr>
<th>Model</th>
<th>Used in</th>
<th>Ordinary orderings</th>
<th>Synchronization orderings</th>
</tr>
</thead>
<tbody>
<tr>
<td>Sequential consistency</td>
<td>Most machines as an optional mode</td>
<td>$\mathrm{R\to R,R\to W}$,$\mathrm{W\to R,W\to W}$</td>
<td>$\mathrm{S\to W, S\to R, R\to S, W\to S, S\to S}$</td>
</tr>
<tr>
<td>Total store order or processor consistency</td>
<td>IBMS/370, DEC VAX, SPARC</td>
<td>$\mathrm{R\to R,R\to W}$,$\mathrm{W\to W}$</td>
<td>$\mathrm{S\to W, S\to R, R\to S, W\to S, S\to S}$</td>
</tr>
<tr>
<td>Partial store order</td>
<td>SPARC</td>
<td>$\mathrm{R\to R,R\to W}$</td>
<td>$\mathrm{S\to W, S\to R, R\to S, W\to S, S\to S}$</td>
</tr>
<tr>
<td>Weak ordering</td>
<td>PowerPC</td>
<td></td>
<td>$\mathrm{S\to W, S\to R, R\to S, W\to S, S\to S}$</td>
</tr>
<tr>
<td>Release consistency</td>
<td>MIPS, RISC V, Armv8, C, and C++ specifications</td>
<td></td>
<td>$\mathrm{S_A\to W, S_A\to R, R\to S_R, W\to S_R}$,$\mathrm{ S_A\to S_A, S_A\to S_R, S_R\to S_A, S_R\to S_R}$</td>
</tr>
</tbody>
</table>
<p><img loading="lazy" src="/assets/img/note/caaqa/memory-consistency.png" alt=""  />
</p>
<h3 id="centralized-shared-memory-architectures">Centralized Shared-Memory Architectures</h3>
<blockquote>
<p>coherent 的内存</p>
<ol>
<li>P 写了位置 X，在没有其他处理器写位置 X 时，P 再读位置 X，读到自己写的值</li>
<li>P 写完位置 X，Q 在足够间隔且没有其他写的情况下读位置 X，应该能看到 P 写的值</li>
<li>
<blockquote>
<p>write serialization</p>
<p>写同一位置的顺序是一致的：P 先写 Q 后写对于所有处理器都是一样的</p>
</blockquote>
</li>
</ol>
</blockquote>
<p>Coherence 和 Consistency（<a href="#memory-consistency-%E6%A8%A1%E5%9E%8B">参见上面部分</a> ） 侧重点不一样。Coherence 规定同一位置的读写行为；Consistency 规定涉及其他位置访存时候的读写行为。维护 cache coherence 有两种方向的协议：<a href="#directory-based">Directory based</a> 和<a href="#snooping">Snooping</a></p>
<h3 id="snooping">Snooping</h3>
<blockquote>
<p>Snooping</p>
<p>基于侦听。每个缓存共享内存的处理器自己追踪状态变化。可以通过比如侦听总线上广播的形式</p>
</blockquote>
<p>有两种主要的 snooping 的变种</p>
<ol>
<li>
<blockquote>
<p>write invalidate</p>
<p>处理器在能写共享部分之前，先独占的拥有其。因此，每次写都会使得其他处理器上副本失效</p>
</blockquote>
</li>
<li>
<blockquote>
<p>write update/write broadcast</p>
<p>根据写的结果，广播更新其他副本</p>
</blockquote>
</li>
</ol>
<p>一般的 Snooping 协议实现都是每个处理器和 cache 维护一个有限状态机。对于一个简化版协议，可以认为一共有 3 种状态，Invalid,Shared 和 Modified，这也被称为 MSI 协议。对于使用 write invalidate，write back cache 的 Snooping 协议，cache 状态转移图表示如下。具体细节有表格。注意，这里假定各操作是原子的。如果是单一的中心化总线，可以把总线的获取和释放用于同步。多总线可以指定每条总线负责一个范围的共享内存。</p>
<p><img loading="lazy" src="/assets/img/note/caaqa/snooping-fsm.png" alt=""  />
</p>
<table>
<thead>
<tr>
<th>请求</th>
<th>源</th>
<th>对应 cache 块状态</th>
<th>cache 行动</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>Read hit</td>
<td>Processor</td>
<td>Shared/modified</td>
<td>正常命中</td>
<td>把数据读进 local cache</td>
</tr>
<tr>
<td>Read miss</td>
<td>Processor</td>
<td>Invalid</td>
<td>正常缺失</td>
<td>总线上广播 read miss</td>
</tr>
<tr>
<td>Read miss</td>
<td>Processor</td>
<td>Shared</td>
<td>替换</td>
<td>共享地址的缺失: 总线上广播 read miss</td>
</tr>
<tr>
<td>Read miss</td>
<td>Processor</td>
<td>Modified</td>
<td>替换</td>
<td>共享地址的缺失: 先写回，再在总线上广播 read miss</td>
</tr>
<tr>
<td>Write hit</td>
<td>Processor</td>
<td>Modified</td>
<td>正常命中</td>
<td>向 local cache 写数据</td>
</tr>
<tr>
<td>Write hit</td>
<td>Processor</td>
<td>Shared</td>
<td>Coherence</td>
<td>总线上广播 invalidate，因为不会去 fetch 数据，只是改变数据的状态，这一般被称为 upgrade 或者 ownership misses</td>
</tr>
<tr>
<td>Write miss</td>
<td>Processor</td>
<td>Invalid</td>
<td>正常缺失</td>
<td>在总线上广播 write miss</td>
</tr>
<tr>
<td>Write miss</td>
<td>Processor</td>
<td>Shared</td>
<td>替换</td>
<td>共享地址的缺失: 在总线上广播 write miss</td>
</tr>
<tr>
<td>Write miss</td>
<td>Processor</td>
<td>Modified</td>
<td>替换</td>
<td>共享地址的缺失:先写回;然后在总线上广播 write miss</td>
</tr>
<tr>
<td>Read miss</td>
<td>Bus</td>
<td>Shared</td>
<td>无需行动</td>
<td>用自己的 cache 或者内存的内容去解决其他处理器的 read miss.</td>
</tr>
<tr>
<td>Read miss</td>
<td>Bus</td>
<td>Modified</td>
<td>维护一致性</td>
<td>其他处理器尝试读共享数据: 把自己的 cache 块广播到总线, 写回，然后把自己数据状态改成 shared</td>
</tr>
<tr>
<td>Invalidate</td>
<td>Bus</td>
<td>Shared</td>
<td>维护一致性</td>
<td>其他处理器尝试写共享数据; 把自己数据变为 invalidate 态</td>
</tr>
<tr>
<td>Write miss</td>
<td>Bus</td>
<td>Shared</td>
<td>维护一致性</td>
<td>其他处理器尝试读共享数据： 把自己数据变为 invalidate 态</td>
</tr>
<tr>
<td>Write miss</td>
<td>Bus</td>
<td>Modified</td>
<td>维护一致性</td>
<td>其他处理器尝试写独占的数据：写回，然后把自己数据变为 invalidate 态</td>
</tr>
</tbody>
</table>
<p>除了最基本的 MSI 协议，还可以拓展更多状态。比如</p>
<ul>
<li>MESI：多了 Exclusive。E 状态表示只有一个处理器有副本，而且是 clean 的，写的时候不需要广播 invalidate 消息，因此不需要再次访问总线而有开销；当其他处理器对其 read miss，就会转为 Shared 态。可以通过 dirty 位来区别 Exclusive 和 Modified 态</li>
<li>MESIF：多了 Exclusive 和 Forward，F 用来在分布式内存环境下，指定某个（共享中的）处理器处理请求</li>
<li>MOESI：多了 Exclusive 和 Owned。如果其他处理器需要读 Modified 的数据，原先处理器状态转为 Owned 态，而先不写回内存。O 态表示内存数据不是最新的，该数据相关的 miss 由仅有一个的 O 态处理器负责提供（eg，AMD Opteron）</li>
</ul>
<p>snooping 协议可能有以下问题导致可拓展性不好</p>
<ol>
<li>总线负担大</li>
<li>cache 负担大，需要检查每个 invalidate 信号</li>
</ol>
<blockquote>
<p>coherence miss</p>
<p>由于缓存一致性协议导致的 cache miss</p>
<ul>
<li>true sharing：真正的缺失，比如其他处理器要求独占之后的缺失</li>
<li>false sharing：同一个 cache line 当中，实际没有共享数据被共享部分涉及而产生的缺失</li>
</ul>
</blockquote>
<h3 id="directory-based">Directory based</h3>
<blockquote>
<p>Directory based</p>
<p>基于目录。共享内存的状态被一块专门的目录（directory）管理，在 SMP 中维护一个中心化的目录，而在 NUMA 中目录也要分布开</p>
</blockquote>
<p>简单的目录协议中，除了单独的 cache 块有 MSI3 种状态，目录本身有 3 种状态。可以使用位图，每个位表示某个处理器是否持有副本（eg， intel i7）。NUMA 架构里，目录和对应管理的共享存储可以放在一起，保证分布式的目录可以被唯一的确定和找到。</p>
<ol>
<li>Shared：至少一个节点有副本，而且内存里是最新值</li>
<li>Uncached：没有节点有副本</li>
<li>Modified：有且只有一个节点有最新的副本，内存里是旧的值</li>
</ol>
<p>和 snooping 协议里广播和侦听总线不同，目录协议直接对特定节点发消息。这里假定消息收发是 FIFO 的，消息之间处理是原子的。为了方便，节点做如下区分</p>
<ol>
<li>local node：发送请求的节点</li>
<li>home node：请求地址对应内存和目录的管理节点</li>
<li>remote node：拥有数据副本的节点</li>
</ol>
<table>
<thead>
<tr>
<th>消息类型</th>
<th>源</th>
<th>目的</th>
<th>内容</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Read miss</td>
<td>Local cache</td>
<td>Home directory</td>
<td>P, A</td>
<td>节点 P 读地址 A 出现 read miss，请求数据，并把节点 P 设置为读共享</td>
</tr>
<tr>
<td>Write miss</td>
<td>Local cache</td>
<td>Home directory</td>
<td>P, A</td>
<td>节点 P 写地址 A 出现 write miss，请求数据，并把节点 P 设置为独占</td>
</tr>
<tr>
<td>Invalidate</td>
<td>Local cache</td>
<td>Home directory</td>
<td>A</td>
<td>请求共享地址 A 的节点发送 invalidate（不是真的发了 invalidate，和下一项区分）</td>
</tr>
<tr>
<td>Invalidate</td>
<td>Home directory</td>
<td>Remote cache</td>
<td>A</td>
<td>把地址 A 的数据副本置 invalid</td>
</tr>
<tr>
<td>Fetch</td>
<td>Home directory</td>
<td>Remote cache</td>
<td>A</td>
<td>请求地址 A 的数据，更新 home 节点的数据和目录，并把持有地址 A 数据的节点置为共享态</td>
</tr>
<tr>
<td>Fetch/ invalidate</td>
<td>Home directory</td>
<td>Remote cache</td>
<td>A</td>
<td>请求地址 A 的数据，更新 home 节点的数据和目录，并把持有地址 A 数据的节点置为 invalid</td>
</tr>
<tr>
<td>Data value reply</td>
<td>Home directory</td>
<td>Local cache</td>
<td>D</td>
<td>从 home 内存取值发出去</td>
</tr>
<tr>
<td>Data writeback</td>
<td>Remote cache</td>
<td>Home directory</td>
<td>A, D</td>
<td>把地址 A 的数据写回到 home 内存</td>
</tr>
</tbody>
</table>
<p>对于一个单独的 cache 块，其状态转移图非常类似 snooping 协议（把来自 local 的消息标黑，来自 home 的消息标灰）</p>
<p><img loading="lazy" src="/assets/img/note/caaqa/dir-cache-fsm.png" alt=""  />
</p>
<p>而目录对于 cache 块和消息的也有状态转移图（注意，对于目录而言，所有改变都是因为有外部的请求，所以全部标灰）</p>
<p><img loading="lazy" src="/assets/img/note/caaqa/dir-dir-fsm.png" alt=""  />
</p>
<h3 id="同步操作">同步操作</h3>
<p>常见的硬件同步原语有</p>
<ul>
<li>atomic-echange：原子的交换</li>
<li>fetch-and-add(FA)：原子加，共识数小，但是简单，不容易竞争</li>
<li>compare-and-set (CAS)：比较预期值和内存变量，相等时候改为新传入的值，反之不修改，返回执行之后的内存变量值，会有 ABA 问题</li>
<li>load-reserved 和 store-conditional：成对使用，在<code>lr</code>预定一个地址到<code>sc</code>写同一个地址之间，如果有其他的写，<code>sc</code>会返回非零错误值，天然免疫 ABA 问题，但是多核容易导致竞争抖动</li>
</ul>
<p>可以用<code>lr,sc</code>来实现其他同步原语效果</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="c">; atomic exchange
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nl">try:</span>  <span class="nf">mov</span> <span class="no">x3</span><span class="p">,</span><span class="no">x4</span> <span class="c">;mov exchange value
</span></span></span><span class="line"><span class="cl"><span class="c"></span>      <span class="no">lr</span> <span class="no">x2</span><span class="p">,</span><span class="no">x1</span> <span class="c">;load reserved from
</span></span></span><span class="line"><span class="cl"><span class="c"></span>      <span class="no">sc</span> <span class="no">x3</span><span class="p">,</span><span class="mi">0</span><span class="p">(</span><span class="no">x1</span><span class="p">)</span> <span class="c">;store conditional
</span></span></span><span class="line"><span class="cl"><span class="c"></span>      <span class="no">bnez</span> <span class="no">x3</span><span class="p">,</span><span class="no">try</span> <span class="c">;branch store fails
</span></span></span><span class="line"><span class="cl"><span class="c"></span>      <span class="no">mov</span> <span class="no">x4</span><span class="p">,</span><span class="no">x2</span> <span class="c">;put load value in x4
</span></span></span><span class="line"><span class="cl"><span class="c"></span>
</span></span><span class="line"><span class="cl"><span class="c">; fetch-and-add-1
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nl">try:</span>  <span class="nf">lr</span> <span class="no">x2</span><span class="p">,</span><span class="no">x1</span> <span class="c">;load reserved 0(x1)
</span></span></span><span class="line"><span class="cl"><span class="c"></span>      <span class="no">addi</span> <span class="no">x3</span><span class="p">,</span><span class="no">x2</span><span class="p">,</span><span class="mi">1</span> <span class="c">;increment
</span></span></span><span class="line"><span class="cl"><span class="c"></span>      <span class="no">sc</span> <span class="no">x3</span><span class="p">,</span><span class="mi">0</span><span class="p">(</span><span class="no">x1</span><span class="p">)</span> <span class="c">;store conditional
</span></span></span><span class="line"><span class="cl"><span class="c"></span>      <span class="no">bnez</span> <span class="no">x3</span><span class="p">,</span><span class="no">try</span> <span class="c">;branch store fails
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>进一步的可以用同步原语构件自旋锁（spin-lock）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="c">; 不考虑cache一致性
</span></span></span><span class="line"><span class="cl"><span class="c"></span>         <span class="nf">addi</span> <span class="no">x2</span><span class="p">,</span><span class="no">R0</span><span class="p">,</span><span class="c">#1
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">lockit</span><span class="p">:</span>  <span class="no">EXCH</span> <span class="no">x2</span><span class="p">,</span><span class="mi">0</span><span class="p">(</span><span class="no">x1</span><span class="p">)</span> <span class="c">;atomic exchange
</span></span></span><span class="line"><span class="cl"><span class="c"></span>         <span class="no">bnez</span> <span class="no">x2</span><span class="p">,</span><span class="no">lockit</span> <span class="c">;already locked?
</span></span></span><span class="line"><span class="cl"><span class="c"></span>
</span></span><span class="line"><span class="cl"><span class="c">; 利用cache一致性，缓存lock的变量
</span></span></span><span class="line"><span class="cl"><span class="c">; 1. spining时候只需要读本地变量，不需要远程访存
</span></span></span><span class="line"><span class="cl"><span class="c">; 2. 之后局部性可能更好，以后也用同一个lock
</span></span></span><span class="line"><span class="cl"><span class="c"></span>
</span></span><span class="line"><span class="cl"><span class="nl">lockit:</span>  <span class="nf">ld</span> <span class="no">x2</span><span class="p">,</span><span class="mi">0</span><span class="p">(</span><span class="no">x1</span><span class="p">)</span> <span class="c">;load of lock
</span></span></span><span class="line"><span class="cl"><span class="c"></span>         <span class="no">bnez</span> <span class="no">x2</span><span class="p">,</span><span class="no">lockit</span> <span class="c">;not available-spin
</span></span></span><span class="line"><span class="cl"><span class="c"></span>         <span class="no">addi</span> <span class="no">x2</span><span class="p">,</span><span class="no">R0</span><span class="p">,</span><span class="c">#1 ;load locked value
</span></span></span><span class="line"><span class="cl"><span class="c"></span>         <span class="no">EXCH</span> <span class="no">x2</span><span class="p">,</span><span class="mi">0</span><span class="p">(</span><span class="no">x1</span><span class="p">)</span> <span class="c">;swap
</span></span></span><span class="line"><span class="cl"><span class="c"></span>         <span class="no">bnez</span> <span class="no">x2</span><span class="p">,</span><span class="no">lockit</span> <span class="c">;branch if lock wasn’t0
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>lr,sc</code>原语有效的分离了变量的读写，可以减少总线负担。直接使用<code>lr,sc</code>实现自旋锁如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nl">lockit:</span>  <span class="nf">lr</span> <span class="no">x2</span><span class="p">,</span><span class="mi">0</span><span class="p">(</span><span class="no">x1</span><span class="p">)</span> <span class="c">;load reserved
</span></span></span><span class="line"><span class="cl"><span class="c"></span>         <span class="no">bnez</span> <span class="no">x2</span><span class="p">,</span><span class="no">lockit</span> <span class="c">;not available-spin
</span></span></span><span class="line"><span class="cl"><span class="c"></span>         <span class="no">addi</span> <span class="no">x2</span><span class="p">,</span><span class="no">R0</span><span class="p">,</span><span class="c">#1 ;locked value
</span></span></span><span class="line"><span class="cl"><span class="c"></span>         <span class="no">sc</span> <span class="no">x2</span><span class="p">,</span><span class="mi">0</span><span class="p">(</span><span class="no">x1</span><span class="p">)</span> <span class="c">;store
</span></span></span><span class="line"><span class="cl"><span class="c"></span>         <span class="no">bnez</span> <span class="no">x2</span><span class="p">,</span><span class="no">lockit</span> <span class="c">;branch if store fails
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="fallacy-3">Fallacy</h3>
<ol>
<li>Amdahl 定律对并行计算不适用
<ul>
<li>简单的放缩基准数据集（weak scaling），使得程序串行规模部分几乎不变，只有并行部分放大，会导致虚假的加速比</li>
<li>需要合理衡量 true speedup 时候对串行和并行所用的数据集</li>
</ul>
</li>
<li>多处理器只有实现完美的线性加速比才成本上合算
<ul>
<li>执行时间短（现实中一般只会关注任务用时，而不是每个处理器时间加和）是公认的并行的优势</li>
<li>成本不是简单的正比于处理器数目,还有内存，硬盘，多核芯片等因素</li>
</ul>
</li>
</ol>
<h3 id="pitfall-3">Pitfall</h3>
<ol>
<li>衡量多核性能时候，只考虑执行时间的加速比
<ul>
<li>加速比对比对象：相对低端芯片加速比很大并不一定意味着性能好；对于浮点计算密集程序，如果没有专门硬件部件，或许实现可以接近线性加速比，但性能还是很差</li>
<li>注意区分 relative speedup 和 true speedup，应该对比并行最优的算法和串行的最优算法</li>
</ul>
</li>
<li>没有发展专门对多处理器架构优化的软件
<ul>
<li>eg：在使用锁管理页表的 os 上，即使是完美并行的程序，依然会被页分配制约</li>
</ul>
</li>
</ol>
<h2 id="ch-a-instruction-set-principles">ch A Instruction Set Principles</h2>
<h3 id="isa-特性">ISA 特性</h3>
<p>对于 ISA 设计，其有如下一些考虑：</p>
<ol>
<li>指令集类型
<ol>
<li>栈</li>
<li>累加器</li>
<li>寄存器-内存</li>
<li>寄存器-寄存器/load-store</li>
</ol>
</li>
<li>地址访问：对齐、不对齐</li>
<li>寻址模式
<ol>
<li>立即数 <code>3</code></li>
<li>寄存器 <code>Regs[R4]</code></li>
<li>寄存器访存 <code>Mem[Regs[R4]]</code></li>
<li>寄存器+偏移访存 <code>Mem[Regs[R4]+10]</code></li>
<li>寄存器+寄存器访存 <code>Mem[Regs[R3]+Regs[R4]]</code></li>
<li>立即数访存 <code>Mem[1001]</code></li>
<li>PC 相关 <code>pc</code></li>
<li>寄存器间接访存 <code>Mem[Mem[Regs[R4]]]</code></li>
<li>自增自减 <code>Mem[Regs[R2]+=d]</code></li>
<li>寄存器+寄存器倍增访存 <code>Mem[Regs[R2]+Regs[R3]*d]</code></li>
</ol>
</li>
<li>操作数类型：
<ol>
<li>整型 <code>u8,i8,u16,i16,u32,i32,u64,i64</code></li>
<li>浮点数<code>f32,f64</code></li>
<li>拓展浮点数 80 位</li>
</ol>
</li>
<li>指令类型
<ol>
<li>运算和逻辑</li>
<li>访存</li>
<li>控制</li>
<li>系统特权有关</li>
<li>浮点数指令</li>
<li>decimal 指令</li>
<li>字符串指令</li>
<li>图像指令</li>
<li>SIMD</li>
</ol>
</li>
<li>控制流指令
<ol>
<li>无条件跳转</li>
<li>条件转移</li>
<li>函数调用</li>
<li>函数 return</li>
</ol>
</li>
<li>ISA 编码：
<ol>
<li>寄存器数目：对应编译器分配，解依赖，编码长度</li>
<li>定长，变长</li>
<li>寄存器编码位置固定/不固定</li>
</ol>
</li>
</ol>
<h3 id="编译器优化">编译器优化</h3>
<table>
<thead>
<tr>
<th>编译器层次</th>
<th>依赖</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>front end per language</td>
<td>语言相关，和机器无关</td>
<td>语言翻译成通用 intermediate 形式</td>
</tr>
<tr>
<td>high-level optimizations</td>
<td>语言相关，基本和机器无关</td>
<td>eg，循环展开，函数内连</td>
</tr>
<tr>
<td>global optimizer</td>
<td>基本语言无关，和机器有关（寄存器数目和类型）</td>
<td>优化和寄存器分配</td>
</tr>
<tr>
<td>code generator</td>
<td>语言无关，机器相关</td>
<td>具体的机器特定优化和指令选择</td>
</tr>
</tbody>
</table>
<ol>
<li>寄存器数目$\ge 16$个以方便启发性的 group coloring 的寄存器分配算法（本质是个$\mathcal{NP}$问题，只有近似线性的启发式算法）</li>
<li>保证常见场景优化+罕见场景正确</li>
<li>操作，数据类型和寻址 3 者可以正交组合</li>
<li>提供 primitive 原语，而不是方案，防止过于适配高层语言</li>
<li>简化 trade-off 的选择</li>
<li>保证编译期常量能直接绑定到指令</li>
</ol>
<p>SIMD 指令基本上违背所有原则（vec 寄存器数目少，寻址模式过于简单，vec 类型不常见 etc.）。因此 SIMD 一般只有用在人工编写的底层库</p>
<h3 id="isa-统计和对应的-risc-v-设计">ISA 统计和对应的 RISC-V 设计</h3>
<h3 id="fallacy-4">Fallacy</h3>
<ol>
<li>存在一个典型程序：不同程序对 ISA 的使用差异巨大</li>
<li>有缺陷的 ISA 不能成功（80x86）</li>
<li>存在完美的体系结构
<ul>
<li>trade-off 永存</li>
<li>不同技术和时代强调目标不同</li>
</ul>
</li>
</ol>
<h3 id="pitfall-4">Pitfall</h3>
<ol>
<li>设计一个高层次指令来支持高层语言的结构
<ul>
<li>semantic gap：过于复杂，功能过剩，或者是对于其他语言其约定有差异</li>
</ul>
</li>
<li>设计 ISA 时候不考虑编译器优化
<ul>
<li>编译器优化等级对于体积优化和性能优化结果差异很大</li>
</ul>
</li>
</ol>
]]></content:encoded></item><item><title>高级算法设计-课堂笔记（更新到第11次课）</title><link>https://livypad.github.io/post/2023-02-27-adalg/</link><pubDate>Mon, 17 Apr 2023 21:00:00 +0800</pubDate><guid>https://livypad.github.io/post/2023-02-27-adalg/</guid><description>高级算法设计 快速排序 python 算法代码 测试代码 rust 算法代码 测试代码 随机算法分类 形式化定义 算法的正确率提升 Les-Vegas 和 Monte-Carlo 转化 自动机 图灵机 图灵机线性加速定理 3-CNF 非确</description><content:encoded><![CDATA[<ul>
<li><a href="#%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1">高级算法设计</a>
<ul>
<li><a href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序</a>
<ul>
<li><a href="#python">python</a>
<ul>
<li><a href="#%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81">算法代码</a></li>
<li><a href="#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">测试代码</a></li>
</ul>
</li>
<li><a href="#rust">rust</a>
<ul>
<li><a href="#%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81-1">算法代码</a></li>
<li><a href="#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81-1">测试代码</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB">随机算法分类</a>
<ul>
<li><a href="#%E5%BD%A2%E5%BC%8F%E5%8C%96%E5%AE%9A%E4%B9%89">形式化定义</a></li>
<li><a href="#%E7%AE%97%E6%B3%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E7%8E%87%E6%8F%90%E5%8D%87">算法的正确率提升</a></li>
<li><a href="#les-vegas-%E5%92%8C-monte-carlo-%E8%BD%AC%E5%8C%96">Les-Vegas 和 Monte-Carlo 转化</a></li>
<li><a href="#%E8%87%AA%E5%8A%A8%E6%9C%BA">自动机</a></li>
<li><a href="#%E5%9B%BE%E7%81%B5%E6%9C%BA">图灵机</a>
<ul>
<li><a href="#%E5%9B%BE%E7%81%B5%E6%9C%BA%E7%BA%BF%E6%80%A7%E5%8A%A0%E9%80%9F%E5%AE%9A%E7%90%86">图灵机线性加速定理</a></li>
<li><a href="#3-cnf">3-CNF</a></li>
<li><a href="#%E9%9D%9E%E7%A1%AE%E5%AE%9A%E6%80%A7%E5%9B%BE%E7%81%B5%E6%9C%BA">非确定性图灵机</a></li>
</ul>
</li>
<li><a href="#%E8%A7%84%E7%BA%A6">规约</a>
<ul>
<li><a href="#%E5%9B%BE%E7%81%B5%E5%8F%AF%E8%AE%A1%E7%AE%97%E9%97%AE%E9%A2%98%E8%A7%84%E7%BA%A6%E5%88%B0-bool-%E7%BA%BF%E8%B7%AF">图灵可计算问题规约到 bool 线路</a></li>
<li><a href="#%E6%9E%84%E4%BB%B6%E6%9B%BF%E6%8D%A2%E8%A7%84%E7%BA%A6">构件替换规约</a></li>
</ul>
</li>
<li><a href="#pnp">P，NP</a>
<ul>
<li><a href="#ladner-%E5%AE%9A%E7%90%86">Ladner-定理</a></li>
</ul>
</li>
<li><a href="#p">#P</a></li>
<li><a href="#csp">CSP</a></li>
<li><a href="#holant-csp">Holant-#CSP</a></li>
<li><a href="#%E4%BA%8C%E9%83%A8-holant-%E9%97%AE%E9%A2%98">二部 Holant 问题</a></li>
</ul>
</li>
<li><a href="#%E7%AE%97%E6%B3%95">算法</a>
<ul>
<li><a href="#%E7%9F%A9%E9%98%B5%E6%A3%80%E9%AA%8C">矩阵检验</a></li>
<li><a href="#gcd">GCD</a></li>
<li><a href="#%E7%B4%A0%E6%95%B0%E5%88%A4%E5%AE%9A">素数判定</a>
<ul>
<li><a href="#%E5%8F%8C%E8%BE%B9%E5%87%BA%E9%94%99%E7%AE%97%E6%B3%95">双边出错算法</a></li>
<li><a href="#%E5%8D%95%E8%BE%B9%E5%87%BA%E9%94%99%E7%AE%97%E6%B3%95">单边出错算法</a></li>
<li><a href="#%E5%8E%9F%E6%A0%B9">原根</a></li>
</ul>
</li>
<li><a href="#%E5%9B%BE%E5%AE%8C%E7%BE%8E%E5%8C%B9%E9%85%8D">图完美匹配</a></li>
<li><a href="#sat">SAT</a>
<ul>
<li><a href="#%E6%AD%A3%E5%88%86-sat">正分-SAT</a></li>
</ul>
</li>
<li><a href="#sat-%E8%BD%AC%E6%8D%A2">SAT-转换</a>
<ul>
<li><a href="#%E5%9B%BE%E7%9D%80%E8%89%B2%E7%BC%96%E7%A0%81">图着色编码</a></li>
<li><a href="#logic-puzzle">logic puzzle</a></li>
<li><a href="#%E6%95%B0%E7%8B%AC">数独</a></li>
<li><a href="#%E6%8E%A8%E7%AE%B1%E5%AD%90">推箱子</a></li>
</ul>
</li>
<li><a href="#%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92">线性规划</a>
<ul>
<li><a href="#%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6">区间调度</a></li>
<li><a href="#%E6%8E%92%E7%8F%AD">排班</a></li>
</ul>
</li>
<li><a href="#max-cut">MAX-CUT</a></li>
</ul>
</li>
<li><a href="#birthday-paradox">Birthday Paradox</a>
<ul>
<li><a href="#msqrtn">m~sqrt(n)</a></li>
<li><a href="#mn">m~n</a>
<ul>
<li><a href="#%E4%B8%8A%E7%95%8C">上界</a></li>
<li><a href="#%E4%B8%8B%E7%95%8C">下界</a></li>
</ul>
</li>
<li><a href="#mn-1">m&gt;n</a></li>
</ul>
</li>
<li><a href="#%E5%BC%A0%E9%87%8F%E7%BD%91%E7%BB%9C">张量网络</a>
<ul>
<li><a href="#%E5%AE%9A%E4%B9%89">定义</a></li>
<li><a href="#%E5%BC%95%E5%85%A5%E5%A4%96%E8%BE%B9%E6%88%90%E4%B8%BA%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0">引入外边成为多元函数</a></li>
<li><a href="#st">s+t</a></li>
<li><a href="#%E5%85%A8%E6%81%AF%E8%A7%84%E7%BA%A6">全息规约</a></li>
<li><a href="#%E5%AF%B9%E7%A7%B0%E5%87%BD%E6%95%B0">对称函数</a></li>
<li><a href="#csp-%E4%BA%8C%E5%88%86%E5%AE%9A%E7%90%86">#CSP-二分定理</a>
<ul>
<li><a href="#csp-%E7%AC%AC%E4%B8%80%E6%98%93%E8%A7%A3%E7%B1%BB">#CSP-第一易解类</a>
<ul>
<li><a href="#%E5%81%B6%E6%95%B0%E6%9D%A1%E8%BE%B9%E7%9A%84%E5%AD%90%E5%9B%BE%E6%95%B0%E7%9B%AE%E7%AE%97%E6%B3%95">偶数条边的子图数目算法</a></li>
</ul>
</li>
<li><a href="#csp-%E7%AC%AC%E4%BA%8C%E6%98%93%E8%A7%A3%E7%B1%BB">#CSP-第二易解类</a></li>
</ul>
</li>
<li><a href="#%E5%9B%BE%E5%90%8C%E6%80%81%E6%98%A0%E5%B0%84%E6%95%B0%E7%9B%AE">图同态映射数目</a></li>
<li><a href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E9%97%A8">斐波那契门</a>
<ul>
<li><a href="#%E7%AE%97%E6%B3%95%E4%B8%80">算法一</a></li>
<li><a href="#%E7%AE%97%E6%B3%95%E4%BA%8C">算法二</a></li>
</ul>
</li>
<li><a href="#%E5%A5%87%E5%81%B6%E5%92%8C%E7%9B%B8%E7%AD%89%E5%85%B3%E7%B3%BB%E8%BD%AC%E6%8D%A2">奇偶和相等关系转换</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E7%BA%BF%E6%80%A7%E6%80%A7%E8%B4%A8%E7%BA%BF%E6%80%A7%E6%A3%80%E6%B5%8B">函数线性性质线性检测</a></li>
<li><a href="#%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86">容斥原理</a></li>
<li><a href="#permanent">Permanent</a>
<ul>
<li><a href="#ryser-%E5%85%AC%E5%BC%8F">Ryser 公式</a></li>
<li><a href="#%E6%A8%A1%E6%95%B0%E6%84%8F%E4%B9%89%E4%B8%8B%E7%9A%84%E5%BF%AB%E9%80%9F%E7%AE%97%E6%B3%95">模数意义下的快速算法</a></li>
</ul>
</li>
<li><a href="#%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98">匹配问题</a>
<ul>
<li><a href="#%E5%B8%A6%E6%9D%83%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98%E8%A7%84%E7%BA%A6">带权匹配问题规约</a></li>
<li><a href="#%E4%B8%80%E8%88%AC%E7%9A%84%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98">一般的匹配问题</a></li>
</ul>
</li>
<li><a href="#%E5%8C%B9%E9%85%8D%E9%97%A8">匹配门</a>
<ul>
<li><a href="#juxtaposition">Juxtaposition</a></li>
<li><a href="#jumper">Jumper</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E9%99%84%E5%BD%95-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">附录-基础知识</a>
<ul>
<li><a href="#markov-inequality">Markov-Inequality</a></li>
<li><a href="#chebyshev-inequality">Chebyshev-Inequality</a>
<ul>
<li><a href="#%E6%8A%BD%E6%A0%B7%E8%B0%83%E6%9F%A5%E5%87%86%E7%A1%AE%E7%8E%87">抽样调查准确率</a></li>
</ul>
</li>
<li><a href="#%E7%BB%84%E5%90%88%E6%95%B0%E4%B8%8D%E7%AD%89%E5%BC%8F">组合数不等式</a></li>
<li><a href="#chernoff-bound">Chernoff-Bound</a>
<ul>
<li><a href="#%E6%AD%A3%E5%90%91%E7%9A%84%E8%AF%81%E6%98%8E">正向的证明</a></li>
<li><a href="#%E8%B4%9F%E5%90%91%E7%9A%84%E8%AF%81%E6%98%8E">负向的证明</a></li>
</ul>
</li>
<li><a href="#fermat-little-theorem">Fermat-Little-Theorem</a>
<ul>
<li><a href="#carmichael-number">Carmichael-Number</a></li>
<li><a href="#%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86">中国剩余定理</a></li>
</ul>
</li>
<li><a href="#schwartz-zippel-lemma">Schwartz-Zippel-Lemma</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="高级算法设计">高级算法设计</h1>
<h2 id="快速排序">快速排序</h2>
<h3 id="python">python</h3>
<h4 id="算法代码">算法代码</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">random</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">swap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">quicksort</span><span class="p">(</span><span class="n">A</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">q</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">quicksort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">quicksort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">partition</span><span class="p">(</span><span class="n">A</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">pivot</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randrange</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span><span class="p">[</span><span class="n">pivot</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">swap</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">pivot</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">hi</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">hi</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">            <span class="n">A</span><span class="p">[</span><span class="n">hi</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">swap</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">hi</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span><span class="p">[</span><span class="n">hi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">swap</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">hi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">hi</span> <span class="o">+</span> <span class="mi">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="测试代码">测试代码</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">random</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">a</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">),</span> <span class="n">k</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">quicksort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="rust">rust</h3>
<p>注意一下，</p>
<ul>
<li><code>rand</code>库需要声明依赖</li>
<li>&lt;=这样的比较需要 <code>PartialOrd</code> 的 trait</li>
<li><code>sort()</code>需要实现 <code>Ord</code> 的 trait，只有整型有；浮点类型只能使用<code>sort_by()</code>去自定义比较函数</li>
<li><code>sort()</code>是原位排序，更加推荐更快的 <code>sort_unstable()</code></li>
</ul>
<h4 id="算法代码-1">算法代码</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">rand</span>::<span class="n">Rng</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">quicksort</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">PartialOrd</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arr</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="n">T</span><span class="p">],</span><span class="w"> </span><span class="n">p</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">r</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">partition</span>::<span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">quicksort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">quicksort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">partition</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">PartialOrd</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arr</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="n">T</span><span class="p">],</span><span class="w"> </span><span class="n">p</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">r</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">arr</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">rand</span>::<span class="n">thread_rng</span><span class="p">().</span><span class="n">gen_range</span><span class="p">(</span><span class="n">p</span><span class="o">..</span><span class="n">r</span><span class="p">),</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">hi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">p</span><span class="o">..</span><span class="n">r</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">r</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">arr</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">hi</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">arr</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">hi</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="测试代码-1">测试代码</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-toml" data-lang="toml"><span class="line"><span class="cl"><span class="p">[</span><span class="nx">dependencies</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">rand</span><span class="p">=</span><span class="s2">&#34;0.8.0&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">rand</span>::<span class="n">seq</span>::<span class="n">SliceRandom</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">mod</span> <span class="nn">quicksort</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">const</span><span class="w"> </span><span class="n">UP</span>: <span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="mi">200000</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">arr</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">UP</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">arr</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">rand</span>::<span class="n">thread_rng</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">new_arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">quicksort</span>::<span class="n">quicksort</span><span class="p">(</span><span class="n">new_arr</span><span class="p">.</span><span class="n">as_mut_slice</span><span class="p">(),</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">.</span><span class="n">len</span><span class="p">(</span><span class="w">                                                        </span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">arr</span><span class="p">.</span><span class="n">sort</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">new_arr</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">arr</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">f32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">UP</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">f32</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">arr</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">rand</span>::<span class="n">thread_rng</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">new_arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">quicksort</span>::<span class="n">quicksort</span><span class="p">(</span><span class="n">new_arr</span><span class="p">.</span><span class="n">as_mut_slice</span><span class="p">(),</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">.</span><span class="n">len</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">arr</span><span class="p">.</span><span class="n">sort_unstable_by</span><span class="p">(</span><span class="o">|</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="o">|</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">partial_cmp</span><span class="p">(</span><span class="n">b</span><span class="p">).</span><span class="n">unwrap</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">new_arr</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="随机算法分类">随机算法分类</h2>
<blockquote>
<p>Las Vegas 算法</p>
<p>随机数对结果正误没有影响，但是对于运行时间有影响（允许最坏情况下不终止）。eg，<a href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快排</a></p>
</blockquote>
<blockquote>
<p>Monte Carlo 算法</p>
<p>随机数选择会影响是否出错。eg，<a href="#%E7%9F%A9%E9%98%B5%E6%A3%80%E9%AA%8C">检验矩阵乘法正确性</a></p>
</blockquote>
<p>上述的定义不关心是否是多项式时间复杂度。考虑现实一般都会加上。</p>
<h3 id="形式化定义">形式化定义</h3>
<ul>
<li>Zero-error,Probabilistic,Poly(ZPP)，时间的期望为多项式
<ul>
<li>$$
\begin{aligned}
l\in \mathcal{ZPP} \iff&amp;\exists deterministic\ alg\ A\in \mathcal{P},random\ input\ r,\\
&amp;\{x\in l \iff A(x,r)=1\}
\end{aligned}
$$</li>
</ul>
</li>
<li>Randomized Poly 单边出错，假阴性，时间被多项式限制
<ul>
<li>$$
\begin{aligned}
l\in \mathcal{RP} \iff&amp;\exists deterministic\ alg\ A\in \mathcal{P},random\ input\ r,\\
&amp;\{x\in l \rightarrow Pr(A(x,r)=1)\ge\frac{1}{2},\\
&amp;x\notin l \rightarrow Pr(A(x,r)=0)=1 \}
\end{aligned}
$$</li>
</ul>
</li>
<li>Co-RP 单边出错，假阳性
<ul>
<li>$$
\begin{aligned}
l\in \mathcal{Co-RP} \iff&amp;\exists deterministic\ alg\ A\in \mathcal{P},random\ input\ r,\\
&amp;\{x\in l \rightarrow A(x,r)=1\ge\frac{1}{2},\\
&amp;x\notin l \rightarrow Pr(A(x,r)=0)\ge\frac{1}{2} \}
\end{aligned}
$$</li>
<li>$$
\{\bar{l}|l\in\mathcal{RP}\}
$$</li>
</ul>
</li>
<li>Bounded Probabilistic Poly(BPP) 双边出错
<ul>
<li>$$
\begin{aligned}
l\in \mathcal{BBP} \iff&amp;\exists deterministic\ alg\ A\in \mathcal{P},random\ input\ r,\\
&amp;\{x\in l \rightarrow Pr(A(x,r)=1)\ge\frac{2}{3},\\
&amp;x\notin l \rightarrow Pr(A(x,r)=0)\ge\frac{2}{3} \}
\end{aligned}
$$</li>
</ul>
</li>
</ul>
<h3 id="算法的正确率提升">算法的正确率提升</h3>
<p>事实上，上述定义中的概率常量不影响（对于$\mathcal{RP}\mathcal{Co-RP}$常数无关，对于$\mathcal{BPP}$错误率小于$\frac{1}{2}$，集合之间等同。独立随机的输入运行多次，然后选择结果。</p>
<p>eg，$\mathcal{RP}_\frac{1}{2}$ 提升到 $\mathcal{RP}_\frac{1}{4}$ ，运行 2 次，至少一次 1 即输出 1，全 0 输出 0。</p>
<p>eg， $\mathcal{BBP}_\frac{1}{3}$ 提升（错误率不能超过 $\frac{1}{2}$）。取独立随机输入$r_1,&hellip;r_{2t+1}$ 对应随机变量$Y_1,&hellip;Y_{2t+1}$，如果和$Y=\sum Y_i\ge t+1$，输出 1，反之输出 0</p>
<p>$$
\begin{aligned}
&amp;Pr(\sum Y_i\le t)\\
&amp;=Pr(Y-E(Y)\le t-E(Y))\\
&amp;\le Pr(Y-E(Y)\le t-(2t+1)\frac{2}{3})\\
&amp;\le Pr(|Y-E(Y)| \ge t/3+2/3)\\
&amp;\le \frac{Var(Y)}{(t/3+2/3)^2}\\
&amp;\le \frac{(2t+1)Var(Y_i)}{(t/3+2/3)^2}\\
&amp;\le \frac{(2t+1)/4}{(t/3+2/3)^2}\\
\end{aligned}
$$</p>
<p>t 足够大时，正确的概率即可足够大</p>
<h3 id="les-vegas-和-monte-carlo-转化">Les-Vegas 和 Monte-Carlo 转化</h3>
<p>$$\mathcal{RP}\cap\mathcal{Co-RP}=\mathcal{ZPP} $$</p>
<ol>
<li>$\mathcal{ZPP}\subseteq\mathcal{RP}$：超时直接输出一个结果，按照$\mathcal{RP}$的要求，给 0（超时概率被 <a href="#markov-inequality">markov 不等式限制</a>，给出 1 一定正确，给 0 可能会出错 ）</li>
<li>$\mathcal{ZPP}\subseteq\mathcal{Co-RP}$，类似的</li>
<li>$\mathcal{RP}\cap\mathcal{RP}\subseteq\mathcal{ZPP}$：联立$A_1\in\mathcal{RP} ,A_2\in\mathcal{Co-RP}$,(1,1)输出 1，(0,0)输出 0，(0,1)再来一次。时间期望被正确率控制（(1,0)自相矛盾，不可能发生）</li>
</ol>
<p>这些算法集合关系如下。注意，$\mathcal{NP}$和$\mathcal{BPP}$之间实际上关系未知，有待进一步证明。目前大概认为不等</p>
<p><img loading="lazy" src="/assets/img/p-npvenn.png" alt="p,np,zpp,rp,bpp"  />
</p>
<h3 id="自动机">自动机</h3>
<blockquote>
<p>自动机</p>
<p>每次读取下一个字符（有限集$\Sigma$），根据状态转移函数改变状态（有限集$Q$）</p>
<p>$\delta:Q\times \Sigma\to Q$</p>
</blockquote>
<blockquote>
<p>语言</p>
<p>字符串的集合 $L\subseteq\Sigma^*$</p>
<p>等价定义指示函数 $L:\Sigma^*\to {0,1}$</p>
</blockquote>
<blockquote>
<p>正则语言</p>
<p>能被自动机接收的语言</p>
</blockquote>
<blockquote>
<p>有限差异</p>
<p>集合${\sigma|L_1(\sigma)\neq L_2(\sigma)}$有限大小</p>
</blockquote>
<p>有限语言都是正则语言。正则语言对于交、并、补运算封闭。</p>
<p>对于两个有限差异的问题$L_1,L_2$，对于$L_1$有复杂度$T(n)$为算法。那么对于$L_2$，总可以把差异部分打表，相同部分调用$L_1$的算法，形成一个$T(n)+n+c$的算法。</p>
<ul>
<li>判定问题 $F:\Sigma^*\to {0,1}$</li>
<li>优化问题 $F:\Sigma^*\to \Sigma^*$</li>
<li>计数问题 $F:\Sigma^*\to \mathbb{N}$</li>
</ul>
<h3 id="图灵机">图灵机</h3>
<blockquote>
<p>图灵机</p>
<p>根据状态和读入的字符，可以写字符，变状态，左右移动</p>
<p>$F:Q\times \Gamma\to Q\times \Gamma\times\{\leftarrow,\rightarrow\}$</p>
</blockquote>
<blockquote>
<p>（图灵）可计算问题</p>
<p>起始状态时，带子作为输入字符串。停机之后，带子上字符串作为输出</p>
<p>$F:\Sigma^*\to \Sigma^*$</p>
</blockquote>
<p>图灵机是所有编程语言的计算能力。</p>
<h4 id="图灵机线性加速定理">图灵机线性加速定理</h4>
<p>对于一个可计算问题，存在一个图灵机有复杂度$T(n)$算法。那么存在一个图灵机可以实现$\frac{1}{d}T(n)+n+c$的算法。</p>
<p>主要靠扩充状态和字符集，将原先的状态和字符压缩表示。</p>
<h4 id="3-cnf">3-CNF</h4>
<p>$$\psi=C_1\wedge C_2&hellip;$$</p>
<p>当中子句是 3 元或函数，当中文字为变量的形式$x_i,\neg x_i$：$C_i=l_{i,1}\vee l_{i,2}\vee l_{i,3}$</p>
<ul>
<li>非门: $x=\neg y \iff (x\vee y)\wedge(\neg x\vee \neg y)$</li>
<li>或门: $x=(y\vee z)\iff (\neg x\vee y\vee z)\wedge(x\vee \neg y)\wedge(x\vee \neg z)$</li>
</ul>
<p><a href="#sat">作为 3SAT 的基础</a>。而且，对于 4SAT 问题，定义一个新变量$z_i$来表示一个子句$l_{i,1}\vee l_{i,2}\vee l_{i,3}\vee l_{i,4}$，写成$l_{i,1}\vee l_{i,2}\vee z_i,\neg z_i\vee l_{i,3}\vee l_{i,4}$。</p>
<h4 id="非确定性图灵机">非确定性图灵机</h4>
<p>non-deterministic Turing machine</p>
<blockquote>
<p>非确定性图灵机</p>
<p>根据状态和读入的字符，接下来随机选择状态转移（可以认为是无限度的并行执行，选择最正确的分支作为结果），可以写字符，变状态，左右移动</p>
<p>$F:Q\times {0,1}\to Q\times \Sigma\times\{\leftarrow,\rightarrow\}$</p>
</blockquote>
<h3 id="规约">规约</h3>
<p>对于规约$\Psi$，有$F(X)=H(\Psi(X))$</p>
<p>如果规约$\Psi$是多项式时间的、$\log$空间、etc；称为多项式时间规约、$\log$空间规约、etc。记为$\le^\text{cost}_{way}$。</p>
<ul>
<li>多项式时间规约：$F\le^\text{poly}_m H\implies p(n)+q(p(n))$，规约时间+H 算法（规约输入）</li>
<li>图灵规约：递归调用$H$，adaptive。需要带 oracle 的图灵机（预言机，指的是规约到更强大的预言机来解决）$F\le^\text{poly}_T H\implies p(n)+p(n)q(p(n))$，规约时间+规约出来的状态数目*H 算法（规约输入）</li>
<li>Truth Table 规约：一次给定多个$H$,non-adaptive</li>
</ul>
<p>如果$\forall F\in\mathcal{NP}$，$F$可以被规约到问题$H$，称$H$为$\mathcal{NP}-C$问题（NP 完全问题）</p>
<h4 id="图灵可计算问题规约到-bool-线路">图灵可计算问题规约到 bool 线路</h4>
<p>对于输入字符串为$n$。图灵机停机用时$T(n)$。那么必然读写头移动范围不超过$T(n)$。可以把图灵机的运行过程用一个$T(n)\times T(n)$的表格表示。每格记为$\Sigma\times (Q\cup{\mathcal{o}})$，表示每格的字符，图灵机状态、读写头是否在本格。即为<strong>计算表格</strong>。</p>
<p>因此，上述每格的有限数目的状态用$c$个 bit 编码。注意到，任意一个时刻某个位置字符是否改变，必然只取决于上一个时刻其左右 3 个字符的情况（$3c$个 bit）。因此最后可以表达为有限个逻辑门组合。</p>
<p>注意，对于$\mathcal{NP}$问题，对于多项式时间判定函数$R()$的计算表格，也可以类似规约。如此规约出来的问题具有 <a href="#3-cnf">3CNF 问题</a>的形式。由此也可以证明<a href="#sat">3SAT 问题</a>是$\mathcal{NP}$完全的。</p>
<h4 id="构件替换规约">构件替换规约</h4>
<p>对于$A\le B$的规约，由于张量网络结合律，使用 B 的构件，发挥 A 中函数作用。如<a href="#3-cnf">4SAT 到 3SAT 的规约</a>。</p>
<h3 id="pnp">P，NP</h3>
<p>判定问题，可以对应一个集合/语言。</p>
<p>$$f:x\to \{0,1\}$$</p>
<p>$$L_f=\left\{x|f(x)=1 \right\}$$</p>
<ul>
<li>$\mathcal{P}$：对于<a href="#%E5%9B%BE%E7%81%B5%E6%9C%BA">图灵机</a>多项式时间可解</li>
<li>$\mathcal{NP}$：对于<a href="#%E9%9D%9E%E7%A1%AE%E5%AE%9A%E6%80%A7%E5%9B%BE%E7%81%B5%E6%9C%BA">非确定性图灵机</a>多项式时间可解；多项式时间可验证一个解的正确性</li>
</ul>
<p>存在多项式时间算法$R$有输入$|y|=|x|^k$，有$F\in\mathcal{NP},F(x)=1\iff \exists y,R(x,y)=1$</p>
<h4 id="ladner-定理">Ladner-定理</h4>
<p>如果$\mathcal{P}\neq\mathcal{NP}$，存在问题不是 P，也不是 NP 难。</p>
<p>构造一个算法，使得增长速度能够介于$\mathcal{P}$与$\mathcal{NP}$之间。大致思路是，在 SAT 之间插入$n^{H(n)}$的 1，当中$H(n)$是关于$n$的多项式时间函数，且$n$趋于无穷时候趋于无穷。记$SAT_H={\psi01^{n^{H(n)}}:\psi\in SAT \wedge n=|\psi|}$。</p>
<h3 id="p">#P</h3>
<p>函数$F$属于$\#P$问题：存在多项式时间算法$R$，使得$F(x)=|{y|R(x,y)=1}|$（多项式时间验证可解的解的计数）</p>
<p>如果任何$\#P$的问题可以规约到问题 B，B 是$\#P$ 完全（$\#P-complete$）。$\#P-complete$也是$\mathcal{NP}$ 完全的。#SAT 是 $\#P$ 完全的。<a href="#permanent">01Permanent 问题</a>也是$\#P$完全的</p>
<h3 id="csp">CSP</h3>
<blockquote>
<p>$CSP(\mathcal{F})$ 问题（Constraint Satisfaction Problem）</p>
<p>变量的约束满足形式$\mathcal{F}$，约束是否可以满足的问题</p>
</blockquote>
<p>$\mathcal{F}$如果有形式，$CSP(\mathcal{F})$为 P 问题，否则为 NP 难</p>
<ul>
<li>0-valid</li>
<li>1-valid</li>
<li>Horn SAT</li>
<li>dual Horn SAT</li>
<li>affine（线性函数）</li>
<li>bijunctive（2SAT）</li>
</ul>
<p>3-SAT 作为 CSP 的特例。每个子句相当于 8 种约束中的一种。要求满足所有约束</p>
<h3 id="holant-csp">Holant-#CSP</h3>
<blockquote>
<p>$Holant(\mathcal{F})$问题</p>
<p>对于张量网络$G$,点上的函数属于$\mathcal{F}$，输出 G 的值</p>
</blockquote>
<blockquote>
<p>$\#CSP(\mathcal{H})$ 问题（Constraint Satisfaction Problem 计数）</p>
<p>张量网络形如 $=_n,F_i\in\mathcal{H}$ 的二部图</p>
<p>$\#CSP(\mathcal{H})=Holant(\{=_i&hellip;\}\cup \mathcal{H})$</p>
</blockquote>
<p>对于变量集合$X=\{x_1,x_2,&hellip;x_n\}$，有函数 $R_1(x_{1,1},&hellip;x_{1,r_1}),&hellip;R_m(x_{m,1},&hellip;x_{m,r_m})$，函数有$R_i\in\mathcal{F}$。$\#CSP(\mathcal{F})$就是求解</p>
<p>$$\sum_{\sigma:X\to D}\prod R_j(\sigma(x_{j,1}）,&hellip;,\sigma(x_{j,r_j}))$$</p>
<p>对于#CSP 问题，其中一部分是$\mathcal{P}$问题，见<a href="#csp-%E4%BA%8C%E5%88%86%E5%AE%9A%E7%90%86">#CSP 二分定理</a></p>
<h3 id="二部-holant-问题">二部 Holant 问题</h3>
<p>对于两个函数集合$\mathcal{H},\mathcal{F}$，对于二部图$G(U,V,E)$：$U$上函数来自$\mathcal{H}$；$V$上函数来自$\mathcal{F}$ 定义问题$\#\mathcal{H}|\mathcal{F}$，求解张量网络值。也被称为二部 Holant 问题</p>
<p>注意，任何一条边，可以转化成两条连着二元相等关系顶点$=_2$的边。因此，有如下等价关系</p>
<ol>
<li>$\#\mathcal{F}\equiv\#\{=_2\}|\mathcal{F}$</li>
<li>$\#CSP(\mathcal{F})\equiv\#\{=_i,&hellip;\}|\mathcal{F}$</li>
<li>$\#CSP(\mathcal{F})\equiv\#\{=_i,&hellip;\}\cup\mathcal{F}$
<ol>
<li>在$\mathcal{F}$直接有两边相连，插入$=_2$</li>
<li>$=_i$关系相连，转换为一个更大的相等关系</li>
</ol>
</li>
</ol>
<p>问题的集合和实例的集合不是一回事：</p>
<ul>
<li>从问题角度，#CSP 问题类是 Holant 问题类的子集,$\#CSP(\mathcal{F})=\#\mathcal{F}\cup\{=_i,&hellip;\}\subseteq\#\mathcal{F}$</li>
<li>对于一个确定的函数集合$\mathcal{F}$，$\#\mathcal{F}$的实例对应的实例$\#CSP(\mathcal{F})\supseteq\#\mathcal{F}\cup\{=_2\}$，前者可规约到后者</li>
</ul>
<h2 id="算法">算法</h2>
<h3 id="矩阵检验">矩阵检验</h3>
<p>在$O(n^2)$，概率判断两矩阵乘是否相等另一矩阵。重复选择向量$x$。对于 0，1 的 2-bit 矩阵，错误率（在不等情况下）为$\frac{1}{2}$。</p>
<p>$$A(Bx)==Cx$$</p>
<h3 id="gcd">GCD</h3>
<p>不分解质因数，使用辗转相除法计算最大公因数 GCD。至多 2 次减半，时间复杂度度$O(\ln n*\ln^2 n)$。</p>
<p>辗转相除法的过程中，还可以同时构造得到 Bezout 系数$x,y\in \mathbb{Z}$使得 $GCD(a,b)=x\times a+y\times b$。一个可能的实现如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">num</span>::<span class="n">Integer</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">cmp</span>::<span class="p">{</span><span class="n">max</span><span class="p">,</span><span class="w"> </span><span class="n">min</span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ops</span>::<span class="p">{</span><span class="n">Div</span><span class="p">,</span><span class="w"> </span><span class="n">Neg</span><span class="p">,</span><span class="w"> </span><span class="n">Rem</span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">gcd</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Integer</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Neg</span><span class="o">&lt;</span><span class="n">Output</span><span class="o">=</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Copy</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span>: <span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">b</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">r_rep</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[(</span><span class="n">T</span>::<span class="n">zero</span><span class="p">(),</span><span class="w"> </span><span class="n">T</span>::<span class="n">one</span><span class="p">())];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">v2</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max_min</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">div_rem</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">is_zero</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r_rep</span><span class="p">.</span><span class="n">pop</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">it</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">it</span><span class="p">.</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">it</span><span class="p">.</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">it</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(((</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">)))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_last2_items</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r_rep</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">r_rep</span><span class="p">.</span><span class="n">push</span><span class="p">((</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">d</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">r_rep</span><span class="p">.</span><span class="n">push</span><span class="p">((</span><span class="n">T</span>::<span class="n">one</span><span class="p">(),</span><span class="w"> </span><span class="o">-</span><span class="n">q</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v2</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">get_last2_items</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Copy</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v</span>: <span class="kp">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">len</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nb">Some</span><span class="p">((</span><span class="n">v</span><span class="p">[</span><span class="n">l</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="n">l</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">]))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nb">None</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">div_rem</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Div</span><span class="o">&lt;</span><span class="n">Output</span><span class="o">=</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Rem</span><span class="o">&lt;</span><span class="n">Output</span><span class="o">=</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Copy</span><span class="o">&gt;</span><span class="p">(</span><span class="n">dividend</span>: <span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">divisor</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">(</span><span class="n">dividend</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">divisor</span><span class="p">,</span><span class="w"> </span><span class="n">dividend</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">divisor</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">max_min</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Ord</span> <span class="o">+</span><span class="w"> </span><span class="nb">PartialOrd</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Copy</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v1</span>: <span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">),</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="素数判定">素数判定</h3>
<p>对于一个大小为 n 的数，注意到表示这个数需要的复杂度是$O(\ln n)$。所以合理的多项式时间算法，应该是针对$\sim \ln n$的多项式。</p>
<h4 id="双边出错算法">双边出错算法</h4>
<p>给定一个$\mathcal{BPP}$算法</p>
<ol>
<li>n 不是不为 2 的偶数</li>
<li>$n=r^s\qquad r,s&gt;1$
<ol>
<li>$r$遍历过$2&hellip;\log_2{n}$</li>
<li>二分查找$r^s&lt;n$，判断是否成立，时间复杂度$O(\ln^3 n)$，遍历+二分查找+翻倍乘法（FFT）作为基</li>
</ol>
</li>
<li>独立随机的取$a_1,a_2,..a_{10}\in[2,n-1]$
<ol>
<li>$GCD(\prod a_i,n)\neq 1$，结束，<a href="#gcd">时间复杂度</a> $O(\ln^3 n)$</li>
<li><a href="#fermat-little-theorem">费马小定理检测</a>$a_i^{n-1}\neq 1\pmod n$，结束</li>
<li>$a_i^{\frac{n-1}{2}}\neq \pm1\pmod n$，结束</li>
<li>$\exists i,a_i^{\frac{n-1}{2}}\equiv -1\pmod n$，是素数，结束</li>
<li>全是+1，合数</li>
</ol>
</li>
</ol>
<p>对于素数$p$，有$(a^{\frac{p-1}{2}}-1)(a^{\frac{p-1}{2}}+1)=a^{p-1}-1\equiv0\pmod p$。p 至少整除$a^{\frac{p-1}{2}}-1,a^{\frac{p-1}{2}}+1$其中一个。因此必有$a^{\frac{p-1}{2}}\equiv \pm1\pmod p$。对于素数，只有最后两个步骤可能出问题。mod 为+1 的概率为$\frac{1}{2}$，<a href="#%E5%8E%9F%E6%A0%B9">因为原根</a>。</p>
<p>对于合数。</p>
<p>$$
\begin{aligned}
\epsilon=Pr(\exists i,&amp;a_i^{\frac{n-1}{2}}\equiv -1\pmod n\\
\forall i,&amp;a_i^{\frac{n-1}{2}}\equiv \pm1\pmod n,\
&amp;a_i^{n-1}\equiv 1\pmod n )
\end{aligned}
$$</p>
<p>找一个坏的$y$使得$y^{\frac{n-1}{2}}\neq \pm1\pmod n$。然后 y 和其他的 mod 余数为$\pm1$的乘，即可生成等大小的集合，<a href="#%E5%8E%9F%E6%A0%B9">类似原根里的构造集合</a> 。使得能正确筛出概率$\ge \frac{1}{2}$。坏的$y$在 mod -1 元素存在时（$a^{\frac{n-1}{2}}\equiv -1\pmod n=-1\pmod{PQ}$）必然存在。</p>
<p>分解有$n=p^\alpha Q=P\times Q\implies GCD(P,Q)=1$（分解的存在性由通过第 2 大步保证，Q 是剩下素因子乘积）。使用 <a href="#%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86">中国剩余定理</a>保证下列要求有解。</p>
<p>$$
\left\{
\begin{aligned}
&amp;y\equiv 1\pmod{P}\\
&amp;y\equiv a\pmod{Q},\qquad a\neq \pm 1
\end{aligned}
\right.
$$</p>
<p>而且容易知道，解$y\star$不能是 naive 的 1，-1，否则下列等式总有一行不成立。且等式和在一起必与$y^{\frac{n-1}{2}}\equiv \pm1\pmod n$矛盾（对 n mod $\pm1$，对于 PQ 必然都 mod $\pm 1$两个结果一样，因为$(y\mp 1)\mod n=(y\mp 1)\mod P=(y\mp 1)\mod Q=0$）</p>
<p>$$
\left\{
\begin{aligned}
&amp;y\star^{\frac{n-1}{2}}=1^\frac{n-1}{2}=1\equiv 1\pmod{P}\\
&amp;y\star^{\frac{n-1}{2}}=a^{\frac{n-1}{2}}\equiv -1\pmod{Q}
\end{aligned}
\right.
$$</p>
<h4 id="单边出错算法">单边出错算法</h4>
<p>关于素数$\mathcal{Co-RP}$，关于合数的$\mathcal{RP}$算法。前大部分得出合数都是可靠的。</p>
<ol>
<li>n 不是不为 2 的偶数</li>
<li>$n=r^s\qquad r,s&gt;1$
<ol>
<li>$r$遍历过$2&hellip;\log_2{n}$</li>
<li>二分查找$r^s&lt;n$，判断是否成立，时间复杂度$O(\ln^3 n)$，遍历+二分查找+翻倍乘法（FFT）作为基</li>
</ol>
</li>
<li>随机选取$a\in[2,n-1]$
<ol>
<li>$GCD(a,n)\neq 1$，合数</li>
<li>$a^{n-1}\neq 1\pmod{n}$，合数</li>
<li>$a^{\frac{n-1}{2}}\neq \pm1\pmod{n}$，合数</li>
<li>$n-1=2^rs$遍历，$a^{2^{r-1}s},&hellip;a^s$，mod n，检测结果序列
<ol>
<li>出现$\neq \pm1$，合数</li>
<li>出现$1,-1$形式，素数，可能错误选出合数</li>
<li>全是 1，素数，可能错误选出合数</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>注意，$s$ 是奇数，必然的$-1^s\equiv -1\pmod{n}$。和<a href="#%E5%8F%8C%E8%BE%B9%E5%87%BA%E9%94%99%E7%AE%97%E6%B3%95">之前合数部分类似的</a>，可以拓展出坏根。出现$\neq \pm1$的概率$\ge \frac{1}{2}$</p>
<h4 id="原根">原根</h4>
<p>原根有$a\star ^{\frac{p+1}{2}}\equiv-1\pmod p$。素数必有原根。且原根能满足下列集合在 mod p 意义上的相等</p>
<p>$$p,a\star\implies \{a\star ^1,a\star^2 &hellip; a\star ^{p-1}\}\pmod p=\{1,2,3&hellip;p-1\}\pmod p$$</p>
<p>假定一个数已知有原根。那 mod 之后，等于 1，-1 的集合等大小（原根乘 mod 余 1 的集合每个元素，构造出来两个集合等大小）。</p>
<h3 id="图完美匹配">图完美匹配</h3>
<p>对于二部图$G(U,V,E)$，对于其邻接矩阵表示$M$，不存在完美匹配的必要条件为$\det(M)=0$</p>
<p>$$\det(M)=\sum_{\pi\in S_n}(-1)^{sign(\pi)}\prod^n_{j=1}m_{j,z(j)}$$</p>
<p>不是充分条件，因为比如完全的二部图的邻接矩阵，每行每列全为 1，会导致抵消而等于 0。引入$O(n^2)$个变量，保证$\det(M)$行列之间不相消</p>
<p>$$
m_{ij}=\left\{
\begin{aligned}
&amp;x_{ij}\qquad (u_i,v_j)\in E\\
&amp;0     \qquad (u_i,v_j)\notin E
\end{aligned}
\right.
$$</p>
<p>此时不存在完美匹配的充要条件即为$\det(M)=M(x_{ij})\equiv0$</p>
<p><a href="#schwartz-zippel-lemma">使用 Schwartz Zippel Lemma</a>，取素数$n^2\le p\le 2n^2$，独立随机取$r_1,&hellip;r_n\in \mathbb{F}_p=[1..p]\subseteq\mathbb{Z}$，在模 p 意义下计算行列式（eg，高斯消元法数值计算，时间复杂度$O(n^3)$）。该算法对于有匹配的图可能给出无匹配的错误结果，单边出错。</p>
<p>$$
\begin{aligned}
\epsilon&amp;=Pr(\det(M)=0)=Pr(M(x_{ij})=0)\\
&amp;\le \frac{\deg(M)}{p}\\
&amp;=\frac{n}{n^2}=\frac{1}{n}
\end{aligned}
$$</p>
<h3 id="sat">SAT</h3>
<p>对于 bool 变量$x_1,&hellip;x_n$，有逻辑表达式$\varphi=(x_i\vee&hellip;)\wedge&hellip;$，是否存在一组取值使得$\varphi$可被满足为真。<a href="#%E5%9B%BE%E7%81%B5%E5%8F%AF%E8%AE%A1%E7%AE%97%E9%97%AE%E9%A2%98%E8%A7%84%E7%BA%A6%E5%88%B0-bool-%E7%BA%BF%E8%B7%AF">3-SAT 为$\mathcal{NP}$问题</a>。</p>
<h4 id="正分-sat">正分-SAT</h4>
<p>逻辑表达式$\varphi=(x_i\vee&hellip;)\wedge&hellip;$，每个子句满足有正分，反之 0 分。MAX-2SAT 是$\mathcal{NP}$问题。</p>
<p>$$\varphi=(x_1\vee \bar{x}_2)\wedge(\bar{x}_1\vee x_3\vee\bar{x}_4)&hellip;$$</p>
<p>考虑变量$y_1,&hellip;y_m\in\{0,1\}$，当中$y_i$表示第 i 个 clause 是否被满足。优化目标即为$W=w_1y_1+&hellip;w_my_m$。把逻辑表达式转化为约束条件有</p>
<p>$$
\left\{
\begin{aligned}
&amp;y_1\le x_1+(1-x_2)\\
&amp;y_2\le (1-x_1)+x_3+(1-x_4)\\
&amp;&hellip;\\
&amp;x_i\in\{0,1\}\\
&amp;y_i\in\{0,1\}\\
\end{aligned}
\right.
$$</p>
<p>问题为 Integer Linear Programming（ILP），为$\mathcal{NP}$。可以把整数约束松弛求近似解（线性规划是$\mathcal{P}问题$），$0\le x_i\le1,0\le y_i\le 1$。由于范围更大，有$opt(\tilde{P})\ge opt(P)$（可以证明$opt(\tilde{P})$必然是一个分数解）。令随机变量$Pr(X_i=1)=x_i^{\star}$，把$opt(\tilde{P})$的结果作为概率去做舍入（可以保持均值/期望不变）</p>
<p>此时，有 clause 的满足也成为随机变量$Y_i$，$R=w_1Y_1+&hellip;w_mY_m$</p>
<p>$$
\begin{aligned}
\mathbb{E}(R)&amp;=\sum w_iE(Y_i)\\
&amp;=\sum w_iPr(Y_i=1)\\
&amp;=\sum w_i(1-Pr(Y_i=0))\\
&amp;=\sum w_i(1-\prod(Pr(X_i=1/0)))\\
&amp;\ge \sum w_i(1-[\frac{\sum x^{\star}/(1-x^{\star})}{s_i}]^{s_i})\qquad\text{$X_i=1/0$对应概率}\\
&amp;=\sum w_i(1-[\frac{s_i -\sum (1-x^{\star})/x^{\star}}{s_i}]^{s_i})\qquad\text{平均值不等式}\\
&amp;=\sum w_i(1-(1-\frac{y_i^{\star}}{s_i})^{s_i})\qquad \text{注意逻辑表达式}
\end{aligned}
$$</p>
<p>对于$k\ge2,z\in[0,1]$，有上凸函数$f(z),f(0)=0,f(1)=1-(1-\frac{1}{k})^k \le1-\frac{1}{e}$</p>
<p>$$
\begin{aligned}
f(z)&amp;=1-(1-\frac{z}{k})^k&gt;0\\
f^\prime(z)&amp;=(1-\frac{z}{k})^{k-1}&gt;0\\
f^{\prime\prime}(z)&amp;=-\frac{k-1}{k}(1-\frac{z}{k})^{k-2}&lt;0
\end{aligned}
$$</p>
<p>上凸函数有函数值大于直线，有$f(z)=1-(1-\frac{z}{k})^k&gt;(1-\frac{1}{e})z$。则$\mathbb{E}(R)\ge \sum w_i(1-\frac{1}{e})y_i^{\star}$。又由于松弛条件$opt(P)\le opt(\tilde{P})=\sum w_iy_i^{\star}$。可以得出估计的偏差可被有效控制住</p>
<p>$$
\frac{\mathbb{E}(R)}{opt(P)}\ge 1-\frac{1}{e}
$$</p>
<h3 id="sat-转换">SAT-转换</h3>
<p>可以把很多问题归结到 SAT 问题求解。而且 SAT 问题有现成的求解器程序（solver）</p>
<h4 id="图着色编码">图着色编码</h4>
<p>如 3-染色问题，每个点的每种染色结果编码为一个 bool 变量$x_{i1},x_{i2},x_{i3}$，然后枚举约束</p>
<ol>
<li>一条边上两个点颜色不同,$\neg x_{i1}\vee \neg x_{j1}$</li>
<li>一个点必须有一种颜色 $x_{i1}\vee x_{i2}\vee x_{i3}$</li>
<li>不需要指定一个点只取一种颜色（solver 求解之后，再舍去多多余即可，但这可能增加 solver 负担）</li>
</ol>
<h4 id="logic-puzzle">logic puzzle</h4>
<p>至少一人说谎。$a,b,c$3 个 bool 变量对应 ABC 是否说真话。可以将蕴含转换为析取形式</p>
<ul>
<li>A: B is lying.</li>
<li>B: C is lying.</li>
<li>C: A and B is lying.</li>
</ul>
<p>对应表达式</p>
<ol>
<li>$a\vee b\vee c$</li>
<li>$a\to \neg b,\neg a\to b \implies\neg a \vee \neg b,a\vee b$</li>
<li>$b\to \neg c,\neg b\to c \implies\neg b \vee \neg c,b\vee c$</li>
<li>$c\to(\neg a\wedge\neg b),\neg c\to \neg(\neg a\wedge\neg b)\implies \neg c\vee \neg a,\neg c \vee \neg b,a\vee b\vee c$</li>
</ol>
<p>最后可以求解为$\neg a,b,\neg c$</p>
<h4 id="数独">数独</h4>
<p>$p(i,j,n)$表示第 i 行 j 列是否取数字 n</p>
<ol>
<li>每行:$\bigwedge_i\bigwedge_n\bigvee_j p(i,j,n)$</li>
<li>每列:$\bigwedge_j\bigwedge_n\bigvee_i p(i,j,n)$</li>
<li>小方块:$\bigwedge_s\bigwedge_t\bigwedge_n\bigvee_i\bigvee_j p(3s+i,3t+j,n)$</li>
<li>一个格子对应一个数:$n\neq n^\prime \implies \neg p(i,j,n) \vee \neg p(i,j,n^\prime)$</li>
</ol>
<h4 id="推箱子">推箱子</h4>
<p>每个位置对应 3 种状态，<code>Empty,Worker,Box</code>。可以编码 k 步行动（行动可以被行动前后的状态对<code>&lt;pre,con&gt;</code>来编码）的推箱子解。</p>
<ol>
<li>每个状态有且只有值</li>
<li>每轮行动要求前一轮之后前提能被满足</li>
<li>每轮行动后，状态对应改变</li>
<li>状态的改变必然是由于有行动</li>
<li>每轮有且只有一个行动</li>
</ol>
<h3 id="线性规划">线性规划</h3>
<p>线性规划（LP，Linear Programing）。有如下的标准形式。</p>
<p>$$
\min z=\mathbf{c}x\text{ s.t. }
\left\{\begin{aligned}
Ax=b\\
x\ge 0
\end{aligned}\right.
$$</p>
<p>如果要求变量只能取整数，即为 ILP；如果要求一部分为整数，为 MILP。</p>
<h4 id="区间调度">区间调度</h4>
<p>一些工作（持续时间是区间$[s_j,e_j)$），分配给一些工人（工人 t 有$B_t=\bigcap[s_{ti},e_{ti})$的时间段有别的事情）。要求同一个人干活、其他杂事之间都不能重叠。</p>
<p>定义 bool 变量$x_t^j$表示工作 j 分配给工人 t。可以化归为整数线性规划</p>
<ol>
<li>$\sum_t x_t^j=1$：有时间的至少有一个人干某个工作 j</li>
<li>$x_t^i\le(1-x_t^j)$：如果工作 i、j 时间冲突，一个人至多做其中一件事情</li>
<li>$x_t^j\in{0,1}$</li>
</ol>
<h4 id="排班">排班</h4>
<ul>
<li>N 个人</li>
<li>W 个周数</li>
<li>D：一周天数</li>
<li>S 种任务</li>
</ul>
<p>定义 bool 变量$x_{n,w,d,s}$表示第 w 周第 d 天，第 n 号人是否被分配工作 s</p>
<ol>
<li>优化目标 $\min z=z_1+z_2$
<ol>
<li>尽量整个周末要么加班要么不加班：$z_1=w_1\sum (y_{n,w,1}+y_{n,w,2})$</li>
<li>每个人尽量上满天数：$z_2=w_2\sum_n q_n$</li>
</ol>
</li>
<li>硬约束
<ol>
<li>每人每天只能干一个工作：$\sum_s x_{n,w,d,s}\le 1$</li>
<li>每天每项工作要满足最少人数：$\sum_n x_{n,w,d,s}\ge C_{w,d,s}^{\min}$</li>
<li>一些工作不能连续干：$\forall (s_1,s_2)\in\text{forbidden}:x_{n,w,d,s_1}+x_{n,w,d+1,s_2}$</li>
</ol>
</li>
<li>软约束
<ol>
<li>$\sum_s x_{n,w,6,s}-\sum_s x_{n,w,7,s}+y_{n,w,1}\ge 0;\sum_s x_{n,w,7,s}-\sum_s x_{n,w,6,s}+y_{n,w,2}\ge 0$</li>
<li>$\sum x_{n,w,d,s}+q_n\ge T_{\min}$</li>
</ol>
</li>
</ol>
<h3 id="max-cut">MAX-CUT</h3>
<p>对于图$G=U\cup W,U\cap W=\emptyset$，m 条边，使得$|E(U,W)|$最大。这是$\mathcal{NP}$问题。</p>
<p>对于每个顶点取$\frac{1}{2}$分给 U、W，对于每个边，有$\frac{1}{2}$概率(uu,uw,wu,ww)在 cut 中。因此，由于期望的线性性，有</p>
<p>$$
\mathbb{E}(|E(X_u,X_w)|)=\frac{m}{2}
$$</p>
<p>而且因为$opt\le m$，因此这是一个$\frac{1}{2}$的估计。</p>
<p>注意到，$\frac{m}{2}=E(Y)=\frac{1}{2}E(Y|X_1=0)+\frac{1}{2}E(Y|X_1=1)$。由于平均数的特性，必然有一个$E(Y|X_1=0),E(Y|X_1=0)$是比原先的期望$E(Y)$更大。可以持续按照$X_1,X_2&hellip;$固定，取更大的期望，递降下去，<strong>去随机化</strong>。这样可以得到 cut 的取值。</p>
<p>具体来说，由于期望线性性，可以把给定$X_1,..X_{i-1}$取值，准备给定$X_i$的某个 0/1 取值时候的 cut 大小的期望表示为：$X_1,..X_{i}$内部的边的期望，$X_1,..X_{i}$与其他未确定点边界处的边的期望，和未确定点内部的边的期望。</p>
<p>$$
\mathbb{E}(Y|X_1,&hellip;X_i)=\mathbb{E}(X_1,&hellip;X_i)+\mathbb{E}(|X_j,unkonwn|)+\mathbb{E}(unkonwn)
$$</p>
<p>容易知道:</p>
<ol>
<li>无论$X_i$的具体取值，$\mathbb{E}(unkonwn)$都是相同的。</li>
<li>已知点和未确定点之间边界边的期望有$\mathbb{E}(|X_j,unkonwn|)=\mathbb{E}(|\{X_1,&hellip;X_{i-1}\},unknown|)+\mathbb{E}(|X_i,unkonwn|)$。
<ol>
<li>$\mathbb{E}(|\{X_1,&hellip;X_{i-1}\},unknown|)$被之前确定的点所固定，与$X_i$取值无关</li>
<li>而$\mathbb{E}(|X_i,unkonwn|)$关于$X_i$取 0/1 是对称的，因此也和$X_i$取值无关。</li>
</ol>
</li>
</ol>
<p>因此，事实上该去随机化算法，每次新加入的点，取值使得已确定的点之间能构成最大的 cut 即可。可以考虑下列一些简单的例子。</p>
<table>
<thead>
<tr>
<th>三角形</th>
<th>u</th>
<th>w</th>
<th>$\mathbb{E}$</th>
</tr>
</thead>
<tbody>
<tr>
<td>u,w</td>
<td>2</td>
<td>2</td>
<td>$\frac{2+2}{2}=2$</td>
</tr>
<tr>
<td>u,u</td>
<td>0</td>
<td>2</td>
<td>$\frac{0+2}{2}=1$</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>四边形取邻边</th>
<th>u,u</th>
<th>u,w</th>
<th>w,u</th>
<th>w,w</th>
<th>$\mathbb{E}$</th>
</tr>
</thead>
<tbody>
<tr>
<td>u,w</td>
<td>2</td>
<td>2</td>
<td>4</td>
<td>2</td>
<td>$\frac{2+2+4+2}{4}=5/2$</td>
</tr>
<tr>
<td>u,u</td>
<td>0</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>$\frac{0+2+2+2}{2}=3/2$</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>正四面体取邻边</th>
<th>u,u</th>
<th>u,w</th>
<th>w,u</th>
<th>w,w</th>
<th>$\mathbb{E}$</th>
</tr>
</thead>
<tbody>
<tr>
<td>u,w</td>
<td>3</td>
<td>4</td>
<td>4</td>
<td>3</td>
<td>$\frac{3+4+4+3}{4}=7/2$</td>
</tr>
<tr>
<td>u,u</td>
<td>0</td>
<td>3</td>
<td>3</td>
<td>4</td>
<td>$\frac{0+3+3+4}{2}=5/2$</td>
</tr>
</tbody>
</table>
<p>注意，这个提升算法因为没有回退，因此可能陷入局部最优解。考虑如下一个简单例子。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain"><span class="line"><span class="cl">  u    最优： u    次优：u
</span></span><span class="line"><span class="cl">/ | \      / | \     / | \
</span></span><span class="line"><span class="cl">1-2-3      v-u-v     u-v-u
</span></span></code></pre></td></tr></table>
</div>
</div><p>局部来看，1，2，3 这三个位置填 w，局部都是最优的多 1 条 cut 边。但是，全局最优要求 w 填在 1 或者 3 的位置（最优解里 cut 大小为 4，否则最后 cut 大小为 3）。</p>
<h2 id="birthday-paradox">Birthday Paradox</h2>
<p>$m$个球，独立随机投入到$n$个盒子。作为生日悖论的推广。还包括如 md5 的 hash 碰撞，服务器负载均衡请求等。$X_i$表示 i 个盒子中球的数目，之间同分布但不独立（和为$m$）。注意有
$x\in(0,1)\implies e^{-x}&gt;1-x$</p>
<h3 id="msqrtn">m~sqrt(n)</h3>
<p>$$
\begin{aligned}
Pr(\max X_i\ge 2)&amp;=1-Pr(\forall i,X_i\le 1)\\
&amp;=1-(1-\frac{1}{n})(1-\frac{2}{n})&hellip;(1-\frac{m-1}{n})\\
&amp;\ge 1-e^{-\frac{1}{n}}&hellip;e^{-\frac{m-1}{n}}\\
&amp;=1-e^{-\frac{m(m-1)}{2n}}\\
&amp;\ge 1-e^{-(\frac{m}{\sqrt{2n}})^2}
\end{aligned}
$$</p>
<p>因此，$m=\Theta(\sqrt{n})\approx\sqrt{2n}$时候，大概率 2 球碰撞（$Pr=1-e^{-1}$）</p>
<h3 id="mn">m~n</h3>
<p>$$m=n\implies \max X_i \sim \frac{\ln n }{\ln \ln n}$$</p>
<p>有高概率实现（with high prop，whp，概率量级为$1-o(1)$）。证明有上界下界。如果尝试次数大于 1 次，可以改善到$\Theta(\ln \ln n)$（证明未被提及）</p>
<h4 id="上界">上界</h4>
<p>$$
Pr(\max X_i\le 3\frac{\ln n }{\ln \ln n})\ge 1-o(1)
$$</p>
<p>$$
\begin{aligned}
&amp;Pr(X_1\ge 3s)\\
&amp;=Pr(\exists i_1,&hellip;i_{3s}\in [1,n],Ball_{i_j} \in X_1 )\\
&amp;=Pr(\bigcup Ball_{i_j} \in X_1 )\\
&amp;\le \sum Pr(Ball_{i_j} \in X_1)\\
&amp;=\binom{m}{3s}\left(\frac{1}{n}\right)^{3s}\\
&amp;\sim \binom{n}{3s}\left(\frac{1}{n}\right)^{3s}\\
&amp;\le \left(\frac{ne}{3s}\right)^{3s}\left(\frac{1}{n}\right)^{3s}\\
&amp;=(\frac{e}{3s})^{3s}\\
&amp;&lt;s^{-3s}\\
&amp;=(\frac{\ln  \ln n }{\ln n})^{3s}\\
&amp;&lt; (\frac{\sqrt {\ln n}}{\ln n})^{3s}\\
&amp;=e^{-\ln \ln n \cdot (\frac{3}{2}\frac{\ln n }{\ln \ln n})}\\
&amp;=n^{-3/2}
\end{aligned}
$$</p>
<p>$$
\begin{aligned}
Pr(\max X_i\ge 3\frac{\ln n }{\ln \ln n})&amp;=Pr(\exists i,X_i\ge 3\frac{\ln n }{\ln \ln n})\\
&amp;=Pr(\bigcup X_i\ge 3\frac{\ln n }{\ln \ln n})\\
&amp;\le nPr(X_1\ge 3s)\\
&amp;\le n^{\frac{1}{2}}
\end{aligned}
$$</p>
<h4 id="下界">下界</h4>
<p>$$
Pr(\max X_i\ge \frac{1}{3}\frac{\ln n }{\ln \ln n})\ge 1-o(1)
$$</p>
<p>定义同分布但不独立的随机变量$Y_1,&hellip;Y_n$ 有</p>
<p>$$
Y_i=\left\{
\begin{aligned}
&amp;1\qquad X_i\ge \frac{s}{3}\\
&amp;0\qquad otherwise
\end{aligned}
\right.
$$</p>
<p>$$
\begin{aligned}
Pr(Y_i=1)&amp;=Pr(X_i\ge \frac{s}{3})\\
&amp;\ge Pr(X_i=\frac{s}{3})\\
&amp;=\binom{m}{\frac{s}{3}}(\frac{1}{n})^{\frac{s}{3}}\cdot (1-\frac{1}{n})^{m-\frac{s}{3}}\\
&amp;\sim\binom{n}{\frac{s}{3}}(\frac{1}{n})^{\frac{s}{3}}\cdot (1-\frac{1}{n})^{n-\frac{s}{3}}\\
&amp;\ge (\frac{n}{\frac{s}{3}})^{\frac{s}{3}}(\frac{1}{n})^{\frac{s}{3}}e^{-1}\\
&amp;=(\frac{3}{s})^{\frac{s}{3}}e^{-1}\\
&amp;=(\frac{(3\ln \ln n)}{\ln n})^{\frac{s}{3}}e^{-1}\\
&amp;\ge (\ln n )^{-\frac{s}{3}}e^{-1}\qquad n&gt;4\implies 3\ln \ln n&gt;1\\
&amp;=e^{\ln \ln n\cdot \frac{\ln n}{3\ln \ln n}}e^{-1}\\
&amp;=n^{-1/3}e^{-1}
\end{aligned}
$$</p>
<p>因此有期望估计为 $E(Y_i)\ge n^{-1/3}e^{-1}$，期望和估计为$E(Y)\ge n^{2/3}e^{-1}$</p>
<p>$$
\begin{aligned}
&amp;Pr(\max X_i\ge \frac{1}{3}\frac{\ln n }{\ln \ln n})\\
&amp;=Pr(\exists Y_i=1)\\
&amp;=Pr(\sum Y_i \ge 1)\\
&amp;=1-Pr(\sum Y_i \le 0)\\
\end{aligned}
$$</p>
<p>$$
\begin{aligned}
Pr(\sum Y_i \le 0)&amp;=Pr(Y\le 0)\\
&amp;\le Pr(|Y-E(Y)|\ge E(Y))\qquad \text{注意到}E(Y)\ge 0\\
&amp;\le \frac{Var(Y)}{(n^{2/3}e^{-1})^2}\\
&amp;\le \frac{nVar(Y_i)}{(n^{2/3}e^{-1})^2}\\
&amp;\le \frac{e^2}{4}n^{-\frac{1}{3}}
\end{aligned}
$$</p>
<p>注意，这时候虽然$Y_i$之间不独立，但是其负相关（显然），协方差小于 0。和的方差等于方差的和加上负的协方差。因此还是可以使用<a href="#chebyshev-inequality">chebyshev 不等式进行放缩</a>。</p>
<h3 id="mn-1">m&gt;n</h3>
<p>期望里每个盒子的球数目为$\frac{m}{n}$。而在$m\sim n\ln n$量级上，可以保证高概率每个盒子均符合期望。</p>
<p>考虑独立随机变量$Y_1,&hellip;Y_m$，$Y_i$表示第 i 个球是否进入 1 号盒子。$E(Y_i)=\frac{1}{n},E(Y)=\frac{m}{n}$。取$m=24 n\ln n$。使用 <a href="#chernoff-bound">chernoff-bound 进行放缩</a></p>
<p>$$
\begin{aligned}
&amp;Pr(\forall X_i\in [(1-\frac{1}{2})\frac{m}{n},(1+\frac{1}{2})\frac{m}{n}])\\
&amp;=1-Pr(\exists X_i\notin [(1-\frac{1}{2})\frac{m}{n},(1+\frac{1}{2})\frac{m}{n}] )\\
&amp;\ge 1-nPr(X_1 \notin [(1-\frac{1}{2})\frac{m}{n},(1+\frac{1}{2})\frac{m}{n}])\\
&amp;=1-(Pr(X_1 \le(1-\frac{1}{2})\frac{m}{n})+Pr(X_1\ge (1+\frac{1}{2})\frac{m}{n}))\\
&amp;\ge 1- 2ne^{-\frac{(\frac{1}{2})^2}{3}\cdot\frac{m}{n}}\\
&amp;=1-2ne^{-2\ln n}\\
&amp;=1-2/n=1-o(1)
\end{aligned}
$$</p>
<h2 id="张量网络">张量网络</h2>
<h3 id="定义">定义</h3>
<p>使用$[d]$表示大小为$d$的有限集合。$\mathbb{R}^d$的向量可以视为对每一维上的离散函数$F(i):[d]\to\mathbb{R}$。$k$维张量即可以视为$F(i_1,&hellip;i_k)$</p>
<blockquote>
<p>张量网络</p>
<p>张量/离散函数作为点、自变量作为边的图。如果函数不对称，需要指定边的次序</p>
<p>图$G(V,E)$中每个点$v$赋予一个$d_v$元函数$F_v$</p>
<p>张量网络的值：$\sum_{e\in [d]} \prod_v F_v(e_{v,1},&hellip;e_{v,d_v})$，对所有边取一种赋值之后的结果求和</p>
</blockquote>
<p>eg，对于 <a href="#sat">SAT 问题</a> ，$\exists {x_1,&hellip;x_n}\to {0,1},\bigwedge c()=1 \iff \sum\prod c()\ge 1$（可以引入一些辅助节点，保证出现次数大于 2 次的边，转化成很多条连到辅助节点的边，辅助节点的函数要求所有边取值相同）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain"><span class="line"><span class="cl">F1-e-F2
</span></span></code></pre></td></tr></table>
</div>
</div><p>$e\in\{0,1\},F_1(0)=1,F_1(1)=3,F_2(0)=2,F_2(1)=5$，网络值是 $1\times 2+3\times 5=17$</p>
<p>eg，3-regular 图（顶点度数均为 3）的 3 染色问题，可以用张量网络和转变为计数问题</p>
<h3 id="引入外边成为多元函数">引入外边成为多元函数</h3>
<p>定义输入$X=\{x_1,&hellip;x_n\}\in D^n$，有</p>
<p>$$F_G(x_1,&hellip;x_n)=\sum_e\prod_v F_v(e_{v,1},&hellip;e_{v,d_v},x_i)$$</p>
<p>eg，$AB_{x_1x_2}=\sum A_{x_1e}B_{ex_2}$</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain"><span class="line"><span class="cl">x1-A-e-B-x2
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>矩阵的迹(对角线元素求和)
<ul>
<li>$trace(A)=\sum A_{ee}$(自环),$trace(ABC)=\sum A_{e_1e_2}B_{e_2e_3}C_{e_3e_1}$</li>
</ul>
</li>
<li>张量积，(克罗内克积)对于矩阵$M_{dd},N_{dd}$，结果为$d^2\times d^2$的矩阵，$M\otimes N=(m_{ij}N)$
<ul>
<li>$(M\otimes N)_{x_1x_2,x_3x_4}=M_{x_1x_3}N_{x_2x_4}$ 。结果中行标$x_1x_2$可以视为把$M$的行标$x_1$和$N$的行标$x_2$字符串组合在一起</li>
<li>可以表示为<code>x1-M-x3, x2-N-x4</code>的张量网络（没有内部边，无需求和，顶点函数就是矩阵的 index）</li>
</ul>
</li>
<li>张量网络值满足<strong>结合律</strong></li>
<li>有限域上的线性方程组解集大小，等于对应张量网络值
<ul>
<li>$\#P$问题，存在多项式时间算法</li>
<li>相同的变量用一个多元相等关系约束</li>
<li>每个方程对应一个 $\mod{}$ 顶点</li>
</ul>
</li>
<li>图的顶点覆盖数目（选定一组顶点，使得顶点的邻边包括所有的边）
<ul>
<li>$\#P-complete$问题</li>
</ul>
</li>
</ul>
<h3 id="st">s+t</h3>
<p>$s+t$的 bool 函数$F$，输入为$x_1,&hellip;x_s,y_1,&hellip;y_t$。向左边视为行标，向右边视为列标。对于$2^s\times2^t$矩阵$M_{x_1,&hellip;x_s,y_1,&hellip;y_t}=F(x_1,&hellip;x_s,y_1,&hellip;y_t)$。注意如果$s=0$（$t=0$），降级为行（列）向量。此时的张量网络函数可以视为矩阵乘法。</p>
<h3 id="全息规约">全息规约</h3>
<p>$$
AB=AEB=AMM^{-1}B=(AM)\cdot(M^{-1}B)
$$</p>
<p>一个$f,h$二分的张量网络，可以先把$f,h$之间插入一个$=_2=[1,0,1]$，然后把$=_2=MM^{-1}$，把$f,h$换一个基：$fM^{\otimes i},(M^{-1})^{\otimes j}h$</p>
<p>对于一个$F，H$二分，而且$F、H$之间每条边上都有顶点$M$的张量网络。有问题间的等价关系$\#\{FM^{\otimes i}\}|\{H\}\equiv\#\{F\}|\{M^{\otimes j}H\}$</p>
<h3 id="对称函数">对称函数</h3>
<p>对于置换$\pi$,对于自变量$\forall x_i$，有</p>
<p>$$
F(x_1,&hellip;x_n)=F(x_{\pi(1)},&hellip;x_{\pi(n)})
$$</p>
<p>如果是 bool 为自变量的对称函数，可以用$f_i$表示$i$个 1 时候$F$的值。那么$F$可以完全被$f_0,f_1,&hellip;f_{n}$来确定。对于 n 元相等关系(全相等时候取 1，否则取 0)，记$F=[1,0,&hellip;0,1]$为$=_n$</p>
<h3 id="csp-二分定理">#CSP-二分定理</h3>
<p>bool 定义域的#CSP 问题，其他形式是#P 难的问题</p>
<ul>
<li>01 值域：
<ul>
<li>仿射关系</li>
</ul>
</li>
<li>非负实数值域
<ul>
<li>pure affine</li>
<li>product type</li>
</ul>
</li>
<li>复数值域
<ul>
<li>第一易解类$\mathcal{A}$</li>
<li>第二易解类$\mathcal{P}$，作为 product 形式的推广</li>
</ul>
</li>
</ul>
<h4 id="csp-第一易解类">#CSP-第一易解类</h4>
<p>对于 bool 定义域，值域$\mathbb{C}$的函数$F$。有一个第一易解类$\mathcal{A}$，对于<a href="#holant-csp">$\#CSP(\mathcal{A})$</a>存在多项式时间算法。定义仿射关系，$\mathcal{X}_{(AX=C)}$，为$D$上$n$维的指示函数。</p>
<p>可以定义一类特殊条件的多项式$P()$：</p>
<ul>
<li>整系数多项式$P(x_1,&hellip;x_n)$，整数加法乘法运算</li>
<li>$P()$最高次数为 2，交错二次项的系数为偶数</li>
</ul>
<p>那么，$F\in \mathcal{A}$当且仅当$F$具有形式$\mathcal{X}_{(AX=C)}\cdot i^{P(x_1,&hellip;x_n)}$</p>
<p>考虑$AX=C$的自由变量有$x_1,&hellip;x_r$，其他的变量可以表示为$X^\prime=(x_1,&hellip;x_r,1)$的线性组合，$x_j=L_j(X^\prime)\mod 2$。注意到</p>
<ol>
<li>$\forall a\in\mathcal{Z},a=0,1\mod2\iff a^2=0,1\mod 4$
<ol>
<li>显然有$a\pmod2=0\iff a^2\pmod4=0$</li>
<li>$a^2 \pmod4 =1$可知$a^2,a$为奇数</li>
<li>$a=2k+1\implies a^2=(2k+1)^2=4(k^2+k)+1$,$\mod 1$的情况得证</li>
</ol>
</li>
<li>注意到对$i=\sqrt{-1}$的指数，可以在$\mod 4$的意义下计算</li>
</ol>
<p>因此我们可以把$P()$中的不自由的$x_j$（$j\in[r+1,n]$）进行<strong>合法的替换</strong></p>
<ol>
<li>一次项$x_j$替换为$L_j(X^\prime)^2$，因为在$\mod 4$下不改变</li>
<li>平方项和交错二次项正常换成$L_j(X^\prime)^2$和$2L_j(X^\prime)L_{k}(X^\prime)$</li>
</ol>
<p>此时$P(x_1,..x_r,x_{r+1},&hellip;x_n)=P(x_1,&hellip;x_r,L_{r+1}(X^\prime),&hellip;L_{n}(X^\prime))=Q(x_1,&hellip;x_r)$，容易验证新的多项式$Q()$仍然满足上述$P()$的条件。因此有</p>
<p>$$
\sum \mathcal{X}_{(AX=C)}\cdot i^{P(x_1,&hellip;x_n)}=\sum i^{Q(x_1,&hellip;x_r)}
$$</p>
<p>接下来进行逐步消除自变量。考虑$x_1$。注意到，$x_i$都是 bool 变量，因此必然有$x_i^2\equiv x_i$，我们可以把关于$x_1$的二次项$\alpha_1x_1^2$（如果存在的话）改写成$\alpha_1x_1$融合进关于$x_1$的一次项当中。</p>
<p>对$x_1$的一次项系数进行分类讨论。假设其是偶数，那么可以把$Q()$分解为$Q(x_1,&hellip;x_r)=2x_1R(x_2,&hellip;x_r)+S(x_2,&hellip;x_r)$。容易知道，当中$S()$仍然满足之前$P()$的要求，而$R(x_2,&hellip;x_r)$是一个次数为 1 的多项式</p>
<p>$$
\begin{aligned}
\sum i^{Q(x_1,&hellip;x_r)}&amp;=\sum i^{2x_1R+S}\\
&amp;=\sum_{x_2,&hellip;x_r}i^S\sum_{x_1\in{0,1}}i^{2x_1R}\\
&amp;=(1+(-1)^{R})\sum_{x_2,&hellip;x_r}i^S
\end{aligned}
$$</p>
<p>类似的，如果$x_1$的一次项系数是奇数，分解$Q(x_1,&hellip;x_r)=2x_1R(x_2,&hellip;x_r)+S(x_2,&hellip;x_r)+x_1$（注意所有的交错二次项的系数均是偶数，因此只有可能留下$x_1$单独的一次项）。此时有</p>
<p>$$
\sum i^{Q(x_1,&hellip;x_r)}=(1+(-1)^R\cdot i)\sum_{x_2,&hellip;x_r}i^S
$$</p>
<p>考虑表达式之前的常数项，（不失一般性的）有</p>
<ul>
<li>$1+(-1)^R\cdot 1$
<ul>
<li>$R=0\implies 2,R=1\implies 0$</li>
<li>可以用示性函数来表示，$2\mathcal{X}_{R=0}$</li>
</ul>
</li>
<li>$1+(-1)^R\cdot (-1)$
<ul>
<li>$R=0\implies 0,R=1\implies 2$</li>
<li>可以用示性函数来表示，$2\mathcal{X}_{R=1}$</li>
</ul>
</li>
<li>$1+(-1)^R\cdot i$
<ul>
<li>$R=0\implies (1+i),R=1\implies (1-i)$</li>
<li>注意到可以表示为$(1+i)\cdot (-i)^R$</li>
</ul>
</li>
<li>$1+(-1)^R\cdot (-i)$
<ul>
<li>$R=0\implies (1-i),R=1\implies (1+i)$</li>
<li>注意到可以表示为$(1-i)\cdot (i)^R$</li>
</ul>
</li>
</ul>
<p>由于之前的分解$R(x_2,&hellip;x_r)$是一个次数为 1 的多项式</p>
<ol>
<li>对于示性函数$\mathcal{X}_{R=0},\mathcal{X}_{R=1}$ ，可以在选出一个不自由的自变量 $x_i$ 由其他 $x_j$ 来表示，这样再次可以类似开始的消除不自由变量的递降</li>
<li>由于$S()$满足$P()$的条件，$R()$次数为 1，和二次项无关，因此$T(x_2,&hellip;x_r)=S()\pm R()$仍然满足$P()$的条件。此时$F$具有类似$\sum i^{T(x_2,&hellip;x_r)}$的形式，可以类似之前提出$x_1$的方法继续提出其他自变量</li>
</ol>
<p>显然的这个过程（高斯消元解矩阵，多项式提取公共项等）可以在多项式时间内实现，$\mathcal{A}$确为一个易解类。</p>
<blockquote>
<p>这一小结参考论文<a href="https://www.sciencedirect.com/science/article/pii/S0022000013001414">The complexity of complex weighted Boolean #CSP</a></p>
</blockquote>
<h5 id="偶数条边的子图数目算法">偶数条边的子图数目算法</h5>
<p>有函数形式</p>
<p>$$
F=\left(\begin{matrix}1&amp;1 \\ 1&amp;-1\end{matrix}\right)
$$</p>
<p>也可以认为是对于$x,y$，为$F(x,y)=i^{2xy}$。</p>
<p>对于图，点为$x_1,&hellip;x_n$，对每个边应用$F$。考虑取 1 的点构成的子图。子图有偶数条边，$-1$的偶数次幂为$+1$；奇数条边子图结果即为$-1$</p>
<p>因此问题结果为：偶数边子图数目-奇数边子图数目。已知 所有子图数目$2^{|V|}$=偶数边子图数目+奇数边子图数目。因此偶数边子图、奇数边子图数目计算为 $\mathcal{P}$ 问题</p>
<h4 id="csp-第二易解类">#CSP-第二易解类</h4>
<p>集合$\mathcal{E}$有，$F\in\mathcal{E} \iff \exists \alpha\in \{0,1\}^n,\forall X\notin \{ \alpha,\bar{\alpha} \},F(X)=0$。这个集合可以认为是 n 元相等关系的推广。</p>
<p>注意到 $\{\alpha,\bar{\alpha}\}$是一个一维仿射子空间。一个自由变量相当于约束了其他非自由变量（对于求张量网络和来说）。</p>
<p>第二易解类$\mathcal{P}$，当函数为$\mathcal{E}$的乘积。注意到，连通的$\mathcal{E}$类型的函数，还是$\mathcal{E}$类型的函数。连通分支内部取值固定，连通分支之间取乘积即可（有结合律，易知）。</p>
<p>定义二元不等关系$\neq_2$为$[0,1,0]$。可以认为集合$\mathcal{E}$是由一个推广 n 元相等$[a,0..,0,b]$，取一些边接上二元不等关系$\neq_2$生成。这也是一种 <a href="#%E6%9E%84%E4%BB%B6%E6%9B%BF%E6%8D%A2%E8%A7%84%E7%BA%A6">构件替换规约</a>。</p>
<h3 id="图同态映射数目">图同态映射数目</h3>
<p>图的同态映射，$\psi:V_G\to V_H$，有$\forall e=(a,b)\in E_G,(\psi(a),\psi(b))\in E_H$。给定一个图，求同态映射数目，相当于求一个二元函数$H$定义的$\#CSP$问题。</p>
<p>3 染色问题，可以认为是$H=\left(\begin{aligned}0,1,1\\1,0,1\\1,1,0\end{aligned}\right)$的$\#CSP(H)$问题</p>
<p>如果二元函数$H$对应的矩阵的秩小于等于 1，那么该问题为 $\mathcal{P}$问题。把分解二元函数$H=ab^{\prime}$。原来的图的每个顶点都相当于一个 n 元相等关系，只有两个赋值能满足，这样显然是易解的。</p>
<p>另一个易解类出现在如果图是二部图，有邻接矩阵$\begin{pmatrix}
0,A\\B,0
\end{pmatrix}$ ，当中的矩阵 A、B 秩都是 1。那么，如果另一图不是二部图，显然不存在同态映射；如果是二部图，考虑一部的顶点集合到另一个部的顶点集合，这时候化归到二元函数$H$对应的矩阵的秩小于等于 1 的情况。</p>
<h3 id="斐波那契门">斐波那契门</h3>
<p>对于张量网络中的对称函数，如果$f_{i+2}=f_{i+1}+f_i$,那么$[f_0,f_1,f_2,&hellip;,f_k]$被称为斐波那契门。</p>
<p>斐波那契门的张量网络求值问题$\#\{Fib\}|\{=_2\}$，有多项式时间解法</p>
<h4 id="算法一">算法一</h4>
<p>对于$\#\{Fib\}|\{=_2\}$这样的张量网络，以下两种运算封闭</p>
<ol>
<li>把两个斐波那契门函数用一条公共边$=_2$关系连在一起，形成一个新的斐波拉契门
<ul>
<li>考虑一个输入，一部分输入的 1 在一边，一部分在另一边，容易证明不管如何分配值不变</li>
<li>再证明这些输入的结果满足斐波那契关系</li>
</ul>
</li>
<li>把一个斐波那契门函数的两条自由边成环在一起，新的函数还是新的斐波拉契门
<ul>
<li>容易证明$[f_0+f_2,f_1+f_3,&hellip;f_{k-2}+f_k]$这样的形式也是斐波那契门</li>
</ul>
</li>
</ol>
<p>因此对于上述网络重复上述两种操作，由于操作的封闭性和张量网络求值的结合律，最后可以得到一个超大的斐波那契门。表示，计算斐波那契门的输入输出都是多项式时间的。因此是$\mathcal{P}$问题。</p>
<h4 id="算法二">算法二</h4>
<p>考虑$x^2=x+1$，根为$a,b$，有韦达定理$ab=-1$。注意到$a^{i+2}=a^{i+1}+a^i$。那么$[1,a,a^2,&hellip;a^n]$满足$f_{i+2}=f_{i+1}+f_i$这样的递推关系。举个简单例子</p>
<p>$$
\begin{aligned}
&amp;(1,a)^{\otimes 3}\\
&amp;=(1,a)\otimes (1,a,a,a^2)\\
&amp;=(1,a,a,a^2,a,a^2,a^2,a^3)\\
&amp;(000,001,010,011,100,101,110,111)
\end{aligned}
$$</p>
<p>因此，$(1,a)^{\otimes n},(1,b)^{\otimes n},s(1,a)^{\otimes n}+t(1,b)^{\otimes n}$都是斐波那契门。</p>
<p>反之，所有斐波那契门都能表示成$s(1,a)^{\otimes n}+t(1,b)^{\otimes n}$的形式。注意到</p>
<p>$$
\begin{pmatrix}
f_{i+1}\\f_{i+2}
\end{pmatrix}=\left(\Sigma\begin{pmatrix}
a,0\\0,b
\end{pmatrix}\Sigma^{-1}\right)^i\begin{pmatrix}
f_{i}\\f_{i+1}
\end{pmatrix}=\Sigma\begin{pmatrix}
a,0\\0,b
\end{pmatrix}^i\Sigma^{-1}\begin{pmatrix}
f_{i}\\f_{i+1}
\end{pmatrix}=T \begin{pmatrix}
a^i\\b^i
\end{pmatrix}
$$</p>
<p>而且，定义$M=\begin{pmatrix}
1,a\\1,b
\end{pmatrix}$，注意到</p>
<p>$$
\begin{aligned}
&amp;s(1,a)^{\otimes n}+t(1,b)^{\otimes n}\\
&amp;=(s,0,&hellip;0,t)\begin{pmatrix}
1,a\\1,b
\end{pmatrix}^{\otimes n}\\
&amp;=[s,0,&hellip;0,t]\begin{pmatrix}
1,a\\1,b
\end{pmatrix}^{\otimes n}=[s,0,&hellip;0,t]M^{\otimes n}
\end{aligned}
$$</p>
<p><a href="#%E5%85%A8%E6%81%AF%E8%A7%84%E7%BA%A6">使用全息规约</a>，把斐波那契门的$M^{\otimes n}$项转移到二元相等关系上去。有</p>
<p>$$
\begin{aligned}
&amp;M^{\otimes 2}\begin{pmatrix}
1\\0\\0\\1
\end{pmatrix}\\
&amp;=\begin{pmatrix}
1,a,a,a^2\\1,b,a,ab\\1,a,b,ab\\1,b,b,b^2
\end{pmatrix}\begin{pmatrix}
1\\0\\0\\1
\end{pmatrix}\\
&amp;=\begin{pmatrix}
1+a^2\\0\\0\\1+b^2
\end{pmatrix}
\end{aligned}
$$</p>
<p>注意到，$[s,0,&hellip;0,t]$和$(1+a^2,0,0,1+b^2)$都属于集合$\mathcal{E}$。这时候可以调用 <a href="#csp-%E7%AC%AC%E4%BA%8C%E6%98%93%E8%A7%A3%E7%B1%BB">#CSP 第二易解类，product 形式</a>的算法。因此可以多项式时间完成。</p>
<h3 id="奇偶和相等关系转换">奇偶和相等关系转换</h3>
<p>对于$H=\begin{pmatrix}
1,1\\1,-1
\end{pmatrix}$，有如下</p>
<p>$$
\begin{aligned}
&amp;[1,0,0,1]H^{\otimes 3}\\
&amp;=((1,0)^{\otimes 3}+(0,1)^{\otimes 3})H^{\otimes 3}\\
&amp;=(1,1)^{\otimes 3}+(1,-1)^{\otimes 3}\\
&amp;=[1,1,1,1]+[1,-1,1,-1]\\
&amp;=[2,0,2,0]=2[1,0,1,0]
\end{aligned}
$$</p>
<p>又有</p>
<p>$$
\begin{aligned}
&amp;[2,0,2,0]H^{\otimes 3}\\
&amp;=((1,1)^{\otimes 3}+(1,-1)^{\otimes 3})H^{\otimes 3}\\
&amp;=(2,0)^{\otimes 3}+(0,2)^{\otimes 3}\\
&amp;=[2,0,0,0]+[0,0,0,2]\\
&amp;=[2,0,0,2]=2[1,0,0,1]
\end{aligned}
$$</p>
<h3 id="函数线性性质线性检测">函数线性性质线性检测</h3>
<p>对于$X,Y\in{0,1}^n$，对于一个线性函数$G:{0,1}^n\to{0,1}$.有$G(X+Y)\equiv G(X)+G(Y) \mod 2$。当中有形式$G=\sum a_ix_i,a_i\in{0,1}$</p>
<p>现在给出函数$G$，需要判断是否线性。则需要判断$G(X+Y)+G(X)+G(Y) \equiv0\mod 2$。如果不满足则不是线性函数。考虑变换$Z=X+Y$, 原有的判断条件可以改写为$(-1)^{G(X)}(-1)^{G(Y)}(-1)^{G(Z)}=1$。这时候，可以把 $(\text{通过概率}(1-p)-\text{拒绝概率}(p))$用张量网络求值表达出来。进行全息变换。$\oplus_3$替换为$=_3$ ,$(-1)^G$替换为$\hat{G}$</p>
<p>$$
\begin{aligned}
1-2p&amp;=\sum\left((-1)^{G(X)}(-1)^{G(Y)}(-1)^{G(Z)}\prod \oplus_3(X_i,Y_i,Z_i)\right)\\
&amp;=\sum \hat{G}(S)\hat{G}(U)\hat{G}(V)\prod =_3(S,U,V)\\
&amp;=\sum \hat{G}^3(S) \\
&amp;\le\sum (\max \hat{G}(S))\hat{G}^2(S)=\max \hat{G}(S)
\end{aligned}
$$</p>
<p>$\hat{G}$可以认为是$G$函数和对应选择的线性函数$\chi_s$的值相同的概率$1-\rho$减去值不同的概率$\rho$</p>
<p>注意到，bool 函数$G$和$\pm1$函数 $F:{1,-1}^n\to{1,-1}$之间是等价的，当中$F(X)=\prod_{j\in s}x_j$（注意这里把原先的$G$的 0 替换为$F$的 1，$G$的 1 替换为$F$的-1，$G$的奇数次的 1 有结果 1 对应$F$奇数次的-1 有结果-1）</p>
<p>考虑 Hadmard 的满秩矩阵，$H=\begin{pmatrix}
1,1\\  1,-1
\end{pmatrix}$，$H^{\otimes n}$对应着关于不同的$x_j,j\in s$的$s$选取的真值表的基$\boldsymbol{\chi}_s,s\subseteq [n]$。以$n=2$为例</p>
<p>$$
\begin{aligned}
H^{\otimes 2}=\begin{pmatrix}
1,1,1,1\\1,-1,1,-1\\1,1,-1,-1\\1,-1,-1,1
\end{pmatrix}\qquad\begin{matrix}
00\\01\\10\\11
\end{matrix}
\end{aligned}
$$</p>
<p>右边表示是否选取$x_0,x_1$。例如，$10$代表选择$x_0$，此时的线性函数为$\chi_{10}=x_0$。真值对应如下面的树状关系</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-plaintext" data-lang="plaintext"><span class="line"><span class="cl">  x0=1        x0=-1
</span></span><span class="line"><span class="cl">x1=1 x1=-1  x1=1 x1=-1
</span></span><span class="line"><span class="cl"> 1     1     -1    -1
</span></span></code></pre></td></tr></table>
</div>
</div><p>考虑一个 bool 函数按照上述转化而来的 $\pm 1$函数$F$的结果向量和某个$\chi_s$的内积$&lt;F,\chi_s&gt;$。由内积的定义，如果某位其相同，乘积为 1，反之为-1。那么内积的结果就是$F$和$\chi_s$之间相同点-不同点的数目。</p>
<p>这时候就可以定义相对距离$\rho$，不同的点数除以总点数。而值相同的概率减去值不同的概率一样表示为$1-2\rho$。因此，这是一个单边出错算法，拒绝概率$p\ge \rho$</p>
<h3 id="容斥原理">容斥原理</h3>
<p>$$
|\bigcap \bar{A}_i|=|S-\bigcup A_i|=|S|-\sum|A_i|+\sum|A_i\cap A_j|&hellip;+(-1)^n|A_1\cap&hellip;A_n|
$$</p>
<p>定义$A_i(0)=\bar{A}_i,A_i(1)=A_i$，自变量$X\in{0,1}^n$，定义</p>
<p>$$
F(X)\triangleq |\bigcap A_i(x_i)|
$$</p>
<p>定义 $A_i^*(0)=S,A_i^*(1)=A_i$ ，自变量 $X\in{0,1}^n$，定义</p>
<p>$$
H(X)\triangleq |\bigcap A_i^*(x_i)|
$$</p>
<p>$$
\begin{aligned}
H(01&hellip;1)= &amp; |S\cap\bigcap_2 A_i^*(x_i)| \\
&amp;=|A_1 \cap\bigcap_{2} A^{*}_{i}(x_i) |+|\bar{A}_1\cap\bigcap_2 A_i^{*}(x_i)| \\
&amp;=F(01&hellip;1)+F(11&hellip;1) \\
&amp;=(0,&hellip;0,1,0,&hellip;,0,1)\cdot\begin{pmatrix}
F(0&hellip;0)\\
&hellip;\\
F(1&hellip;1)
\end{pmatrix}\\
&amp;=&lt;(1,1)\otimes (0,1)^{\otimes n-1},\mathbf{F}&gt;
\end{aligned}
$$</p>
<p>所以可以有（slide 上实际没有证明）</p>
<p>$$
\mathbf{H}=\begin{pmatrix}
1,1\\0,1
\end{pmatrix}^{\otimes n} \mathbf{F},\begin{pmatrix}
1,-1\\0,1
\end{pmatrix}^{\otimes n}\mathbf{H}=\mathbf{F}
$$</p>
<p>那么就有，$F(0&hellip;0)=(1,-1)^{\otimes n}\mathbf{H}$。展开就能得到容斥原理的表达式。</p>
<h3 id="permanent">Permanent</h3>
<p>矩阵$A$的积和式，定义为</p>
<p>$$Permanent(M)=\sum_{\pi \in S_n}\prod M_{j,\pi(j)}$$</p>
<p>对于 $M$ ：</p>
<ul>
<li>n 个点带权有向图，所有圈的权重乘积之和；</li>
<li>二分图的所有完美匹配的权重乘积之和</li>
<li>这个定义对比行列式的定义，去除了符号项</li>
</ul>
<h4 id="ryser-公式">Ryser 公式</h4>
<p>可以定义矩阵的每行加起来，再乘积的结果$\phi(M)$</p>
<p>$$
\phi(M)=\prod(a_{11}+a_{12}+&hellip;)=\prod_i\sum_j a_{ij}
$$</p>
<p>把$\phi(M)$展开，每一项对应每行出一个元素的连乘结果。定义坏事件$A_i$表示每行贡献一项的元素连乘结果，第$i$列没有贡献项。$\phi(M)$作为全集，而积和式可以用容斥原理表达为</p>
<p>$$
\begin{aligned}
Perm(M)&amp;=\sum\prod M_{i,\pi(i)}\\
&amp;=\phi(M)-A_1-A_2&hellip;+A_1\cap A_2&hellip;\\
\end{aligned}
$$</p>
<p>那么，有$k$个坏事件之交$\sum \bigcap^k A_i$结果为</p>
<p>$$T_k=\sum_{B是M的n\times(n-k)子式}\phi(B)$$</p>
<p>那么上述的容斥原理表达式，即可转成指数复杂度的 Ryser 公式，计算积和式</p>
<p>$$
\begin{aligned}
Perm(M)&amp;=\sum (-1)^kT_k\\
&amp;=(-1)^n\sum_{S\subseteq\{1,&hellip;,n\}}(-1)^{|S|}\prod_i\sum_{j\in S}m_{ij}
\end{aligned}
$$</p>
<p>如果考虑积和式对应二分图的带权完美匹配的问题，那么有边的权重关系$(i,j^\prime)=(j^\prime,i)=A_{ij}$（当中$i,j^{\prime}$表示点出自不同部分）</p>
<p>对于二部图，每个点取对称函数$[0,1,0&hellip;0]$（1 个 1，n-1 个 0 时候输出 1，否则输出 0）。如果张量网络求值结果不为 1，说明每个顶点有且只有一条边取 1，那么此时取得完美匹配。。如果把张量网络里一部的点的函数换成$[0,1,1&hellip;1]=(1,1)^{\otimes n}-(1,0)^{\otimes n}=F_1+F_2$，值不变（n 次匹配，必须完美分配才能保证一边不出 0 值）。如果从里面选一个${(1,1)^{\otimes n},-(1,0)^{\otimes n}}$拆开来算，那么分别计算$2^n$次，但每一次当中，一边的点对应边要么全 0 要么全 1，相对简单好算。</p>
<h4 id="模数意义下的快速算法">模数意义下的快速算法</h4>
<p>注意到积和式和行列式在模 2 意义下相等。而且积和式满足如下的关系</p>
<p>$$
Perm\begin{pmatrix}
A_1+bB_1\\ A_2\\ &hellip;\\ A_n
\end{pmatrix}=Perm\begin{pmatrix}
A_1\\ A_2\\ &hellip;\\ A_n
\end{pmatrix}+b\cdot Perm\begin{pmatrix}
B_1\\ A_2\\ &hellip;\\ A_n
\end{pmatrix}
$$</p>
<p>因此可以提出在积和式 $\mod 2^k,k\in \mathbb{Z}^*$意义下的多项式时间算法。首先对于积和式进行高斯分解。假定对第二行有$A_2+kA_1=(0,*)$，那么就有$A_2=(-k)A_1+(0,*)$。利用上述积和式关系，一次分解，会将$n\times n$的方阵，分解出$n-1$个两行相等的积和式，加上一个$(n-1)\times(n-1)$更小的积和式。</p>
<p>令$T_k(n)$表示对$n\times n$的积和式计算$\mod 2^k$意义下的时间，$T_k^\prime(n)$表示对有两行相等的积和式计算$\mod 2^k$意义下的时间。有</p>
<p>$$T_k(n)=(n-1)\cdot T^\prime_k(n)+T_{k-1}(n)+O(n)$$</p>
<p>而对于两行相等的积和式，对两个相同行做展开，有，$T^\prime_k(n)\sim n^2T_{k-1}(n-2)$。因此有$T_k(n)&lt;\Theta(n^{4k+3})$。</p>
<h3 id="匹配问题">匹配问题</h3>
<h4 id="带权匹配问题规约">带权匹配问题规约</h4>
<p>对于完美匹配问题，有如下规约关系。因此主要到#SAT 是#P 完全的，完美匹配计数问题也是<a href="#p">#P 完全的</a></p>
<p>$$
\#SAT\le\#PerM_{\text{有权重}}\le\#PerM_{\text{0,1}}
$$</p>
<p>第二个规约关系的证明。如果权重是正整数，$\star-k-\star$这样一条边可以替换为 $k-1$ 条$\star-0-1-0-\star$和一条$\star-1-\star$的边。因为如果该边在匹配中，顶点$\star$对外的其他边必取 0；而转换之后内部求和的完美匹配权重和的结果和只有一条权为$k$的边相同。</p>
<p>如果权重是任意的$w\in \mathbb{R}$。定义$X_i$为原图完美匹配中去除$i$条权重为$w$的边之后的<strong>部分权重和</strong>。那么全图权重和即为$\#G=\sum w^iX_i$。定义图$G_k$，是将原图的$i$条权重为$w$的边替换为上述$k$条边之后的结果。那么有$\#G_k=\sum k^iX_i$。计算图$G_k$的完美匹配数是计算 01 权重完美匹配数的问题，已经假定存在解法。那么，可以列出关系式</p>
<p>$$
\begin{pmatrix}
&hellip;\\ \#G_k\\ \#G_l\\ &hellip;
\end{pmatrix}=\begin{pmatrix}
&hellip;\\
k^0,k^1,&hellip;k^n\\
l^0,l^1,&hellip;l^n\\ &hellip;
\end{pmatrix}\begin{pmatrix}
X_0\\ X_1\\ &hellip; \\ X_n
\end{pmatrix}
$$</p>
<p>注意到矩阵$\begin{pmatrix}
&hellip;\\
k^0,k^1,&hellip;k^n\\
l^0,l^1,&hellip;l^n\\ &hellip;
\end{pmatrix}$具有 Vandermonde 方阵的形式。Vandermonde 行列式是满秩的。因此可以直接求出$X_0,X_1,&hellip;X_n$，带回去就可以求解$\#G=\sum w^iX_i$。因此规约成立。</p>
<h4 id="一般的匹配问题">一般的匹配问题</h4>
<p>一般的匹配问题的顶点的对称函数变成$[1,1,0&hellip;0]$。完美匹配问题可以规约到求解一般的匹配问题，证明如下</p>
<p>$$
\#PerfectMatch\le\#Match
$$</p>
<p>考虑如下的一个张量网络，对其考虑匹配问题</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-plaintext" data-lang="plaintext"><span class="line"><span class="cl">Fk:
</span></span><span class="line"><span class="cl">*--Mk-.....M2---M1
</span></span><span class="line"><span class="cl">[1,1,0] [1,1,0][1,1]
</span></span></code></pre></td></tr></table>
</div>
</div><p>求值有，把其结果记为$F_k$。如果对应$*$的顶点取 0，结果即为$F_k(0)$，取 1 类似。</p>
<p>$$
\begin{aligned}
&amp;\begin{pmatrix}
1,1\\1,0
\end{pmatrix}^{k-1}\begin{pmatrix}
1\\1
\end{pmatrix}=\begin{pmatrix}
1,1\\1,0
\end{pmatrix}^{k}\begin{pmatrix}
1\\0
\end{pmatrix}\\
&amp;=\frac{1}{\sqrt{5}}\begin{pmatrix}
\frac{1+\sqrt{5}}{2},\frac{1-\sqrt{5}}{2}\\1,1
\end{pmatrix}\begin{pmatrix}
(\frac{1+\sqrt{5}}{2})^k,0\\0,(\frac{1-\sqrt{5}}{2})^k
\end{pmatrix}\begin{pmatrix}
1,\frac{\sqrt{5}-1}{2}\\ -1,\frac{\sqrt{5}+1}{2}
\end{pmatrix}\begin{pmatrix}
1\\0
\end{pmatrix}\\
&amp;=\frac{1}{\sqrt{5}}\begin{pmatrix}
\frac{1+\sqrt{5}}{2},\frac{-1+\sqrt{5}}{2}\\1,-1
\end{pmatrix}\begin{pmatrix}
\alpha^k\\ \beta^k
\end{pmatrix}
\end{aligned}
$$</p>
<p>对于$n$个点的图$G$。定义$Y_i$,表示取一次图的匹配，留下$i$不参加匹配的完美匹配数目。显然，完美匹配数有$\#PM(G)=Y_0$，匹配数有$\#M(G)=\sum Y_i$。考虑修改图$G_k$，把原来图$G$的$n$点全都连接上之前的张量网络链。那么图$G_k$的匹配有（注意到，只有原先没有参与匹配的点，对于新加入的链可以取 1，参加和新的链之间的匹配，即出现$F_k(0)+F_k(1)$的组合）</p>
<p>$$
\begin{aligned}
\#M(G_k)&amp;=\sum Y_i(F_k(0)+F_k(1))^i(F_k(0))^{k-i}\\
&amp;=F_k^n(0)\sum Y_i(\frac{F_k(0)+F_k(1)}{F_k(0)})^i\\
\end{aligned}
$$</p>
<p>当中，有</p>
<p>$$
\begin{aligned}
r_k=\frac{F_k(0)+F_k(1)}{F_k(0)}=\frac{\frac{3+\sqrt{5}}{2}\alpha^k+\frac{\sqrt{5}-3}{2}\beta^k}{\frac{1+\sqrt{5}}{2}\alpha^k+\frac{\sqrt{5}-1}{2}\beta^k}=\begin{pmatrix}
a,b\\ c,d
\end{pmatrix}\begin{pmatrix}
\alpha^k \\ \beta^k
\end{pmatrix}
\end{aligned}
$$</p>
<p>如果要求$s\neq t\implies r_s\neq r_t$，那么充要条件为$ad-bc\neq0,\frac{\alpha}{\beta}\neq 1$。容易验证这些条件都是满足的。由于假定已知求解图$G_k$的匹配的算法，类似上面的，$(r_k)^i$还是可以构造出 Vandermonde 方阵的形式。从而求解出$Y_0,Y_1,&hellip;Y_n$，从而得出完美匹配数$\#PM(G)=Y_0$。因为我们已知<a href="#%E5%B8%A6%E6%9D%83%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98%E8%A7%84%E7%BA%A6">完美匹配是#P 完全问题</a>，所以匹配问题也是<a href="#p">#P 完全问题</a>。</p>
<h3 id="匹配门">匹配门</h3>
<p>用对称函数$[0,1,0&hellip;0]$和$[w_1,0,w_2]$构建的张量网络，称为匹配门$F:\{0,1\}^n\to \mathbb{C}$。假定两个输出$\alpha,\beta\in\{0,1\}^n$，把$\alpha,\beta$不相等的标号升序排列记为$\{p_1,p_2,&hellip;p_k\}$。那么，有匹配门等式</p>
<p>$$I(F,\alpha,\beta)=\sum (-1)^jF(\alpha\oplus p_j)F(\beta\oplus p_j)=0$$</p>
<p>由归纳法证明。起始函数是满足的。<strong>平面</strong>张量网络两个基本运算对匹配门等式封闭。（<a href="#%E7%AE%97%E6%B3%95%E4%B8%80">和斐波那契门算法 1 里的操作相似</a>）</p>
<h4 id="juxtaposition">Juxtaposition</h4>
<p>两个匹配门在平面上连在一起。（注意变量没有交错，平面条件在此）</p>
<p>$$F(x_1,..x_s,y_1,&hellip;y_t)=P(x_1,..x_s)Q(y_1,&hellip;y_t)$$</p>
<p>有</p>
<p>$$I(F,\alpha\alpha^\prime,\beta\beta^\prime)=Q(\alpha^\prime)Q(\beta^\prime)I(P,\alpha,\beta)\pm P(\alpha)P(\beta)I(Q,\alpha^\prime,\beta^\prime)=0$$</p>
<p>证毕</p>
<h4 id="jumper">Jumper</h4>
<p>匹配门两条边成自环，不妨设是$x_1,x_2$</p>
<p>$$F(x_3,&hellip;x_3)=P(0,0,x_3,&hellip;x_s)+P(1,1,x_3,&hellip;x_s)$$</p>
<p>有</p>
<p>$$
\begin{aligned}
I(F,\alpha,\beta)&amp;=I(P,00\alpha,00\beta)+I(P,11\alpha,11\beta)\\
&amp;+(I(P,00\alpha,11\beta)+P(10\alpha)P(01\beta)-P(01\alpha)P(10\beta))\\
&amp;+(I(P,11\alpha,00\beta)+P(01\alpha)P(10\beta)-P(10\alpha)P(01\beta))=0
\end{aligned}
$$</p>
<p>证毕</p>
<h2 id="附录-基础知识">附录-基础知识</h2>
<h3 id="markov-inequality">Markov-Inequality</h3>
<p>$$
\begin{aligned}
&amp;X\ge0,\forall c\ge0\\
&amp;\implies Pr(X\ge c)\le\frac{E(X)}{c}
\end{aligned}
$$</p>
<p>证明是显然的</p>
<h3 id="chebyshev-inequality">Chebyshev-Inequality</h3>
<p>$$
\begin{aligned}
&amp;X,\forall c\ge 0\\
&amp;\implies Pr(|X-E(x)|\ge c)\le\frac{Var(X)}{c^2}
\end{aligned}
$$</p>
<p>注意到$Pr(|X-E(x)|\ge c)=Pr((X-E(x))^2\ge c^2)$，然后化归到 <a href="#markov-inequality">Markov 不等式</a>Chebyshev 不等式适用以下场景：</p>
<ol>
<li>变量之间独立，方差等于各自方差和</li>
<li>变量之间负相关，可以放缩方差和</li>
<li>变量之间两两独立，但不独立（eg，2 个独立 01 变量，再一个为前两个的异或），协方差均为 0，方差等于各自方差和</li>
</ol>
<h4 id="抽样调查准确率">抽样调查准确率</h4>
<p>作为 <a href="#chebyshev-inequality">Chebyshev 不等式</a>的应用。 抽样 n 个，调查出来的概率$\hat{p}=\frac{X_1+&hellip;X_n}{n}=\frac{X}{n}$。对其和真实概率$p=\frac{|T|}{|U|}$的偏移有要求：</p>
<p>$$Pr(|\hat{p}-p|\le \Delta)\ge 1-\epsilon \implies Pr(|\hat{p}-p|\ge \Delta)\le \epsilon $$</p>
<p>$$
\begin{aligned}
&amp;Pr(|\hat{p}-p|\ge \Delta)\\
&amp;=Pr(|\frac{X}{n}-p|\ge \Delta)\\
&amp;=Pr(|X-np|\ge n\Delta)\\
&amp;\le\frac{Var(X)}{(n\Delta)^2}\\
&amp;\le\frac{1}{4n\Delta^2}
\end{aligned}
$$</p>
<p>要求的抽样$n$的取值只和要求的$\Delta,\epsilon$有关（$n\ge\frac{1}{4\epsilon\Delta^2}$），和真实概率$p$本身分布无关。但是，如果知道真实分布，可以改善$n$的取值。</p>
<p>如果使用 <a href="#chernoff-bound">chernoff bound 去估计</a>，可以指定相对误差$\delta\in(0,1)$。如果有如下的要求</p>
<p>$$Pr(\hat{p}\in[(1-\delta)p,(1+\delta)p])\ge 1-\epsilon$$</p>
<p>则有</p>
<p>$$
\begin{aligned}
&amp;Pr(|\hat{p}-p|\ge\delta )\\
&amp;=Pr(|\frac{X_1+&hellip;X_n}{n}-p|\ge\delta)\\
&amp;\le 2e^{-\frac{\delta^2}{3}n\mu}
\end{aligned}
$$</p>
<p>推出要求数目为$n\ge \frac{3(\ln 2-\ln\epsilon)}{\delta^2 p}$。改进为对错误率的对数形式。但是此时对$n$的要求和原始分布$p$有关。</p>
<h3 id="组合数不等式">组合数不等式</h3>
<p>$$
(\frac{n}{m})^m\le\binom{n}{m}\le(\frac{ne}{m})^m
$$</p>
<p>第一个小于等于证明：</p>
<p>$$
\begin{aligned}
\binom{n}{m}&amp;=\frac{n!}{m!(n-m)!}\\
&amp;=\frac{(n)..(n-m+1)}{(m)&hellip;(1)}\\
&amp;=\frac{n}{m}\frac{n-1}{m-1}&hellip;\frac{n-m+1}{1}\\
&amp;\ge (\frac{n}{m})^m
\end{aligned}
$$</p>
<p>注意到$\frac{(\frac{n+2}{n+1})^n}{n+1}(n+2)=(1+\frac{1}{n+1})^{n+1}\le e$。进行数学归纳法，有$\frac{(n+1)^n}{n!}\le e^n$。第二个小于等于证明：</p>
<p>$$
\begin{aligned}
\binom{n}{m}&amp;=\frac{n!}{m!(n-m)!}\\
&amp;=\frac{(n)&hellip;(n-m+1)}{m!}\\
&amp;\le e^m\frac{(n)&hellip;(n-m+1)}{(m+1)^m}\\
&amp;\le (\frac{ne}{m})^m
\end{aligned}
$$</p>
<h3 id="chernoff-bound">Chernoff-Bound</h3>
<p>$X_1,X_2,&hellip;X_n$为 n 个 <strong>01</strong>（如果不是，需要正规化 normalize ） 的<strong>独立</strong>随机变量，$Pr(X_i=1)=p_i$，考虑随机变量和$X=\sum X_i$，均值$E(X)=\mu=\sum p_i$。对于一个偏离$\forall \delta\in (0,1)$（正向偏差时候大于 1 也可以，主要是负向概率不能为负。而最后的 exp 形式放缩需要$\delta\in(0,1)$）。</p>
<p>$$
Pr(X\ge \mu(1+\delta))\le [\frac{e^\delta}{(1+\delta)^{1+\delta}}]^\mu\le e^{-\frac{\delta^2}{3}\mu}
$$</p>
<p>$$
Pr(X\le \mu(1-\delta))\le [\frac{e^{-\delta}}{(1-\delta)^{1-\delta}}]^\mu\le e^{-\frac{\delta^2}{2}\mu}
$$</p>
<p>放缩成双向的</p>
<p>$$
Pr(|X-\mu|\ge \delta\mu)\le 2e^{-\frac{\delta^2}{3}\mu}
$$</p>
<p>eg：抛硬币 1000 次，800+次正面，$e^{-\frac{(3/5)^2}{3}\cdot \frac{n}{2}}$，指数小的概率，对比 <a href="#chebyshev-inequality">Chebyshev 里面只能 1/n 级别</a></p>
<h4 id="正向的证明">正向的证明</h4>
<p>$$
\begin{aligned}
&amp;Pr(X\ge(1+\delta)\mu)\\
&amp;=Pr(e^{\lambda X}\ge e^{\lambda(1+\delta)\mu})\qquad \lambda&gt;0\\
&amp;\le \frac{E(e^{\lambda X})}{e^{\lambda(1+\delta)\mu}}\\
&amp;=\frac{\prod E(e^{\lambda X_i})}{e^{\lambda(1+\delta)\mu}}\\
&amp;=\frac{\prod ((1-p_i)+p_ie^{\lambda})}{e^{\lambda(1+\delta)\mu}}\\
&amp;=\frac{\prod (1+p_i(e^{\lambda}-1))}{e^{\lambda(1+\delta)\mu}}\\
&amp;\le \frac{\prod e^{p_i(e^{\lambda}-1)}}{e^{\lambda(1+\delta)\mu}}\\
&amp;=\frac{e^{(e^{\lambda}-1)\mu}}{e^{\lambda(1+\delta)\mu}}\\
&amp;=e^{(e^\lambda-1-\lambda(1+\delta))\mu}\qquad \lambda=\ln(1+\delta)&gt;0\\
&amp;=e^{(1+\delta-1-(1+\delta)\ln (1+\delta))\mu}\\
&amp;=[\frac{e^\delta}{(1+\delta)^{1+\delta}}]^\mu
\end{aligned}
$$</p>
<p>在 $\delta\in(0,1)$时候，可以改写$e^{(1+\delta-1-(1+\delta)\ln (1+\delta))\mu}$，得出上界估计$e^{-\frac{\delta^2}{3}\mu}$</p>
<p>$$
\begin{aligned}
&amp;\delta -(1+\delta)\ln (1+\delta)\\
&amp;=\delta-(1+\delta)(\delta-\frac{\delta^2}{2}+\frac{\delta^3}{3}&hellip;)\\
&amp;=(\frac{\delta^2}{2}-\frac{\delta^3}{3}&hellip;)-(\delta^2-\frac{\delta^3}{2}+\frac{\delta^3}{3}&hellip;)\\
&amp;=-\frac{\delta^2}{2}+\frac{\delta^3}{6}&hellip;\\
&amp;\le -\frac{\delta^2}{2}+\frac{\delta^2}{6}=-\frac{\delta^2}{3}
\end{aligned}
$$</p>
<h4 id="负向的证明">负向的证明</h4>
<p>类似的，</p>
<p>$$
\begin{aligned}
&amp;Pr(X\le(1-\delta)\mu)\\
&amp;=Pr(e^{\lambda X}\ge e^{\lambda(1-\delta)\mu})\qquad \lambda&lt;0\\
&amp;\le \frac{E(e^{\lambda X})}{e^{\lambda(1-\delta)\mu}}\\
&amp;=\frac{\prod E(e^{\lambda X_i})}{e^{\lambda(1-\delta)\mu}}\\
&amp;=\frac{\prod ((1-p_i)+p_ie^{\lambda})}{e^{\lambda(1-\delta)\mu}}\\
&amp;=\frac{\prod (1+p_i(e^{\lambda}-1))}{e^{\lambda(1-\delta)\mu}}\\
&amp;\le \frac{\prod e^{p_i(e^{\lambda}-1)}}{e^{\lambda(1-\delta)\mu}}\\
&amp;=\frac{e^{(e^{\lambda}-1)\mu}}{e^{\lambda(1-\delta)\mu}}\\
&amp;=e^{(e^\lambda-1-\lambda(1-\delta))\mu}\qquad \lambda=\ln(1-\delta)&lt;0\\
&amp;=e^{(1-\delta-1-(1-\delta)\ln (1-\delta))\mu}\\
&amp;=[\frac{e^{-\delta}}{(1-\delta)^{1-\delta}}]^\mu\\
\end{aligned}
$$</p>
<p>在 $\delta\in(0,1)$时候，可以改写$e^{(1-\delta-1-(1-\delta)\ln (1-\delta))\mu}$，得出上界估计$e^{-\frac{\delta^2}{2}\mu}$</p>
<p>$$
\begin{aligned}
&amp;-\delta -(1-\delta)\ln (1-\delta)\\
&amp;=-\delta+(1-\delta)(\delta+\frac{\delta^2}{2}+\frac{\delta^3}{3}&hellip;)\\
&amp;=(\frac{\delta^2}{2}+\frac{\delta^3}{3}&hellip;)-(\delta^2+\frac{\delta^3}{2}+\frac{\delta^4}{3}&hellip;)\\
&amp;\le -\frac{\delta^2}{2}
\end{aligned}
$$</p>
<h3 id="fermat-little-theorem">Fermat-Little-Theorem</h3>
<p>$$p\in prime\implies \forall a,a^p\equiv a\pmod p$$</p>
<p>$$(a,p)=1\implies a^{p-1}\equiv 1\pmod{p}$$</p>
<p>注意集合${1,2,&hellip;(p-1)}$和集合 ${1\times a,2\times a ,&hellip;(p-1)\times a}$在$\mod p$意义上相等。因此有</p>
<p>$(p-1)!\equiv a^{p-1}(p-1)!\pmod p\implies a^{p-1}\equiv 1\pmod{p}$</p>
<h4 id="carmichael-number">Carmichael-Number</h4>
<p>是合数，但是能够保证通过 <a href="#fermat-little-theorem">费马小定理的检测</a>。</p>
<p>$N=561=3\times 11 \times 17,\forall a,(a,N)=1\implies a^{560}\equiv 1\pmod{561}$</p>
<p>可以使用 <a href="#%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86">中国剩余定理</a>证明 561 满足性质要求。</p>
<p>$$
\left\{
\begin{aligned}
&amp;a^{560}=(a^{2})^{280}=1^{280}\equiv 1\pmod{3}\\
&amp;a^{560}=(a^{10})^{56}=1^{56}\equiv 1\pmod{11}\\
&amp;a^{560}=(a^{16})^{35}=1^{35}\equiv 1\pmod{17}
\end{aligned}
\right.
$$</p>
<p>有无数个 Carmichael Number，而且对于足够大的一个 m，$(m,2m)$之间一定有一个 Carmichael Number（论文证明）。</p>
<h4 id="中国剩余定理">中国剩余定理</h4>
<blockquote>
<p>今有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二，问物几何？</p>
</blockquote>
<p>$$
\left\{
\begin{aligned}
&amp;x=2\pmod 3\\
&amp;x=3\pmod 5\\
&amp;x=2\pmod 7
\end{aligned}
\right.
$$</p>
<p>$$
\begin{aligned}
x=2\times &amp;70+3\times &amp;21+2\times &amp;15\\
(1,&amp;0,0) &amp;(0,1,0) (0,&amp;0,1)
\end{aligned}
$$</p>
<p>可以认为是用不同的余数的基底组合而成。可以推广为以下同余方程组，保证有解</p>
<p>$$
\left\{
\begin{aligned}
&amp;x=n_1\pmod {m_1}\\
&amp;x=n_2\pmod {m_2}\\
&amp;&hellip;\\
&amp;x=n_k\pmod {m_k}
\end{aligned}
\right.
$$</p>
<p>解为</p>
<p>$$x\equiv \sum n_i\times M_i\pmod{\prod m_i}$$</p>
<p>当中</p>
<p>$$
\left\{
\begin{aligned}
&amp;M_i\equiv 0\pmod{\frac{\prod m_k}{m_i}}\\
&amp;M_i\equiv 1\pmod{m_i}
\end{aligned}
\right.
$$</p>
<p>有 Bezout 定理，$GCD(x,y)=1\iff \exists r,s,rx+sy=1$。因此可以表达为$M_i=r(\frac{\prod m_k}{m_i})=1-sm_i$。$r,s$通过<a href="#gcd">辗转相除法的中间系数计算</a></p>
<h3 id="schwartz-zippel-lemma">Schwartz-Zippel-Lemma</h3>
<p>对于数域$\mathbb{F}$，多项式$0\not\equiv P(y_1,&hellip;y_n)\in\mathbb{F}[y1,&hellip;y_n]$。独立随机在有限集$S$中取$r_1,&hellip;r_n\in S\subseteq \mathbb{F}$，有</p>
<p>$$
Pr(P(r1,&hellip;r_n)=0)\le\frac{\deg(p)}{|S|}
$$</p>
<p>注意，对于多元多项式，每项的次数等于元的次数和，整个多项式的$\deg$为每项中的最大值。</p>
<p>数学归纳法证明，$n=1$时候，由代数基本定理容易知道,最多$\deg(P)$个根，不一定根全在$S$当中。假设$n=k$成立，对于$n=k+1$时候，分离出一个变元，如$y_1$，把$y_1$次数最高的项（设大小为 d）提出，</p>
<p>$$P(y1,&hellip;y_{k+1})=y_1^d\cdot Q(y_2,&hellip;y_{k+1})+R(y_1,&hellip;y_{k+1})$$</p>
<p>此时有$\deg(Q)\le \deg(P)-d,\deg(R)\le \deg(P)$</p>
<p>$$
\begin{aligned}
&amp;Pr(P(r_1,&hellip;r_{k+1})=0)\\
&amp;=Pr(P=0,Q(r_1,&hellip;r_{k+1})=0)+Pr(P=0,Q\neq0)\\
&amp;\le Pr(Q=0)+P(P=0,Q\neq 0)\\
&amp;\le \frac{\deg(Q)}{|S|}+P(P=0,Q\neq 0)\\
&amp;\le \frac{\deg(P)-d}{|S|}+P(P=0,Q\neq 0)\\
&amp;\le \frac{\deg(P)-d}{|S|}+\frac{d}{|S|}\qquad\text{关于$y_1$的d次多项式的情况}\\
&amp;=\frac{\deg(P)}{|S|}
\end{aligned}
$$</p>
]]></content:encoded></item><item><title>Michael&amp;Scott 无锁队列</title><link>https://livypad.github.io/post/2022-11-02-mbqueue/</link><pubDate>Wed, 02 Nov 2022 00:22:50 +0800</pubDate><guid>https://livypad.github.io/post/2022-11-02-mbqueue/</guid><description>MB 无锁队列复现和原论文的纠错 纠错 Michael&amp;amp;Scott 1 给出了了一个无锁队列的实现。在我实际用 Java 语音复现时，发现其给出的伪代码有一处问题。 原始版本的enque有</description><content:encoded><![CDATA[<h1 id="mb-无锁队列复现和原论文的纠错">MB 无锁队列复现和原论文的纠错</h1>
<h2 id="纠错">纠错</h2>
<p>Michael&amp;Scott <sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> 给出了了一个无锁队列的实现。在我实际用 Java 语音复现时，发现其给出的伪代码有一处问题。</p>
<p>原始版本的<code>enque</code>有一处是错误的。红色标明的行中，第一个<code>if</code>判断了<code>next.ptr==null</code>之后，第二个 CAS 里面，直接比较<code>next.ptr</code>和其自己的值。但这两个语句之间，实际上另一个线程可能已经把<code>next.ptr</code>赋值了，这样 CAS 肯定成功，因为自己等于自己，但这样就会把已经连上的节点替换掉。</p>
<p><img loading="lazy" src="/assets/img/mbqueue1.png" alt="code"  />
</p>
<p>我们可通过如下一个简单的实验证实（完整的框架见<a href="#%E5%A4%8D%E7%8E%B0%E4%BB%A3%E7%A0%81">下面</a>）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="o">(</span><span class="n">next</span><span class="o">.</span><span class="na">getReference</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="o">(</span><span class="n">next</span><span class="o">.</span><span class="na">getReference</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">err</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;bad things happen!!!&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">next</span><span class="o">.</span><span class="na">compareAndSet</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                            <span class="n">node</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                            <span class="n">next</span><span class="o">.</span><span class="na">getStamp</span><span class="o">(),</span>
</span></span><span class="line"><span class="cl">                            <span class="n">next</span><span class="o">.</span><span class="na">getStamp</span><span class="o">()</span> <span class="o">+</span> <span class="n">1</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span> <span class="k">else</span> <span class="o">{...}</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="/assets/img/mbqueue2.png" alt="result"  />
</p>
<p>所以，那里的 CAS 应该改成<code>CAS(&amp;tail.next-&gt;ptr,NULL,next,[node,next.count+1])</code>。最后是完整的复现和测试代码。测试里开 100 个进程，分别入队 10000 个字符串。然后检查每个进程出队的顺序是不是入队的顺序。结果符合预期。</p>
<h2 id="复现代码">复现代码</h2>
<h3 id="queuejava">Queue.java</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">java.util.concurrent.atomic.AtomicStampedReference</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Queue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">final</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">sentinel</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">    <span class="kd">final</span> <span class="n">AtomicStampedReference</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">Head</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">final</span> <span class="n">AtomicStampedReference</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">Tail</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Queue</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Head</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicStampedReference</span><span class="o">&lt;&gt;(</span><span class="n">sentinel</span><span class="o">,</span> <span class="n">0</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">Tail</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicStampedReference</span><span class="o">&lt;&gt;(</span><span class="n">sentinel</span><span class="o">,</span> <span class="n">0</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">enqueue</span><span class="o">(</span><span class="n">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;&gt;(</span><span class="n">value</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">AtomicStampedReference</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">tail</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicStampedReference</span><span class="o">&lt;&gt;(</span><span class="kc">null</span><span class="o">,</span> <span class="n">0</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">AtomicStampedReference</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">next</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">tail</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">Tail</span><span class="o">.</span><span class="na">getReference</span><span class="o">(),</span> <span class="n">Tail</span><span class="o">.</span><span class="na">getStamp</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">            <span class="n">next</span> <span class="o">=</span> <span class="n">tail</span><span class="o">.</span><span class="na">getReference</span><span class="o">().</span><span class="na">next</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">(</span><span class="n">tail</span><span class="o">.</span><span class="na">getReference</span><span class="o">()</span> <span class="o">==</span> <span class="n">Tail</span><span class="o">.</span><span class="na">getReference</span><span class="o">())</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="o">(</span><span class="n">next</span><span class="o">.</span><span class="na">getReference</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="o">(</span><span class="n">next</span><span class="o">.</span><span class="na">compareAndSet</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                                           <span class="n">node</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                                           <span class="n">next</span><span class="o">.</span><span class="na">getStamp</span><span class="o">(),</span>
</span></span><span class="line"><span class="cl">                                           <span class="n">next</span><span class="o">.</span><span class="na">getStamp</span><span class="o">()</span> <span class="o">+</span> <span class="n">1</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                        <span class="k">break</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                    <span class="o">}</span>
</span></span><span class="line"><span class="cl">                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">Tail</span><span class="o">.</span><span class="na">compareAndSet</span><span class="o">(</span><span class="n">tail</span><span class="o">.</span><span class="na">getReference</span><span class="o">(),</span>
</span></span><span class="line"><span class="cl">                                       <span class="n">next</span><span class="o">.</span><span class="na">getReference</span><span class="o">(),</span>
</span></span><span class="line"><span class="cl">                                       <span class="n">tail</span><span class="o">.</span><span class="na">getStamp</span><span class="o">(),</span>
</span></span><span class="line"><span class="cl">                                       <span class="n">tail</span><span class="o">.</span><span class="na">getStamp</span><span class="o">()</span> <span class="o">+</span> <span class="n">1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="o">}</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">Tail</span><span class="o">.</span><span class="na">compareAndSet</span><span class="o">(</span><span class="n">tail</span><span class="o">.</span><span class="na">getReference</span><span class="o">(),</span> <span class="n">node</span><span class="o">,</span> <span class="n">tail</span><span class="o">.</span><span class="na">getStamp</span><span class="o">(),</span> <span class="n">tail</span><span class="o">.</span><span class="na">getStamp</span><span class="o">()</span> <span class="o">+</span> <span class="n">1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">boolean</span> <span class="nf">dequeue</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">AtomicStampedReference</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicStampedReference</span><span class="o">&lt;&gt;(</span><span class="kc">null</span><span class="o">,</span> <span class="o">-</span><span class="n">1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">AtomicStampedReference</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">tail</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicStampedReference</span><span class="o">&lt;&gt;(</span><span class="kc">null</span><span class="o">,</span> <span class="o">-</span><span class="n">1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">AtomicStampedReference</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">next</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">head</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">Head</span><span class="o">.</span><span class="na">getReference</span><span class="o">(),</span> <span class="n">Head</span><span class="o">.</span><span class="na">getStamp</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">            <span class="n">tail</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">Tail</span><span class="o">.</span><span class="na">getReference</span><span class="o">(),</span> <span class="n">Tail</span><span class="o">.</span><span class="na">getStamp</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">            <span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">getReference</span><span class="o">().</span><span class="na">next</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">getReference</span><span class="o">()</span> <span class="o">==</span> <span class="n">Head</span><span class="o">.</span><span class="na">getReference</span><span class="o">())</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">getReference</span><span class="o">()</span> <span class="o">==</span> <span class="n">tail</span><span class="o">.</span><span class="na">getReference</span><span class="o">())</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="o">(</span><span class="n">next</span><span class="o">.</span><span class="na">getReference</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                    <span class="o">}</span>
</span></span><span class="line"><span class="cl">                    <span class="n">Tail</span><span class="o">.</span><span class="na">compareAndSet</span><span class="o">(</span><span class="n">tail</span><span class="o">.</span><span class="na">getReference</span><span class="o">(),</span> <span class="n">next</span><span class="o">.</span><span class="na">getReference</span><span class="o">(),</span> <span class="n">tail</span><span class="o">.</span><span class="na">getStamp</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">                            <span class="o">,</span> <span class="n">tail</span><span class="o">.</span><span class="na">getStamp</span><span class="o">()</span> <span class="o">+</span> <span class="n">1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="o">(</span><span class="n">Head</span><span class="o">.</span><span class="na">compareAndSet</span><span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">getReference</span><span class="o">(),</span>
</span></span><span class="line"><span class="cl">                                           <span class="n">next</span><span class="o">.</span><span class="na">getReference</span><span class="o">(),</span>
</span></span><span class="line"><span class="cl">                                           <span class="n">head</span><span class="o">.</span><span class="na">getStamp</span><span class="o">(),</span>
</span></span><span class="line"><span class="cl">                                           <span class="n">head</span><span class="o">.</span><span class="na">getStamp</span><span class="o">()</span> <span class="o">+</span> <span class="n">1</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                        <span class="k">break</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                    <span class="o">}</span>
</span></span><span class="line"><span class="cl">                <span class="o">}</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">boolean</span> <span class="nf">dequeue</span><span class="o">(</span><span class="n">T</span><span class="o">[]</span> <span class="n">temp</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">AtomicStampedReference</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicStampedReference</span><span class="o">&lt;&gt;(</span><span class="kc">null</span><span class="o">,</span> <span class="o">-</span><span class="n">1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">AtomicStampedReference</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">tail</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicStampedReference</span><span class="o">&lt;&gt;(</span><span class="kc">null</span><span class="o">,</span> <span class="o">-</span><span class="n">1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">AtomicStampedReference</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">next</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">head</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">Head</span><span class="o">.</span><span class="na">getReference</span><span class="o">(),</span> <span class="n">Head</span><span class="o">.</span><span class="na">getStamp</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">            <span class="n">tail</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">Tail</span><span class="o">.</span><span class="na">getReference</span><span class="o">(),</span> <span class="n">Tail</span><span class="o">.</span><span class="na">getStamp</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">            <span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">getReference</span><span class="o">().</span><span class="na">next</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">getReference</span><span class="o">()</span> <span class="o">==</span> <span class="n">Head</span><span class="o">.</span><span class="na">getReference</span><span class="o">())</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">getReference</span><span class="o">()</span> <span class="o">==</span> <span class="n">tail</span><span class="o">.</span><span class="na">getReference</span><span class="o">())</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="o">(</span><span class="n">next</span><span class="o">.</span><span class="na">getReference</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                    <span class="o">}</span>
</span></span><span class="line"><span class="cl">                    <span class="n">Tail</span><span class="o">.</span><span class="na">compareAndSet</span><span class="o">(</span><span class="n">tail</span><span class="o">.</span><span class="na">getReference</span><span class="o">(),</span> <span class="n">next</span><span class="o">.</span><span class="na">getReference</span><span class="o">(),</span> <span class="n">tail</span><span class="o">.</span><span class="na">getStamp</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">                            <span class="o">,</span> <span class="n">tail</span><span class="o">.</span><span class="na">getStamp</span><span class="o">()</span> <span class="o">+</span> <span class="n">1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">temp</span><span class="o">[</span><span class="n">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">next</span><span class="o">.</span><span class="na">getReference</span><span class="o">().</span><span class="na">value</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="o">(</span><span class="n">Head</span><span class="o">.</span><span class="na">compareAndSet</span><span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">getReference</span><span class="o">(),</span>
</span></span><span class="line"><span class="cl">                                           <span class="n">next</span><span class="o">.</span><span class="na">getReference</span><span class="o">(),</span>
</span></span><span class="line"><span class="cl">                                           <span class="n">head</span><span class="o">.</span><span class="na">getStamp</span><span class="o">(),</span>
</span></span><span class="line"><span class="cl">                                           <span class="n">head</span><span class="o">.</span><span class="na">getStamp</span><span class="o">()</span> <span class="o">+</span> <span class="n">1</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                        <span class="k">break</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                    <span class="o">}</span>
</span></span><span class="line"><span class="cl">                <span class="o">}</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">goThrough</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">AtomicStampedReference</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">Head</span><span class="o">.</span><span class="na">getReference</span><span class="o">().</span><span class="na">next</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="o">(</span><span class="n">iter</span><span class="o">.</span><span class="na">getReference</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">iter</span><span class="o">.</span><span class="na">getReference</span><span class="o">().</span><span class="na">value</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">iter</span> <span class="o">=</span> <span class="n">iter</span><span class="o">.</span><span class="na">getReference</span><span class="o">().</span><span class="na">next</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">T</span> <span class="n">value</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">final</span> <span class="n">AtomicStampedReference</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicStampedReference</span><span class="o">&lt;&gt;(</span><span class="kc">null</span><span class="o">,</span> <span class="n">0</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">(</span><span class="n">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="mainjava">Main.java</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Queue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Queue</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">10000</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">Thread</span><span class="o">[]</span> <span class="n">clusters</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">[</span><span class="n">100</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">clusters</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">finalJ</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">clusters</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">q</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&#34;%d %d&#34;</span><span class="o">,</span> <span class="n">finalJ</span><span class="o">,</span> <span class="n">i</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">                <span class="o">}</span>
</span></span><span class="line"><span class="cl">                <span class="k">try</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">100</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                    <span class="k">throw</span> <span class="k">new</span> <span class="n">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                <span class="o">}</span>
</span></span><span class="line"><span class="cl">            <span class="o">});</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(</span><span class="n">Thread</span> <span class="n">cluster</span> <span class="o">:</span> <span class="n">clusters</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">cluster</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(</span><span class="n">Thread</span> <span class="n">cluster</span> <span class="o">:</span> <span class="n">clusters</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">cluster</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kt">int</span><span class="o">[]</span> <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">clusters</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">String</span><span class="o">[]</span> <span class="n">holder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">[</span><span class="n">1</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">clusters</span><span class="o">.</span><span class="na">length</span> <span class="o">*</span> <span class="n">num</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">dequeue</span><span class="o">(</span><span class="n">holder</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">String</span><span class="o">[]</span> <span class="n">re</span> <span class="o">=</span> <span class="n">holder</span><span class="o">[</span><span class="n">0</span><span class="o">].</span><span class="na">split</span><span class="o">(</span><span class="s">&#34; &#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">re</span><span class="o">[</span><span class="n">0</span><span class="o">]);</span>
</span></span><span class="line"><span class="cl">                <span class="kt">int</span> <span class="n">var</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">re</span><span class="o">[</span><span class="n">1</span><span class="o">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="o">(</span><span class="n">out</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">var</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&#34;%d %d&gt;%d%n&#34;</span><span class="o">,</span> <span class="n">index</span><span class="o">,</span> <span class="n">out</span><span class="o">[</span><span class="n">index</span><span class="o">],</span> <span class="n">var</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                    <span class="n">System</span><span class="o">.</span><span class="na">exit</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                <span class="o">}</span>
</span></span><span class="line"><span class="cl">                <span class="n">out</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">var</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>MICHAEL M M, SCOTT M L, 1998. Nonblocking Algorithms and Preemption-Safe Locking on Multiprogrammed Shared Memory Multiprocessors[J/OL]. Journal of Parallel and Distributed Computing, 51(1): 1-26. DOI:10.1006/jpdc.1998.1446.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
]]></content:encoded></item><item><title>笔记：Distributed Systems An Algorithmic Approach 2nd（更新到第10章）</title><link>https://livypad.github.io/post/2022-07-09-ghoshdsaaa/</link><pubDate>Tue, 04 Oct 2022 01:31:57 +0800</pubDate><guid>https://livypad.github.io/post/2022-07-09-ghoshdsaaa/</guid><description>Ghosh, Sukumar (2014) - Distributed Systems An Algorithmic Approach Ch 1 introduction Ch 2 interprocess communication naming rpc remote procedure call cloud computing MapReduce ch 3 Models for Communication shared variable 共享变量 linda mobile agent 模型强弱 resequencing protocol, 非 FIFO 模拟 FIFO 共享变量模拟信息传递 信息传递模拟共享变量 信</description><content:encoded><![CDATA[<ul>
<li><a href="#ghosh-sukumar-2014---distributed-systems-an-algorithmic-approach">Ghosh, Sukumar (2014) - Distributed Systems An Algorithmic Approach</a>
<ul>
<li><a href="#ch-1-introduction">Ch 1 introduction</a></li>
<li><a href="#ch-2-interprocess-communication">Ch 2 interprocess communication</a>
<ul>
<li><a href="#naming">naming</a></li>
<li><a href="#rpc-remote-procedure-call">rpc remote procedure call</a></li>
<li><a href="#cloud-computing">cloud computing</a>
<ul>
<li><a href="#mapreduce">MapReduce</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#ch-3-models-for-communication">ch 3 Models for Communication</a>
<ul>
<li><a href="#shared-variable-%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F">shared variable 共享变量</a>
<ul>
<li><a href="#linda">linda</a></li>
<li><a href="#mobile-agent">mobile agent</a></li>
</ul>
</li>
<li><a href="#%E6%A8%A1%E5%9E%8B%E5%BC%BA%E5%BC%B1">模型强弱</a>
<ul>
<li><a href="#resequencing-protocol-%E9%9D%9E-fifo-%E6%A8%A1%E6%8B%9F-fifo">resequencing protocol, 非 FIFO 模拟 FIFO</a></li>
<li><a href="#%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E6%A8%A1%E6%8B%9F%E4%BF%A1%E6%81%AF%E4%BC%A0%E9%80%92">共享变量模拟信息传递</a></li>
<li><a href="#%E4%BF%A1%E6%81%AF%E4%BC%A0%E9%80%92%E6%A8%A1%E6%8B%9F%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F">信息传递模拟共享变量</a></li>
<li><a href="#%E4%BF%A1%E9%81%93%E5%88%A4%E7%A9%BA%E7%9A%84%E4%B8%8D%E5%8F%AF%E8%83%BD%E6%80%A7">信道判空的不可能性</a></li>
</ul>
</li>
<li><a href="#%E7%B3%BB%E7%BB%9F%E5%88%86%E7%B1%BB">系统分类</a></li>
<li><a href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E6%95%B0">复杂度计数</a></li>
</ul>
</li>
<li><a href="#ch-4-representing-distributed-algorithms">ch 4 Representing Distributed Algorithms</a>
<ul>
<li><a href="#%E5%85%AC%E6%AD%A3%E6%80%A7">公正性</a></li>
<li><a href="#scheduler">scheduler</a></li>
</ul>
</li>
<li><a href="#ch-5-program-correctness">ch 5 Program Correctness</a>
<ul>
<li><a href="#%E6%96%AD%E8%A8%80%E6%8E%A8%E7%90%86-assertional-reasoning">断言推理 assertional reasoning</a></li>
<li><a href="#%E8%89%AF%E5%9F%BA%E9%9B%86-well-founeded-set">良基集 well-founeded set</a></li>
<li><a href="#%E6%97%B6%E9%97%B4%E9%80%BB%E8%BE%91-temporal-logic">时间逻辑 temporal logic</a></li>
</ul>
</li>
<li><a href="#ch-6-time-in-a-distributed-system">ch 6 Time in a Distributed System</a>
<ul>
<li><a href="#%E9%80%BB%E8%BE%91%E6%97%B6%E9%92%9F">逻辑时钟</a>
<ul>
<li><a href="#%E5%BC%B1%E6%97%B6%E9%92%9F%E6%9D%A1%E4%BB%B6-%E5%81%8F%E5%BA%8F%E5%85%B3%E7%B3%BB-prec">弱时钟条件 偏序关系 $\prec$</a></li>
<li><a href="#%E5%BC%B1%E6%97%B6%E9%92%9F%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%80%BB%E8%BE%91%E6%97%B6%E9%92%9F-logic-clock">弱时钟实现的逻辑时钟 logic clock</a></li>
<li><a href="#%E5%BC%BA%E6%97%B6%E9%92%9F%E5%85%B3%E7%B3%BB-%E5%85%A8%E5%BA%8F%E5%85%B3%E7%B3%BB-ll">强时钟关系 全序关系 $\ll$</a></li>
</ul>
</li>
<li><a href="#%E5%90%91%E9%87%8F%E6%97%B6%E9%92%9F-vector-clock">向量时钟 vector clock</a></li>
<li><a href="#%E7%89%A9%E7%90%86%E6%97%B6%E9%92%9F%E5%90%8C%E6%AD%A5">物理时钟同步</a>
<ul>
<li><a href="#berkeley-%E7%AE%97%E6%B3%95-%E5%86%85%E9%83%A8%E5%90%8C%E6%AD%A5">Berkeley 算法 内部同步</a></li>
<li><a href="#lamport-and-melliarsmith-%E7%AE%97%E6%B3%95-%E5%86%85%E9%83%A8%E5%90%8C%E6%AD%A5">Lamport and Melliar–Smith 算法 内部同步</a></li>
<li><a href="#cristian-%E7%AE%97%E6%B3%95-%E5%A4%96%E9%83%A8%E5%90%8C%E6%AD%A5">Cristian 算法 外部同步</a></li>
<li><a href="#ntp-network-time-protocol-%E5%AE%9E%E7%8E%B0">NTP network time protocol 实现</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#ch-7-mutual-exclusion">ch 7 Mutual Exclusion</a>
<ul>
<li><a href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%96%B9%E6%A1%88">消息传递模型的方案</a>
<ul>
<li><a href="#lamport-%E6%96%B9%E6%A1%88">Lamport 方案</a></li>
<li><a href="#ricartagrawala-%E6%96%B9%E6%A1%88">Ricart–Agrawala 方案</a></li>
<li><a href="#maekawa-%E6%96%B9%E6%A1%88">Maekawa 方案</a></li>
</ul>
</li>
<li><a href="#token-passing-%E7%9A%84%E6%96%B9%E6%A1%88">token-passing 的方案</a>
<ul>
<li><a href="#suzukikasami-%E6%96%B9%E6%A1%88">Suzuki–Kasami 方案</a></li>
<li><a href="#raymond-%E6%96%B9%E6%A1%88">Raymond 方案</a></li>
</ul>
</li>
<li><a href="#%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8%E7%9A%84%E6%96%B9%E6%A1%88">共享存储的方案</a>
<ul>
<li><a href="#peterson-%E6%96%B9%E6%A1%88-%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%AD%90%E6%8C%87%E4%BB%A4">Peterson 方案 不使用原子指令</a></li>
<li><a href="#test-and-set-%E5%8E%9F%E5%AD%90%E6%8C%87%E4%BB%A4">test-and-set 原子指令</a></li>
<li><a href="#load-linked-%E5%92%8C-store-conditional-%E5%8E%9F%E5%AD%90%E6%8C%87%E4%BB%A4">load-linked 和 store-conditional 原子指令</a></li>
</ul>
</li>
<li><a href="#%E7%BB%84%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5">组同步互斥</a>
<ul>
<li><a href="#%E4%B8%AD%E5%BF%83%E5%8C%96%E6%96%B9%E6%A1%88">中心化方案</a></li>
<li><a href="#%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E6%96%B9%E6%A1%88">去中心化方案</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#ch-8-distributed-snapshot">ch 8 Distributed Snapshot</a>
<ul>
<li><a href="#chandy-lamport-%E7%AE%97%E6%B3%95">Chandy-Lamport 算法</a></li>
<li><a href="#lai-yang-%E7%AE%97%E6%B3%95">Lai-Yang 算法</a></li>
<li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F-debug">分布式 debug</a></li>
</ul>
</li>
<li><a href="#ch-9-global-state-collection">ch 9 Global State Collection</a>
<ul>
<li><a href="#%E5%85%A8%E5%B1%80%E5%B9%BF%E6%92%AD">全局广播</a></li>
<li><a href="#%E7%A8%8B%E5%BA%8F%E7%BB%88%E6%AD%A2%E6%A3%80%E6%B5%8B">程序终止检测</a>
<ul>
<li><a href="#dijstra-scholten-%E7%AE%97%E6%B3%95">Dijstra-Scholten 算法</a></li>
<li><a href="#%E5%8D%95%E5%90%91%E7%8E%AF%E7%9A%84-token-passing">单向环的 token passing</a></li>
<li><a href="#%E4%BF%A1%E7%94%A8%E7%82%B9%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95-credit-recovery-algorithm">信用点分配算法 credit-recovery algorithm</a></li>
</ul>
</li>
<li><a href="#%E6%B5%AA%E6%BD%AE-wave-%E7%AE%97%E6%B3%95">浪潮 wave 算法</a></li>
<li><a href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B">死锁检测</a>
<ul>
<li><a href="#resource-deadlock">resource deadlock</a></li>
<li><a href="#communication-deadlock">communication deadlock</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#ch-10-graph-algorithms">ch 10 Graph Algorithms</a>
<ul>
<li><a href="#%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95">路由算法</a>
<ul>
<li><a href="#ford-%E7%AE%97%E6%B3%95">Ford 算法</a></li>
<li><a href="#chandy-and-misra-%E6%94%B9%E8%BF%9B">Chandy and Misra 改进</a></li>
<li><a href="#%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F">距离向量</a></li>
<li><a href="#%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E7%AE%97%E6%B3%95">链路状态算法</a></li>
<li><a href="#%E9%97%B4%E9%9A%94%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95">间隔路由算法</a></li>
<li><a href="#%E5%89%8D%E7%BC%80%E8%B7%AF%E7%94%B1">前缀路由</a></li>
</ul>
</li>
<li><a href="#%E5%9B%BE%E9%81%8D%E5%8E%86">图遍历</a>
<ul>
<li><a href="#chang-%E7%94%9F%E6%88%90%E6%A0%91%E6%9E%84%E5%BB%BA">Chang 生成树构建</a></li>
<li><a href="#tarry-%E5%9B%BE%E9%81%8D%E5%8E%86">Tarry 图遍历</a></li>
<li><a href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91">最小生成树</a></li>
</ul>
</li>
<li><a href="#%E5%9B%BE%E6%9F%93%E8%89%B2">图染色</a>
<ul>
<li><a href="#d--1%E6%9F%93%E8%89%B2">(D + 1)染色</a></li>
<li><a href="#6-%E8%89%B2%E5%B9%B3%E9%9D%A2%E5%9B%BE">6 色平面图</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#ch-11-coordination-algorithms">ch 11 Coordination Algorithms</a></li>
<li><a href="#ch-12-fault-tolerant-systems">ch 12 Fault-Tolerant Systems</a></li>
<li><a href="#ch-13-distributed-consensus">ch 13 Distributed Consensus</a></li>
</ul>
</li>
</ul>
<h1 id="ghosh-sukumar-2014---distributed-systems-an-algorithmic-approach">Ghosh, Sukumar (2014) - Distributed Systems An Algorithmic Approach</h1>
<p>一本高屋建瓴讨论分布式里面重要问题的书。这篇笔记主要就是结合我的理解复述一下书里的我感觉比较重要内容的流水账。</p>
<h2 id="ch-1-introduction">Ch 1 introduction</h2>
<p>特征</p>
<ol>
<li>多进程</li>
<li>进程间通讯</li>
<li>分离地址空间</li>
<li>单任务</li>
</ol>
<p>使用分布式的原因</p>
<ul>
<li>地理分离</li>
<li>加速</li>
<li>远端资源共享</li>
<li>容错</li>
</ul>
<p>一般的问题</p>
<ol>
<li>leader 选举</li>
<li>互斥</li>
<li>时钟同步</li>
<li>全局状态</li>
<li>组播</li>
<li>副本管理</li>
</ol>
<h2 id="ch-2-interprocess-communication">Ch 2 interprocess communication</h2>
<h3 id="naming">naming</h3>
<p>位置无关，方便定位实体。一般是文本形式，树状结构</p>
<h3 id="rpc-remote-procedure-call">rpc remote procedure call</h3>
<ul>
<li>机器差异（大小端，指针和地址）</li>
<li>阻塞/非阻塞</li>
<li>丢包：at-least-once/at-most-once,exactly once</li>
</ul>
<table>
<thead>
<tr>
<th>Client Stub</th>
<th>Server Stub</th>
</tr>
</thead>
<tbody>
<tr>
<td>Pack parameters into a message，Send message to remote machine</td>
<td>Do no message → skip od ，Unpack the call parameters</td>
</tr>
<tr>
<td>Do no result → skip od*，Receive result and unpack it</td>
<td>Call the server procedure Receive result and unpack it Pack result into a message</td>
</tr>
<tr>
<td>Return to the client program</td>
<td>Send it to the client</td>
</tr>
</tbody>
</table>
<h3 id="cloud-computing">cloud computing</h3>
<ul>
<li>software-as-a-service, SaaS
<ul>
<li>Google doc，云盘等</li>
</ul>
</li>
<li>platform-as-a-service, PaaS
<ul>
<li>小程序 API（？</li>
</ul>
</li>
<li>infrastructure-as-a-service, IaaS
<ul>
<li>elastic computing cloud， EC2 云服务器</li>
</ul>
</li>
</ul>
<h4 id="mapreduce">MapReduce</h4>
<p>Map: 〈<em>key, value</em>〉→ list of 〈<em>key, value</em>〉</p>
<p>{This is the intermediate 〈key, value〉 pair}</p>
<p>Reduce: 〈<em>key, list of values</em>〉 → list of 〈<em>key, value</em>〉</p>
<h2 id="ch-3-models-for-communication">ch 3 Models for Communication</h2>
<blockquote>
<p>本书的可靠信道公理 channel</p>
<ol>
<li>所有发出消息都被接收方收到，所有收到消息都有发送者
<ul>
<li>对数据链路/传输层不适用，需要恢复</li>
</ul>
</li>
<li>每条信息都有一条任意，有限长，非零延迟
<ul>
<li>为了放宽对不同延迟的支持</li>
</ul>
</li>
<li>信道呈现 FIFO 特性
<ul>
<li>电报 datagram 网络乱序</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="shared-variable-共享变量">shared variable 共享变量</h3>
<blockquote>
<p>DSM</p>
<p>distribted shared memory，方便使用共享变量有关的编程工具</p>
</blockquote>
<ol>
<li>state reading/locally shared variable 读取自身和邻居状态，只能修改自己状态</li>
<li>link register 链路自带单读者单写者寄存器</li>
</ol>
<h4 id="linda">linda</h4>
<p>共享的 tuple space</p>
<table>
<thead>
<tr>
<th>原语</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>IN，INP</td>
<td>取出 tuple，分阻塞、非阻塞版本</td>
</tr>
<tr>
<td>OUT</td>
<td>放入 tuple</td>
</tr>
<tr>
<td>RD，RDP</td>
<td>读 tuple，类比 in 不删除。分阻塞、非阻塞版本</td>
</tr>
<tr>
<td>EVAL</td>
<td>创建新进程</td>
</tr>
</tbody>
</table>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/** main program**/</span>
</span></span><span class="line"><span class="cl"><span class="n">real_main</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span><span class="n">argv</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">argc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[];</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">nslave</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">hello</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">nslave</span> <span class="o">=</span> <span class="n">atoi</span> <span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nslave</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    	<span class="n">EVAL</span> <span class="p">(</span><span class="s">&#34;slave&#34;</span><span class="p">,</span> <span class="n">hello</span><span class="p">(</span><span class="n">j</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nslave</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    	<span class="n">IN</span><span class="p">(</span><span class="s">&#34;done&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Task completed.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cm">/** subroutine hello **/</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">hello</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Task from number %d.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">OUT</span><span class="p">(</span><span class="s">&#34;done&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="mobile-agent">mobile agent</h4>
<p>移动执行的代码</p>
<p>(I, P, B)</p>
<ul>
<li>I 标识符</li>
<li>P 对应代码</li>
<li>B 代码的变量</li>
</ul>
<h3 id="模型强弱">模型强弱</h3>
<p>强模型限制多，操作多；强模型模拟弱模型容易，反之可能困难</p>
<h4 id="resequencing-protocol-非-fifo-模拟-fifo">resequencing protocol, 非 FIFO 模拟 FIFO</h4>
<p>缓存再发送。可以优化为环形缓存编号</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain"><span class="line"><span class="cl">{Sender process P}
</span></span><span class="line"><span class="cl">var i : integer {initially 0}
</span></span><span class="line"><span class="cl">repeat
</span></span><span class="line"><span class="cl">    send m[i],i to Q;
</span></span><span class="line"><span class="cl">    i := i+1;
</span></span><span class="line"><span class="cl">forever
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{Receiver process Q}
</span></span><span class="line"><span class="cl">var k : integer {initially 0}
</span></span><span class="line"><span class="cl">buffer : buffer [0..∞] of message
</span></span><span class="line"><span class="cl">{initially for all k:buffer[k] = null}
</span></span><span class="line"><span class="cl">repeat{store}
</span></span><span class="line"><span class="cl">	receive m[i],i from P;
</span></span><span class="line"><span class="cl">    store m[i] into buffer[i];
</span></span><span class="line"><span class="cl">    {deliver}
</span></span><span class="line"><span class="cl">    while buffer[k] ≠ null do
</span></span><span class="line"><span class="cl">    begin
</span></span><span class="line"><span class="cl">        deliver the content of buffer [k];
</span></span><span class="line"><span class="cl">        buffer [k] := null; k := k+1;
</span></span><span class="line"><span class="cl">    end
</span></span><span class="line"><span class="cl">forever
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="共享变量模拟信息传递">共享变量模拟信息传递</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain"><span class="line"><span class="cl">shared var p, q: integer {initially p = q}
</span></span><span class="line"><span class="cl">buffer: array [0..max-1] of message
</span></span><span class="line"><span class="cl">{Sender process P}
</span></span><span class="line"><span class="cl">var s: array of messages sent by P, i : integer {initially 0}
</span></span><span class="line"><span class="cl">repeat
</span></span><span class="line"><span class="cl">	if p ≠ q − 1 mod max then
</span></span><span class="line"><span class="cl">    begin
</span></span><span class="line"><span class="cl">    	buffer[p] := s[i]; i := i + 1; p := p + 1 mod max
</span></span><span class="line"><span class="cl">    end
</span></span><span class="line"><span class="cl">forever
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{Receiver process Q}
</span></span><span class="line"><span class="cl">var r: array of messages received by Q, j : integer {initially 0}
</span></span><span class="line"><span class="cl">repeat
</span></span><span class="line"><span class="cl">    if q ≠ p mod max then
</span></span><span class="line"><span class="cl">    begin
</span></span><span class="line"><span class="cl">    	r[j] := buffer[q]; j := j + 1; q := q + 1 mod max
</span></span><span class="line"><span class="cl">    end
</span></span><span class="line"><span class="cl">forever
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="信息传递模拟共享变量">信息传递模拟共享变量</h4>
<p>下列实现错误：</p>
<ol>
<li>组播不 atmoic，atmoic 组播有代价</li>
<li>组播不一定遵循更新变量顺序</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain"><span class="line"><span class="cl">{Implementing shared memory by message passing: first attempt}
</span></span><span class="line"><span class="cl">{read X by process i}
</span></span><span class="line"><span class="cl">read x[i] x[i] := v
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{write X := v by process i}
</span></span><span class="line"><span class="cl">x[i] := v
</span></span><span class="line"><span class="cl">Multicast v to every other process j (j ≠ i) in the system;
</span></span><span class="line"><span class="cl">Process j (j ≠ i), after receiving the multicast, sets x[j] to v.
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="信道判空的不可能性">信道判空的不可能性</h4>
<p>如果进程<code>i,j</code>之间信道需要判空</p>
<ul>
<li>已知<code>i,j</code>之间最大时延 T，等待 T</li>
<li>未知最大时延，初始信道可以包含任意信息，无法判空（即使使用一个清零帧）</li>
</ul>
<h3 id="系统分类">系统分类</h3>
<ul>
<li>reactive：反应性，对请求响应</li>
<li>transformational：转移性，存在初态和末态</li>
<li>named：和处理器标识有关</li>
<li>anonymous：和处理器标识无关，即使标识改变可以继续运行，需要如随机数等机制打破对称性</li>
</ul>
<h3 id="复杂度计数">复杂度计数</h3>
<ul>
<li>空间复杂度：按 node 数目的增长要求的空间</li>
<li>时间复杂度
<ul>
<li>总步数</li>
<li>总轮次 round：最远端的执行一次是一轮</li>
</ul>
</li>
</ul>
<h2 id="ch-4-representing-distributed-algorithms">ch 4 Representing Distributed Algorithms</h2>
<blockquote>
<p>guard</p>
<p>断言，条件执行，如果多个断言判正确，由 scheduler 决定执行任意一个代码段，下面假定每个代码段原子执行</p>
</blockquote>
<p>程序终止条件</p>
<ol>
<li>每个进程终止，guard 全判<code>false</code></li>
<li>无消息还在传递</li>
</ol>
<p>类似如下的伪代码和对应的 Rust 实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain"><span class="line"><span class="cl">program uncertain;
</span></span><span class="line"><span class="cl">define x : integer;
</span></span><span class="line"><span class="cl">initially x = 0
</span></span><span class="line"><span class="cl">do
</span></span><span class="line"><span class="cl">  x &lt; 4 → x := x + 1
</span></span><span class="line"><span class="cl">  [] x = 3 → x := 0
</span></span><span class="line"><span class="cl">od
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">rand</span>::<span class="n">Rng</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">sync</span>::<span class="n">atomic</span>::<span class="p">{</span><span class="n">AtomicUsize</span><span class="p">,</span><span class="w"> </span><span class="n">Ordering</span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">static</span><span class="w"> </span><span class="n">CNT</span>: <span class="nc">AtomicUsize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AtomicUsize</span>::<span class="n">new</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="mi">10</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">CNT</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">Ordering</span>::<span class="n">Relaxed</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">the</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">the</span><span class="p">(</span><span class="n">i</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">CNT</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">Ordering</span>::<span class="n">Relaxed</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">(</span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">guess</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rand</span>::<span class="n">thread_rng</span><span class="p">().</span><span class="n">gen_range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">match</span><span class="w"> </span><span class="n">guess</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="mi">0</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">the</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">the</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">(</span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">the</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">(</span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;terminate in {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">CNT</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="公正性">公正性</h3>
<p>由于 guarded action 的选择依赖 scheduler （调度器） 决定，scheduler 需要考虑公平性</p>
<ul>
<li>无条件公平：每个代码段最终会进入调度队列，无论 guard 值</li>
<li>弱公平：只要代码段的 guard 变为并保持 <code>true</code>就最终会进入调度队列</li>
<li>强公平：只要代码段的 guard 能无限次经常变为<code>true</code>就最终会进入调度队列，弱公平能跑出的顺序，强公平一定能跑出，反之不一定</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain"><span class="line"><span class="cl">program test
</span></span><span class="line"><span class="cl">define
</span></span><span class="line"><span class="cl">x: integer {initial value undefined}
</span></span><span class="line"><span class="cl">do
</span></span><span class="line"><span class="cl">  true → x := 0
</span></span><span class="line"><span class="cl">  [] x = 0 → x := 1
</span></span><span class="line"><span class="cl">  [] x = 1 → x := 2
</span></span><span class="line"><span class="cl">od
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>不公平时可能只执行第 1 条</li>
<li>弱公平时只保证执行第 1、2 条（一直执行第 1 条会保证 x=0 从而执行 2，但 x=1 时可以只执行第 1 条而使得第 3 条永不满足）</li>
</ul>
<h3 id="scheduler">scheduler</h3>
<blockquote>
<p>central scheduler</p>
<p>又名 serial scheduler：原子的调度执行 guard 对应的代码段，简单，可以用 token 传递实现，拓展性差，并行度差，是分布式 scheduler 的退化情形</p>
<p>有关的 Theorem：</p>
<ol>
<li>算法在 central scheduler 下正确</li>
<li>已为<code>true</code> 的 guard 不会被其他代码段修改为<code>false</code></li>
</ol>
<p>=&gt;在 distributed scheduler 下正确</p>
</blockquote>
<h2 id="ch-5-program-correctness">ch 5 Program Correctness</h2>
<blockquote>
<p>安全 safety 条件</p>
<p>&ldquo;bad things never happen.&rdquo;</p>
</blockquote>
<p>如：</p>
<ul>
<li>同步互斥：至多一个进程在临界区</li>
<li>有限容量信道：$nC\le nP\le nC+B$</li>
<li>读写锁：$(nW\le 1 \wedge nR=0) \vee (nW=0\wedge nR\ge 0)$</li>
<li>无死锁：$Q\wedge GG$</li>
<li>部分正确性：如果不死锁，必得正确结果 $\neg GG\implies Q$</li>
</ul>
<blockquote>
<p>活跃 liveness 条件</p>
<p>&ldquo;good things eventually happen.&rdquo;</p>
</blockquote>
<p>如：</p>
<ul>
<li>进行：对于同步互斥问题，不死锁，不活锁（声明了临界区，最终总能获得机会）</li>
<li>公平性：有限时间后 schduler 总会调度</li>
<li>可达性：是否可以从初始状态 $S_0$ 到达状态 $S_k$</li>
<li>终止：部分正确+终止状态可达</li>
</ul>
<h3 id="断言推理-assertional-reasoning">断言推理 assertional reasoning</h3>
<p>用于证明安全性。构造不变式 $I$ 代表安全性条件（类似数学归纳法）</p>
<ol>
<li>初态不变式 $I$满足</li>
<li>假定前状态不变式 $I$满足，任何执行后不变式 $I$ 仍然满足</li>
</ol>
<h3 id="良基集-well-founeded-set">良基集 well-founeded set</h3>
<p>用于证明活跃性。一个映射（测量函数/变化函数 measured/variant function）从系统全局状态到一个 well-founed set $f:S\to WF$</p>
<blockquote>
<p>well-founded set</p>
<p>对于 $WF=\{w_1,w_2,&hellip;\}$ ，上面有个全序关系$\gg$</p>
<ol>
<li>不存在无穷比较链 $w_1\gg w_2 \gg &hellip;$</li>
<li>系统状态从 $s_1$ 到 $s_2$ ，有 $w_1=f(s_1),w_2=f(s_2) \implies w_1 \gg w_2$</li>
</ol>
</blockquote>
<p>一般 well-founed set 会选择非负整数集，0 就是终止状态，全序关系就是大于；也有选择 set 是一组元素，全序关系是字典顺序。</p>
<h3 id="时间逻辑-temporal-logic">时间逻辑 temporal logic</h3>
<ul>
<li>$\Box P$ 意思是 $P$ 永真</li>
<li>$\lozenge P$ 意思是 $P$ 最终会变为真</li>
</ul>
<p>有</p>
<ol>
<li>$\lozenge P=\neg \Box (\neg P)$：P 假不是一直不真的=P 假最终会不真</li>
<li>$\Box P\wedge \Box Q=\Box (P\wedge Q)$</li>
<li>$\Box P\vee \Box Q=\Box (P\vee Q)$</li>
<li>$\lozenge\Box P\implies \Box \lozenge P$：P 最终会一直真推出 P 会一直经常真（强公平蕴含弱公平）</li>
<li>$\lozenge P\wedge \lozenge Q=\lozenge (P\wedge Q)$</li>
<li>$\lozenge P\vee \lozenge Q=\lozenge (P\vee Q)$</li>
<li>$\lozenge P\vee Q\neq \lozenge (P\vee Q)$: <strong>注意：</strong> 如果 $Q=\neg P$，右边永真，左边可以为假</li>
</ol>
<h2 id="ch-6-time-in-a-distributed-system">ch 6 Time in a Distributed System</h2>
<h3 id="逻辑时钟">逻辑时钟</h3>
<h4 id="弱时钟条件-偏序关系-prec">弱时钟条件 偏序关系 $\prec$</h4>
<ol>
<li>同一进程里，a 在 b 后发生，$a\prec b$</li>
<li>两个进程通讯，i 进程的 a 发送，j 进程 b 接受，$a\prec b$</li>
<li>$(a\prec b)\wedge(b\prec c)\implies (a\prec c)$</li>
</ol>
<h4 id="弱时钟实现的逻辑时钟-logic-clock">弱时钟实现的逻辑时钟 logic clock</h4>
<ol>
<li>每个本地事件发生，$LC$ 递增 1</li>
<li>发送消息时附上当前 $LC$ 作为时间戳</li>
<li>接受到消息时 $LC=1+\max(local; LC, message; LC)$</li>
</ol>
<p>此时可以保证，但是反之不成立。逻辑时钟不能完全和因果关系互推，需要<a href="#%E5%90%91%E9%87%8F%E6%97%B6%E9%92%9F-vector-clock">向量时钟</a>。</p>
<p>$a\prec b\implies LC(a)&lt;LC(b)$</p>
<h4 id="强时钟关系-全序关系-ll">强时钟关系 全序关系 $\ll$</h4>
<p>$a\ll b$ 成立条件</p>
<ul>
<li>要么$LC(a)&lt;LC(b)$</li>
<li>要么不同进程，事件 a、b 对应进程 i、j，有 $LC(a)=LC(b),i&lt;j$</li>
</ul>
<h3 id="向量时钟-vector-clock">向量时钟 vector clock</h3>
<p>从事件集到进程数大小(假定为 n)的非负整数向量的函数 $VC:V\to A$。事件 a、b 的向量时钟之间大小关系$VC(a)&lt;VC(b)$的充要条件为</p>
<ol>
<li>$\forall i:i\in [0,n-1]:VC_i(a)\le VC_i(b)$</li>
<li>$\exists j\in[0,n-1]:VC_j(a)&lt;VC_j(b)$</li>
</ol>
<p>如果两个事件之间向量时钟既不大于也不小于，认为事件同时，记作$a\parallel b$。向量时钟保证了因果检测，即 $a\prec b \iff VC(a)&lt;VC(b)$ 。实现要求：</p>
<ol>
<li>进程 i 本地事件发生时候 $VC_i[i]+=1$</li>
<li>发送信息时附带整个向量时钟</li>
<li>进程 j 收到消息附带时间戳 $T$ 时，先更新本地 $VC_j[j]+=1$ ，再更新全局 $\forall k \in [0,n-1]:VC_k[j]=\max(T_k,VC_k[j])$</li>
</ol>
<h3 id="物理时钟同步">物理时钟同步</h3>
<ol>
<li>外部时钟同步：和 UTC/原子钟/GPS 同步时间。可以借助 NTP（network time protocol）协议</li>
<li>内部时钟同步：在即使内部少数错误时钟下仍然同步时间，只需要内部相互同步即可，注意一般通过调快/调慢实现以防止突变</li>
<li>相同步</li>
<li>有界时钟：只能通过加位数保证可预见未来不溢出</li>
</ol>
<ul>
<li>偏移率 drift rate：内部时钟和理想时钟走时速度不完全相等：$(1-\rho)\le \frac{\rm{d}C}{\rm{d}t}\le(1+\rho)$</li>
<li>时钟偏差 clock skew：时钟之间最大允许读数偏差 $\delta$</li>
<li>重同步间隔 resynchronization interval ：$R$</li>
</ul>
<h4 id="berkeley-算法-内部同步">Berkeley 算法 内部同步</h4>
<p>选择一个 leader 收集计算各个内部时钟的平均值，并按此调整</p>
<h4 id="lamport-and-melliarsmith-算法-内部同步">Lamport and Melliar–Smith 算法 内部同步</h4>
<p>去中心化的算法。可以应对 two-faced clock 问题。$c_k[i]$ 表示时钟 i 读取时钟 k 得到的值。</p>
<blockquote>
<p>two-faced clock</p>
<p>2 个非错时钟向 two-faced 时钟读数结果不一致</p>
</blockquote>
<ol>
<li>读系统中每个时钟的值</li>
<li>将离群值丢弃,用本地值代替： $|c_i[i]-c_j[i]|&gt;\delta \implies c_j[i]\gets c_i[i]$</li>
<li>使用处理后的平均值覆盖本地时钟值</li>
</ol>
<p>对于 n 个时钟，只要 two-faced clock 数目 t 有 $n&gt;3t$ 就能保证同步。</p>
<p>考虑 3 个时钟，i、j 好，k 为 two-faced clock。有如下配置</p>
<ul>
<li>$c_i[i]=c$</li>
<li>$c_j[j]=c-\delta$</li>
<li>$c_k[i]=c+\delta$</li>
<li>$c_k[j]=c-2\delta$</li>
</ul>
<p>这时候 i、j 平均值差为 $\frac{3t\delta}{n}$。如果 $n&gt;3t$ 就有$\frac{3t\delta}{n}&lt;\delta$。同步间隔 $R\le(\delta -\frac{3t\delta}{n})/\rho$</p>
<h4 id="cristian-算法-外部同步">Cristian 算法 外部同步</h4>
<p>每个 client 向有精确时钟的 time server 定时通信来同步时钟： $R&lt;\frac{\delta}{2\rho}$。</p>
<blockquote>
<p>round-trip time</p>
<p>每次同步通过发起 RPC，用来度量信号延迟：$RTT=T_2-T_1$</p>
</blockquote>
<p>每次时钟修正为 $T_s+\frac{RTT}{2}=T_s+\frac{T_2-T_1}{2}$。但实际网络波动，返回时间是一个区间，记最短用时 $min$，对应同步精度 $\pm(\frac{T_2-T_1}{2}-min)$</p>
<h4 id="ntp-network-time-protocol-实现">NTP network time protocol 实现</h4>
<p>按层级 stratum 组织各计算机，stratum 0 对应直连高精度时钟，stratum $i$ 作为 $i+1$ 的 time server，精度随着层级增加递减。</p>
<ul>
<li>组播：使用 UDP 协议定期发送</li>
<li>RPC：使用 <a href="#cristian-%E7%AE%97%E6%B3%95-%E5%A4%96%E9%83%A8%E5%90%8C%E6%AD%A5">Cristian 算法</a></li>
<li>P2P 通信：同层级的 time server 互相同步保持精度。设 Q 在 P 之前$\delta$，互相发报：$T_2=T_1+T_{PQ}+\delta,T_4=t_3+T_{QP}-\delta$，则有 $\delta=\frac{T_2-T_4-T_1+T_3}{2}-\frac{T_{PQ}-T_{QP}}{2},RTT=T_{PQ}+T_{QP}=T_2+T_4-T_1-T_3$， 这时候两个时钟误差$\delta$就可以控制在 $\frac{T_2-T_4-T_1+T_3}{2}\pm\frac{RTT}{2}$ 里面（注意到 $T_{PQ},T_{QP}&gt;0$，相减的值可以由 RTT 控制）</li>
</ul>
<h2 id="ch-7-mutual-exclusion">ch 7 Mutual Exclusion</h2>
<p>3 个基本要求</p>
<ol>
<li>同步互斥 Mutual exclusion：至多一个进程在临界区，这是安全性性质</li>
<li>不死锁 Freedom from deadlock：至少一个进程可以运行和进入临界区，也是安全性性质</li>
<li>进展 Progress：每个尝试进入临界区的进程最终总能进入，这是活跃性性质</li>
</ol>
<blockquote>
<p>livelock/starvation</p>
<p>违反性质 3。进程一直被阻止进入临界区</p>
</blockquote>
<blockquote>
<p>FIFO fairness，FIFO 公平</p>
<p>进入临界区的顺序按照申请的顺序，类似 FIFO 队列。注意是申请的时间而不是申请到达 central coordinator（如果采用中心化的算法）的时间，所以一般世俗机构的办事先到先得不是 FIFO fairness</p>
</blockquote>
<h3 id="消息传递模型的方案">消息传递模型的方案</h3>
<p>下面算法一般要求发送消息时间戳。注意到如果只考虑同步互斥问题，时间戳最大差 $(n-1)$，因此可以选择 $\mathrm{mod}(2n-1)$ 的时间戳，有效规避无界时钟问题（详见 <a href="#%E7%89%A9%E7%90%86%E6%97%B6%E9%92%9F%E5%90%8C%E6%AD%A5">物理时钟章节</a> ）。</p>
<h4 id="lamport-方案">Lamport 方案</h4>
<ul>
<li>全连接网络</li>
<li>信道 FIFO，不丢信息</li>
<li>每个进程维护一个队列 Q</li>
<li>3 特性+FIFO 公平，一轮需要 $3(n-1)$ 次消息传递</li>
</ul>
<ol>
<li>期望进入临界区的进程广播带时间戳<code>request</code></li>
<li>接受到<code>request</code>的进程
<ol>
<li>不在临界区：回复 <code>ack</code></li>
<li>在临界区：直到退出临界区再回复<code>ack</code></li>
</ol>
</li>
<li>进入临界区条件：
<ol>
<li>检查本地队列 Q 自己的请求最早</li>
<li>其他进程都回复了<code>ack</code></li>
</ol>
</li>
<li>退出临界区时：
<ol>
<li>删除本地队列 Q 中自己的请求</li>
<li>广播带时间戳<code>release</code></li>
</ol>
</li>
<li>收到<code>release</code>后进程删除对应的请求</li>
</ol>
<h4 id="ricartagrawala-方案">Ricart–Agrawala 方案</h4>
<ul>
<li>不需要维护本地队列</li>
<li>只是更多的缓存请求.对时间戳晚于自己的请求，当时不在临界区时：
<ul>
<li>Lamport 方案回复</li>
<li>Ricart–Agrawala 方案缓存</li>
</ul>
</li>
<li>3 特性+FIFO 公平，一轮需要 $2(n-1)$ 次消息传递</li>
</ul>
<ol>
<li>期望进入临界区的进程广播带时间戳<code>request</code></li>
<li>接受到<code>request</code>的进程回复 <code>ack</code> 条件，反之缓存请求
<ul>
<li>该进程不准备进入临界区</li>
<li>该进程期望进入的时间戳晚于对应的<code>request</code></li>
</ul>
</li>
<li>进入临界区条件其他进程都回复了<code>ack</code></li>
<li>退出临界区执行其他操作前，对等待的请求回复<code>ack</code></li>
</ol>
<h4 id="maekawa-方案">Maekawa 方案</h4>
<p>每个进程 i 属于单独的通信组 $S_i$。组内互相监督满足临界区，只要组的覆盖足够好，就可以减少通信支出。大概为 $3\sqrt{n}=O(\sqrt{n})$</p>
<ol>
<li>$\forall i,j\in [0,n-1],S_i\cap S_j\neq \varnothing$：保证全局覆盖</li>
<li>$i\in S_i$：自身也被监督</li>
<li>最好的，每个进程属于通信组的次数相同（有对称性）</li>
</ol>
<blockquote>
<p>global FIFO</p>
<p>每个进程严格按照发送时间戳接受消息：极难实现</p>
</blockquote>
<ul>
<li>global FIFO 成立时
<ol>
<li>期望进入临界区的进程对 $S_i$ 广播带时间戳<code>request</code></li>
<li>对时间戳最早的请求回复<code>ack</code>，锁住，其他请求排在队列中；如果进程在临界区里，退出时再进行</li>
<li>进入临界区条件：收到 $S_i$ 中每个进程的 <code>ack</code></li>
<li>退出临界区时对 $S_i$ 广播<code>release</code></li>
<li>接收到<code>release</code>后从队列剔除对应请求，解锁，重复<code>步骤2</code></li>
</ol>
</li>
<li>没有 global FIFO，可能会因为循环等 <code>ack</code> 导致死锁，需要添加放弃机制
<ol>
<li>期望进入临界区的进程对 $S_i$ 广播带时间戳<code>request</code></li>
<li>不在临界区时接受到请求：</li>
<li>未锁：对时间戳最早的请求回复<code>ack</code>，锁定</li>
<li>已锁，新请求的时间戳更晚：回复<code>failed</code></li>
<li>已锁，新请求的时间戳更早：排队请求，对之前锁定请求的发送方发<code>inquire</code>，可能会重排顺序</li>
<li>进入临界区条件：收到 $S_i$ 中每个进程的 <code>ack</code>
<ul>
<li>如果收到 <code>inquire</code> 还接受到了<code>failed</code>，对 $S_i$ 广播 <code>relinquish</code> 放弃排期自己的请求</li>
<li>如果只收到 <code>inquire</code> 可以忽略</li>
</ul>
</li>
<li>退出临界区时对 $S_i$ 广播<code>release</code></li>
<li>接收到<code>release</code>后从队列剔除对应请求，解锁，重复<code>步骤2</code></li>
<li>已锁，接受到<code>relinquish</code>，重排队列，对时间戳最早的发<code>ack</code></li>
</ol>
</li>
</ul>
<h3 id="token-passing-的方案">token-passing 的方案</h3>
<h4 id="suzukikasami-方案">Suzuki–Kasami 方案</h4>
<p>全连接网络。初始有个进程拥有 token。期望进入临界区的进程 $i$ 广播带序列号的消息 $(i,num)$。拿到 token 即允许进入临界区。每个进程有本地队列 Q 和本地向量</p>
<ul>
<li>$req[0,&hellip;,n-1]$ 记录对应进程最近请求序列号</li>
<li>$last[0,&hellip;,n-1]$ 记录对应进程进入临界区次数</li>
</ul>
<p>进程 $i$ 拿到 token 后</p>
<ol>
<li>$last[i]\gets num$</li>
<li>将满足 $1+last[k]=req[k]$ 的每个进程 k 加入本地队列 Q</li>
<li>执行临界区</li>
<li>取出 Q 第一项传递 token</li>
</ol>
<p>对应消息总数 $(n-1)+1$（发出 $n-1$，接收 1 条 token）</p>
<h4 id="raymond-方案">Raymond 方案</h4>
<p>关系组织成树。每个进程有一个本地队列。一般的，树之间节点距离就是通信开销 $O(\log{n})$</p>
<ol>
<li>节点拥有 token 时候为树的根，并可以进去临界区，反之将自己的请求加入自己本地队列</li>
<li>节点没有 token，本地队列非空时给父节点发送请求，除非已经发送并在等待</li>
<li>根节点结束临界区，收到请求时，给本地队列第一项的邻居传递 token，并改为指向该邻居，该邻居变成根节点</li>
<li>接受到 token 时候，向本地队列第一项的邻居继续传递，并删除对应的请求，改为指向该邻居，如果队列中还有请求，向新的父节点发送请求</li>
</ol>
<h3 id="共享存储的方案">共享存储的方案</h3>
<p>一般依靠原子指令：</p>
<ul>
<li>compare-and-swap (CAS)：比较预期值和内存变量，相等时候改为新传入的值，反之不修改，返回执行之后的内存变量值</li>
<li>fetch-and-add(FA)：原子加</li>
<li>semaphore 信号量：非负整数支持原子操作，可以对应资源个数
<ul>
<li>$P(s)\triangleq\{waituntil; s&gt;0\implies s-=1\}$：申请资源，取得后可用资源-1</li>
<li>$V(s)\triangleq\{s+=1\}$：释放资源，可用资源+1</li>
</ul>
</li>
</ul>
<h4 id="peterson-方案-不使用原子指令">Peterson 方案 不使用原子指令</h4>
<p>2 个进程版本</p>
<pre tabindex="0"><code>program peterson;
define flag[0], flag[1] shared Boolean;
turn: shared integer
initially flag[0] = false, flag[1] = false, turn = 0 or 1
{program for process 0}
do true→
    flag[0] := true;
    turn := 0;

    do (flag[1] ∧ turn = 0) → skip od//不需要原子语句，turn要么0要么1，不会死锁；如果是flag引起进入临界区，process 1已经执行完临界区了；如果是turn引起，process 1 会等待：保证互斥

    critical section;
    flag[0] := false;
    non-critical section codes
od
{program for process 1}
do  true →
    flag[1] := true;
    turn := 1;

    do (flag[0] ∧ turn = 1) → skip od;//不需要原子语句

    critical section;
    flag[1] := false;
    non-critical section codes
od
</code></pre><p>多进程拓展版本。跑 $n-1$ 轮，每轮留下一个（最后一个修改 $turn[j]$ 的），最后选出 1 个执行临界区。最高位执行完后，$flag$ 会置 0，剩下 flag 最高的会结束等待，然后按照 轮数递减执行临界区。</p>
<pre tabindex="0"><code>program Peterson n-process;
define flag, turn: array [0.. n − 1] of shared integer;
initially ∀k:flag[k] = 0, and turn = 0
{program for process i}
do true →
    j:=1;
    do j ≠ n − 1
        flag[i] := j;
        turn[j] := i;

        do ((∃k ≠ i: flag[k] ≥ j) ∧ turn[j] = i) → skip od;// （1：选出的执行完后递减执行）∧（每轮修改turn的留下，flag不动）

        j := j + 1;
    od;

    critical section;

    flag[i] := 0;

    non-critical section codes
od
</code></pre><h4 id="test-and-set-原子指令">test-and-set 原子指令</h4>
<p>特殊的原子指令，取得某<code>bool</code>变量值，然后将其置 <code>True/1</code></p>
<pre tabindex="0"><code>program Test-and-set (for any process);
define
    x: shared integer;
    r: integer (private);
initially
    x = 0, r = 1;
do true →

    do r ≠ 0 → TS(r, x) od;

    critical section;
    x := 0
od
</code></pre><h4 id="load-linked-和-store-conditional-原子指令">load-linked 和 store-conditional 原子指令</h4>
<ul>
<li>load-linked $LL(r,x)$：类似普通 load 功能 $r\gets x$，还会对 x 插装</li>
<li>store-conditional $SC(r,x)$：类似 store $x\gets r$，如果 SC 是在其他进程的 LL 后执行后没修改，r 返回成功，反之 x 的值不改变，r 返回失败。LL 和 SC 配合类似 test-and-set</li>
</ul>
<pre tabindex="0"><code>program mutex (for process i);
define x: shared integer; r: integer (private);
initially x = 0;
do true →
try:
    do r ≠ 0 → LL(r, x) od; //critical section is busy
    r = 1; SC(r, x);

    if r = 0 → goto try fi;// SC did not succeed

    critical section;
    x := 0;
    non-critical section codes;
od
</code></pre><h3 id="组同步互斥">组同步互斥</h3>
<p>进程可以属于不同的独立的 forum，按 forum 为单位占有资源 in session。这是单独同步互斥、读写锁等经典问题的推广化。</p>
<ol>
<li>同步互斥：同一时间最多 1 个 forum 在 in session</li>
<li>无死锁：任何时间最少一个进程可以有效行动</li>
<li>有界等待：有成员的 forum 在有界时间内能 in session</li>
<li>同步进入：只要 forum 在 in session，其他有意愿的进程都能加入</li>
</ol>
<h4 id="中心化方案">中心化方案</h4>
<ul>
<li>每个进程拥有一个 $flag\in\{F_i,\perp\}$，中心协调器按顺序读取 flag 信息，安排进入 forum 和 in session</li>
<li>为了防止一个 forum 一直有进入，指定一个 leader（一般是第一个进入的进程），当 leader 退出时 forum 结束 in session</li>
</ul>
<h4 id="去中心化方案">去中心化方案</h4>
<p>每个进程拥有一个 $flag=(state,op),state\in \{request, in\_cs, in\_forum, passive\},op\in\{F,F&rsquo;,\perp\}$。类似于 <a href="#peterson-%E6%96%B9%E6%A1%88">peterson 的 2 进程方案</a>。为了保证想要进入 forum 的都可以，而不是偶尔检查条件被 skip，可以选择第一个进入的为 leader，leader 保证申请的随后进入 forum</p>
<pre tabindex="0"><code>First attempt with two forums F and F′
define  flag: array[1..n − 1] of (state, op), turn ∈ {F, F′}
        state ∈ {request, in_cs, in_forum, passive}
        op ∈ {F, F′, ⊥}
{Program for process i trying to attend forum F}
do ∃j ≠ i: flag[j] = (in_cs, F′) →

    flag[i] := (request, F); //发送请求

    do turn ≠ F ∧ ¬(∀j ≠ i: flag[j].op ≠ F′) → skip od; // (1 F&#39;之前执行完)∧(2 没有要求进入F&#39;的)

    flag[i] := (in_cs, F);//准备进入 forum 的临界区
od;

attend forum F;

turn := F′;
flag[i] := (passive, ⊥)
</code></pre><h2 id="ch-8-distributed-snapshot">ch 8 Distributed Snapshot</h2>
<p>记录分布式系统的单个分布组分的状态信息，收集分散的状态信息在下一章 <a href="#ch-9-global-state-collection">global state collection</a> 介绍。非常有用：死锁检测、程序终止检测、系统回滚等。</p>
<blockquote>
<p>cut 切分</p>
<p>一组事件，而且每个进程至少有一个事件</p>
</blockquote>
<blockquote>
<p>consistent cut</p>
<p>cut，而且对于里面的事件，其因的事件也在 cut 当中： $(a\in C)\wedge(b\prec a)\implies b\in C$</p>
</blockquote>
<blockquote>
<p>consistent</p>
<p>对于一次运行（computation，run，behavior），$\forall a,b, a\prec b$，a 发生在 b 前，就称为 consistent 的，保证 consistent 下可以有多种可能的实际事件顺序，如，交换并行的两个事件执行顺序不会影响运行的 consistent 特性</p>
</blockquote>
<h3 id="chandy-lamport-算法">Chandy-Lamport 算法</h3>
<p>强连通图，信道 FIFO，有一个启动进程 initiator，发生一个 * 标志消息启动记录，每个进程有两种状态，<code>white</code>和<code>red</code>，初始为<code>white</code></p>
<ol>
<li>启动进程原子执行
<ol>
<li>变<code>red</code></li>
<li>记录本地状态</li>
<li>向所有对外信道广播*标志</li>
</ol>
</li>
<li>所有进程在<strong>第一次</strong>接受到*标志后，先做以下原子操作再执行其他任务
<ol>
<li>变<code>red</code></li>
<li>记录本地状态：发送事件和接收事件分别由发送进程和接收进程记录</li>
<li>向所有对外信道广播*标志</li>
</ol>
</li>
</ol>
<p>算法记录最后一次白色+第一次红色事件。由于<strong>白色事件不可能引发红色消息</strong>，实际记录下来的事件顺序必然保持因果关系。</p>
<ul>
<li>算法记录下来的 snapshot state 都是由初始状态可达的，但不保证每次运行都能跑出这个状态</li>
<li>每个对于初始状态可达的最终状态，对算法记录下的 snapshot state 也是可达的：这保证了回滚的正确性</li>
</ul>
<h3 id="lai-yang-算法">Lai-Yang 算法</h3>
<p>对 Chandy-Lamport 的改进，信道不需要 FIFO，消息也附加两种状态，<code>white</code>和<code>red</code>。是一种懒记录方法，主要期待借用已有的各种消息传递。对于程序终止检测（终止后不会再收发任务消息）等需要额外发控制消息。</p>
<ol>
<li>启动进程记录本地状态，任何外发消息为$(msg,red)$</li>
<li>任何进程第一次接受到$(msg,red)$时，先记录本地状态，再处理接收信息</li>
</ol>
<h3 id="分布式-debug">分布式 debug</h3>
<blockquote>
<p>本地状态 $s(i),s(j)$ 对应 consistent 的全局状态</p>
<p>如果本地状态 $s(i),s(j)$ 是由事件 $e_i,e_j$ 引发，那么逻辑时钟关系 $\forall k,VC_k(e_i)\sim VC_k(e_j)$</p>
</blockquote>
<p>对由初始状态可达的 consistent 的全局状态应用判断 $\phi$。这样的判断时间复杂度巨大，需要注意可拓展性：n 个进程每个 m 个可能行动 $O(m^n)$</p>
<ul>
<li>Possibly $\phi$：至少一个为真</li>
<li>Definetly $\phi$：永真 $definetly;\phi \implies possibly; \phi$</li>
<li>Never $\phi$：永假</li>
</ul>
<h2 id="ch-9-global-state-collection">ch 9 Global State Collection</h2>
<p>本章假定底层任务能表现出预期的性质（如检测终止算法中，底层任务确实能终止）</p>
<h3 id="全局广播">全局广播</h3>
<p>假设本地需要被收集的为 $s(i)$,最后每个进程都能收集到 $\forall i:V(i)={s(k):0\le k\le n-1}$。那 naive 的方法就是每次向邻居通知自己新知道的其他进程的信息，直到大家知道全了。消息复杂度：向每个邻居发，每次多一个：$O(n^2)$，全局 $O(n^3)$</p>
<pre tabindex="0"><code>program broadcast (for process i}
define Vi, Wi: set of values;
initially Vi = {s(i)}, Wi = Ø {and every channel is empty}
do Vi ≠ Wi      →   send Vi\Wi to every outgoing channel;
                    Wi:= Vi
[] ¬empty (k,i) →   receive X from channel (k,i);
                    Vi:= Vi ∪ X
od
</code></pre><ul>
<li>$empty(i,j)\implies W_i\subseteq V_j$：归纳法易证，注意到 $W_i^{r+1}=V_i^{r+1},V^{r+1}/W^r_i\subseteq V_j$</li>
<li>停止时候能保证 $\forall i:V(i)={s(k):0\le k\le n-1}$: 由上一条+停止条件 有 $\forall i,j:V_i\subseteq V_j$，显然</li>
<li>有界步终止：必然递增</li>
</ul>
<h3 id="程序终止检测">程序终止检测</h3>
<p>（不一定需要是全局终止，相同步时候也要检测某相结束以开启下一相）</p>
<h4 id="dijstra-scholten-算法">Dijstra-Scholten 算法</h4>
<blockquote>
<p>diffusing computation</p>
<p>由一个 initiator 开启，通知邻居逐步开始的计算</p>
</blockquote>
<ul>
<li>沿方向的消息为 <code>signal</code> ，反向消息为<code>ack</code></li>
<li>环境 environment 节点：只有向外边</li>
<li>内部 internal 节点：从环境节点可达</li>
<li>环境节点起始发<code>signal</code> 开始算法</li>
<li>任何节点第一次收到<code>signal</code> 的发送方为父节点，然后自己开始向邻居广播<code>signal</code></li>
<li>之后收到<code>signal</code> 立刻回复<code>ack</code>，自己邻居都回复了<code>ack</code>后向父节点回复<code>ack</code>，起始节点收完<code>ack</code>即算法结束</li>
<li>对于某条有向边，沿向<code>signal</code>和反向<code>ack</code>数值差为 deficit</li>
<li>对于某个节点：
<ul>
<li>$C$：入边的 deficit 和</li>
<li>$D$：出边的 deficit 和</li>
</ul>
</li>
</ul>
<p>在这样设定下，有如下 2 不变式：</p>
<ol>
<li>$(C\ge 0)\wedge(D\ge 0)$:deficit 定义可知</li>
<li>$(C&gt;0)\vee(D=0)$:（1 等待邻居子图完成）或者是（2 邻居都完成了，可以回复父节点了）</li>
</ol>
<p>注意上述不变式有 $(C&gt;1)\vee(C=1\wedge D=0)$，整个进程之间关系是一棵树。要求信道 FIFO（保证工作信息和检测信息之间正确顺序，防止虚假终止）。在大家确实停止后，消息复杂度 $O(|E|)$（每个信道来去各一次）</p>
<pre tabindex="0"><code>program detect {for an internal node i}
define  C, D : integer
        m: (signal, ack) {represents the type of message received}
        state: (active, passive)
initially C = 0, D = 0, parent(i) = i
do (m = signal) ∧ (C = 0)   → C := 1; state := active;
                                parent := sender
                                //开始准备向邻居广播
    [] m = ack                  → D := D − 1
    [] (C = 1 ∧ D = 0) ∧ (state = passive) → send ack to parent;
                                            C:= 0; parent(i) = i
                                 //节点可以返回初始状态了
    [](m = signal) ∧ (C = 1)    → send ack to the sender
                                // 对多余的signal直接回复ack
od
</code></pre><h4 id="单向环的-token-passing">单向环的 token passing</h4>
<ol>
<li>每个节点 <code>black,white</code>两个状态，初始<code>white</code></li>
<li>向 token 传递反向高的节点发消息后，变<code>black</code></li>
<li><code>white</code>节点传递 token 时颜色不变，<code>black</code>节点传递时染黑 token</li>
<li>节点传递完 token 后变回<code>white</code></li>
<li>initiator 能收发白色 token 即终止</li>
</ol>
<p>算法要求消息通信瞬时（新的消息要追上 token 速度）</p>
<pre tabindex="0"><code>program term {for process i &gt; 0，假定进程0为启动进程}
define  color, token: (black, white) {colors of process and token}
        state : (active, passive)
do  (token = white) ∧ (state ≠ passive)   → skip
    [](token = white) ∧ (state = passive) →
            if color(i) = black → color(i) := white; send a black token
            [] color(i) = white → send a white token
            fi
    [](token = black)   → send a black token
    []i sends a message to a higher numbered process → color(i) :=black
od
{for process 0}
send a white token;
do
(token ≠ white) → send a white token
od
//收回白token 结束
</code></pre><h4 id="信用点分配算法-credit-recovery-algorithm">信用点分配算法 credit-recovery algorithm</h4>
<ul>
<li>$\sum credit(i)=1$</li>
<li>对于活跃进程：$credit(i)&gt;0$</li>
<li>对于休眠进程：$credit(i)=0$</li>
</ul>
<ol>
<li>活跃进程发消息时，将自身$credit/2$ 随消息发出</li>
<li>休眠进程接到消息，转活跃，并对于自身$+=msg_{credit}$</li>
<li>活跃进程收到消息，可以：发回给启动进程，或者为了减少消息数目 保留加到自己的 $credit$</li>
</ol>
<h3 id="浪潮-wave-算法">浪潮 wave 算法</h3>
<blockquote>
<p>wave</p>
<p>一个启动进程某活动，引发邻居活动，进而邻居的邻居活动，此谓浪潮</p>
<ol>
<li>每个计算有界</li>
<li>每个计算至少包括一个确定性事件 decision event</li>
<li>一个确定性事件 decision event 在每个进程中一些事件的因果前</li>
</ol>
</blockquote>
<blockquote>
<p>PIF</p>
<p>Propagation of Information with Feedback，类似于 <a href="#dijstra-scholten-%E7%AE%97%E6%B3%95">Dijstra Scholten 算法</a>里的广播，但是此时返回是副本不是<code>ack</code></p>
</blockquote>
<pre tabindex="0"><code>program PIF {for the initiator node i}
define  count : integer
        N(i): set of neighbors of process i

send M to each neighbor; count := |N(i)|
do
    count ≠ 0 ∧ M received → count: = count − 1
od
{program for a non-initiator node j≠i}
if
    message M received → parent := sender
                        send M to each neighbor except parent;
                        count := |N(j)|;
    []count &gt; 0 ∧ M received → count: = count − 1
    []count = 0              → send M to parent
fi
</code></pre><h3 id="死锁检测">死锁检测</h3>
<h4 id="resource-deadlock">resource deadlock</h4>
<p>循环等待资源引发的死锁，特征是<code>AND</code></p>
<ol>
<li>资源访问同步互斥</li>
<li>持有资源并等待更多资源</li>
<li>资源调度非抢占</li>
<li>循环等待</li>
</ol>
<blockquote>
<p>$succ(i)$</p>
<p>进程 i 等待进程的集合</p>
</blockquote>
<blockquote>
<p>$probe(i,s,r)$</p>
<p>消息，i 启动，s 实际发送，r 接受</p>
</blockquote>
<blockquote>
<p>$depend[j,i]$</p>
<p>直到 j 释放资源，i 才能进展。那么容易知道，有：</p>
<ol>
<li>$depend[j,i]\implies j\in succ^m(i)$</li>
<li>$depend[k,j]\wedge depend[j,i]\implies depend[k,i]$</li>
</ol>
</blockquote>
<pre tabindex="0"><code>program resource deadlock {program for process k}
    define P() :  probe {has three fields initiator, sender, receiver}
    depend[k]: array [0..n−1] of boolean
initially ∀j: 0 ≤ j ≤ n−1, depend[k,j] = false
do
    P(i,s,k) received ∧ k is waiting ∧ (k ≠ i) ∧ ¬depend(k, i)→  ∀j ∈ succ(k): send P(i,k,j) to j;   depend(k,i) := true
    [] P(i,s,k) received ∧ k is waiting ∧ (k = i) →  process k is deadlocked
od
</code></pre><p>当且仅当启动算法的进程在 wait for graph 时候，死锁可以成功检测。</p>
<h4 id="communication-deadlock">communication deadlock</h4>
<p>消息传递模型中，彼此等待唤醒信息，特征是<code>OR</code>。</p>
<blockquote>
<p>dependent set, $depend(i)$</p>
<p>对于进程 i，接收到 $depend(i)$ 任意一个进程消息后将活跃</p>
</blockquote>
<p>在子集 S 中</p>
<ol>
<li>S 中所有进程都消极</li>
<li>$\forall i \in S, depend(i) \subseteq S$</li>
<li>S 中信道皆空</li>
</ol>
<ul>
<li>第一次接收到 probe 时候向外发送 probe</li>
<li>之后接收到 probe 后返回 ack</li>
<li>对外每个 probe 都收到 ack 后，对第一次的 parent 发送 ack</li>
<li>注意 $num_{deficit}=num_{probe}-num_{ack}$</li>
</ul>
<p>算法和 <a href="#dijstra-scholten-%E7%AE%97%E6%B3%95">Dijstra-Scholten 算法</a> 类似，证明也是类似。</p>
<pre tabindex="0"><code>program communication deadlock
    define  P () : probe {has three fields  initiator, sender, receiver}
            parent : process  ack : message
            D : integer
    {program for the initiator node i}
initially node i send P(i,i,j) to each j ∈ succ(i), parent = null, D = |succ(i)|
do
    P(i,s,i) → send ack to s;
    [] ack → D := D−1
    [] D = 0 → deadlock detected
od {program for a non-initiator node k}

initially D = 0, parent = k
do
    P(i,s,k) ∧ k is waiting ∧ (parent = k) → parent := s;    ∀j  ∈ succ(k): send (i,k,j) to j;   D := D + |succ(k)|
    []P(i,s,k) ∧ k is waiting ∧ (parent ≠ k) → send ack to s;
    []ack → D := D − 1
    []D = 0 ∧ k is waiting ∧ (parent ≠ k) →  se nd ack to parent; parent := k
od
</code></pre><h2 id="ch-10-graph-algorithms">ch 10 Graph Algorithms</h2>
<h3 id="路由算法">路由算法</h3>
<h4 id="ford-算法">Ford 算法</h4>
<p>注意，i-j-k 的最短路径中，i-j 本身也是最短路径</p>
<pre tabindex="0"><code>program Bellman-Ford shortest path
{program for process 0}
send (D(0)+ w(0,j),0) to each node in j ∈ N(0)
{program for process j &gt; 0, after receiving a message from process i}
do D(i) + w(i,j) &lt; D(j)→
    D(j):= D(i) + w(i,j);
    parent(j):= i;
    send the new D(j) to each node in N(j)\{i}
od
</code></pre><h4 id="chandy-and-misra-改进">Chandy and Misra 改进</h4>
<p>应对负边权，加入一个 <a href="#dijstra-scholten-%E7%AE%97%E6%B3%95">类似终止检测的方法</a></p>
<pre tabindex="0"><code>program Chandy-Misra shortest path
{program for process 0}
send (D(0)+ w(0,k),0) to each node in k ∈ N(0);
deficit:= |N(0)|;
do
    D(i)+ w(i,0)≥ D(0)→ send ack to sender i
    []deficit &gt; 0 ∧ ack → deficit:= deficit – 1
od;
{deficit = 0 signals termination}
{program for process j &gt; 0 after receiving a message from process i}
{initially ∀j:D(j) = ∞, deficit = 0}
do
    D(i)+ w(i,j)&lt; D(j)→
        if (deficit &gt; 0)∧(parent ≠ j)→ send ack to parent
        fi;
        D(j) := D(i)+ w(i, j);
        parent := i; {the sender becomes the new parent}
        send the new D(j) to each node in N(j){i};
        deficit := deficit +|N(j)|−1
    []D(i)+ w(i, j)≥ D(j)→ send ack to sender j
    []deficit &gt; 0 ∧ ack → deficit := deficit − 1
    [](deficit = 0) ∧ (parent ≠ j)→ send ack to parent; parent = j
od
</code></pre><h4 id="距离向量">距离向量</h4>
<p>每个节点的路由表为<code>(destination, next hop, distance)</code>,distance/距离向量初始为</p>
<p>$$
D(i,j)=\left\{
\begin{aligned}
&amp;0, i==j \\
&amp;1, j\in N(i)\\
&amp;\infty, j\notin N(i)\cup\{i\}
\end{aligned}
\right.
$$</p>
<p>之后反复更新。但这样更新，正确容易收敛到；如果断联，会每次距离递增 1 直至无穷</p>
<p>$$
\forall k\neq i:D(i,k)=min_j(w(i,j)+D(j,k))
$$</p>
<h4 id="链路状态算法">链路状态算法</h4>
<p>两阶段</p>
<ol>
<li>
<p>reliable flooding：周期广播本节点到邻接节点距离</p>
</li>
<li>
<p>独立计算网络拓扑</p>
</li>
<li>
<p>保证节点收到全部他者的 reliable flooding 带来的 link-state packets</p>
<ul>
<li>每个包带递增<code>seq</code>，丢弃重复包</li>
<li><code>seq</code>号需要位数足够，防止溢出</li>
</ul>
</li>
<li>
<p>故障处理</p>
<ul>
<li><code>time-to-live</code>字段，定期过期信息保证最新</li>
<li>TTL 还可以应对偶发的<code>seq</code>顺序问题（旧包过期，新的小<code>seq</code>包不会被丢）</li>
</ul>
</li>
</ol>
<pre tabindex="0"><code>program link state {for node i}
define
    L() : link state packet LSP
    seq : integerz
    local : array [0..n – 1] of LSP {local[k] is the LSP from node k}
    {initially, seq = 0, local[k] := (k, undefined for ∀k ≠i, 0)}
do
    neighborhood change detected →
        compute link state S;
        send L(i, S, seq) to k ∈ N(i);
        local[0] := (i, S, seq)
        seq := seq + 1
    [] L(j, S, seq) received →
        if(j = i) → discard L(j, S, seq)
            [](j≠i)∧(L.seq &gt; local[j].seq)→
            enter L(j, S, seq) into the local database;
            forward L(j, S, seq) to k∈N(i)\{sender}
            [](j≠i)∧(L.seq ≤ local[j].seq)→
            discard L(j, S, seq)
        fi
do
</code></pre><h4 id="间隔路由算法">间隔路由算法</h4>
<p>$$
interval[p, q)\equiv\left\{
\begin{aligned}
&amp;if\ p&lt;q:p,p+1 &hellip;q-2,q-1\\
&amp;if\ p\ge q:p,p+1 &hellip;n-2,n-1,0,1,&hellip;q-2,q-1
\end{aligned}
\right.
$$</p>
<p>按照$interval[p, q)$对应的端口发消息</p>
<ol>
<li>生成树根节点标号 0，先序遍历，每次递增 1</li>
<li>按照$L(i)+T(i)+1 \mod n$标记端口
<ol>
<li>$L(i)$为自身标号</li>
<li>$T(i)$为下面子树节点个数（除了自己）</li>
</ol>
</li>
</ol>
<p>可以推广用多个标签</p>
<h4 id="前缀路由">前缀路由</h4>
<p>为了网络结构的频繁变动设计（非常像 URL）。考虑一个字母表$\sigma={a,b,c,d&hellip;}$和空字符$\lambda: \forall x\in \sigma:\lambda\cdot x=x$</p>
<ol>
<li>根节点标签$\lambda$</li>
<li>子树根节点为$L$，子树的子节点的标签即为$L\cdot x,x\in \sigma$</li>
<li>到子节点的端口标子域名标签，到父节点标$\lambda$</li>
<li>如果节点$(u,v)$非树边，标节点全标签。如果 v 就是根节点，把 u 的父节点端口改成父节点标签（防止和 2 冲突，两个$\lambda$端口）</li>
</ol>
<pre tabindex="0"><code>program prefix routing
{Y = label of the current node, X = label of the destination}
if
    X = Y → deliver message locally
    [] X ≠ Y → forward message to the port labeled with the longest prefix of X
fi
</code></pre><h3 id="图遍历">图遍历</h3>
<h4 id="chang-生成树构建">Chang 生成树构建</h4>
<p>对外传染发<code>probe</code>信息，结束后向父节点发<code>echo</code></p>
<pre tabindex="0"><code>program Changs’s spanning tree
define probe, echo: messages, parent: process
initially ∀i&gt;0, parent(i)=i, parent(0)=undefined
{program of the initiator node 0}
send probe to each neighbor j ∈ N(0)
do
    number of echoes ≠ number of probes →
        echo received → echo:= echo + 1
        probe received → send echo to the sender
od
{program for node j&gt;0 , after receiving a probe}
first probe → parent:= sender; forward probe to non-parent
neighbors;
do
    number of echoes ≠ number of probes →
        echo received → echo:=echo+1
        probe received → send echo to the sender
od
send echo to parent; parent(i):= i
</code></pre><h4 id="tarry-图遍历">Tarry 图遍历</h4>
<ol>
<li>向其他邻居发 token</li>
<li>如果不行了，向父节点（第一次传来 token 的节点）传回 token</li>
</ol>
<p>一条边两次：$2\cdot|E|$</p>
<h4 id="最小生成树">最小生成树</h4>
<p>Prim 和 Kruskal</p>
<h3 id="图染色">图染色</h3>
<h4 id="d--1染色">(D + 1)染色</h4>
<p>定义$nc(i)={c(j):j\in N(i)}$，可选颜色范围 C，可能数目远大于最优</p>
<pre tabindex="0"><code>program (D + 1) coloring
define c(i): color {of process i}, b: color
{program for process i}
do
    ∃j ∈ N(i):c(i)= c(j) → c(i):= b:b ∈ {C\nc(i)}
od
</code></pre><p>如果图有向无环，借助前缀和后继，可以减少可选颜色数目</p>
<pre tabindex="0"><code>program dag coloring;
{program for node i}
initially ∀i : c(i)=0;
do
    ∃j ∈ succ(i):c(i)= c(j)→ c(i):= b:b ∈ {C\sc(i)}
od
</code></pre><h4 id="6-色平面图">6 色平面图</h4>
<ul>
<li>要求 coarse-grain atomicity，一个节点原子的检查和执行</li>
<li>将平面图转成度数小于 6 的有向无环图，然后用 <a href="#d--1%E6%9F%93%E8%89%B2">有向无环图方法</a></li>
<li>平面图至少一个节点度数$\le5$（欧拉定理）</li>
<li>每次剔除$\le5$的节点，剩余图还是平面图，因此可一直进行</li>
</ul>
<pre tabindex="0"><code>program undirected to dag;
initially all edges are undirected;
{program for each node i}
do
    number of undirected edges incident on node i ≤ 5 →
    make all undirected edges outgoing
od
</code></pre><pre tabindex="0"><code>program planar graph coloring;
{program for node i}
do {Layer A: dag generation actions}
    number of undirected edges incident on it ≤ 5 →
        make all undirected edges outgoing
        {Layer B: coloring actions}
    [](outdgree(i)≤ 5)∧(∃j ∈ succ(i):c(i)=c(j))→ c(i):= b:b ∈ {C\sc(i)}
od
</code></pre><h2 id="ch-11-coordination-algorithms">ch 11 Coordination Algorithms</h2>
<h2 id="ch-12-fault-tolerant-systems">ch 12 Fault-Tolerant Systems</h2>
<h2 id="ch-13-distributed-consensus">ch 13 Distributed Consensus</h2>
]]></content:encoded></item><item><title>笔记：Designing data-intensive applications(开始记录）</title><link>https://livypad.github.io/post/2022-08-31-ddia/</link><pubDate>Tue, 13 Sep 2022 00:10:00 +0800</pubDate><guid>https://livypad.github.io/post/2022-08-31-ddia/</guid><description>Designing data-intensive applications: the big ideas behind reliable, scalable, and maintainable systems Foundations of Data Systems Data Models SQL：关系型，key-value 对，关联程度一般 文档型：自包含文档，少关联 图数据库：数据大量关联 Storage and Retrival</description><content:encoded><![CDATA[<h1 id="designing-data-intensive-applications-the-big-ideas-behind-reliable-scalable-and-maintainable-systems">Designing data-intensive applications: the big ideas behind reliable, scalable, and maintainable systems</h1>
<h2 id="foundations-of-data-systems">Foundations of Data Systems</h2>
<h3 id="data-models">Data Models</h3>
<ul>
<li>SQL：关系型，key-value 对，关联程度一般</li>
<li>文档型：自包含文档，少关联</li>
<li>图数据库：数据大量关联</li>
</ul>
<h3 id="storage-and-retrival">Storage and Retrival</h3>
<ul>
<li>OLTP 数据存储系统
<ul>
<li>日志结构：追加
<ul>
<li>hash-map：key 对应数据文件当中的位置偏移，只要 key 表能装入内存
<ul>
<li>高性能读写</li>
<li>对大量 key 不友好</li>
<li>区间查询不友好</li>
</ul>
</li>
<li>SSTables：排序字符串表：按顺序合并存储 k-v
<ul>
<li>可以稀疏存储 key</li>
<li>内存维护表，大于表的写进磁盘文件，一个 log 用来数据恢复</li>
</ul>
</li>
</ul>
</li>
<li>原地更新
<ul>
<li>B-Tree：固定大小的段/页组合
<ul>
<li>页大小和底层磁盘契合</li>
<li>覆盖而不是追加</li>
<li>大于页大小时候分裂页</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>OLAP 数据分析系统
<ul>
<li>数据仓库：专门用于数据分析的数据库，是工作用数据库的副本，面向查询
<ul>
<li>事实表：记录事件事实的主表，大，列多</li>
<li>列存储：列太多，一行拆开，每列单独存</li>
<li>列压缩：<code>None</code>值可以被压缩</li>
<li>聚合：面对常见操作预处理</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="encoding">Encoding</h3>
<blockquote>
<p>向前兼容</p>
<p>旧版本可读新版本的数据，一般通过忽略实现</p>
</blockquote>
<blockquote>
<p>向后兼容</p>
<p>新版本可读旧版本数据</p>
</blockquote>
<ul>
<li>语言自带：性能、通用性差、安全问题（代码生成）</li>
<li>文本文件（XML，JSON，CSV）：大，各种数据格式支持弱</li>
<li>二进制编码：小，带有更好的兼容检查支持，自带类型，自带注释</li>
</ul>
<h3 id="dataflow">Dataflow</h3>
<ul>
<li>基于数据库：数据比代码长久，旧版本更新需要忽略新的项</li>
<li>基于服务（web 服务 和 RPC）
<ul>
<li>web 服务：通过 HTTP 向服务器公开的 API 调用服务</li>
<li>RPC：远程调用有网络自身带来新问题，大跨度有兼容性问题</li>
</ul>
</li>
<li>基于消息传递：加入一个消息代理/Actor</li>
</ul>
<h2 id="distributed-data">Distributed Data</h2>
<h3 id="replication">Replication</h3>
<ul>
<li>主从复制
<ul>
<li>分主节点（可读可写）和从节点（只读）</li>
<li>新节点建立：快照+基础上的变更 log</li>
<li>恢复：选举+重新配置</li>
<li>方法
<ul>
<li>基于语句：非确定性语句改为传结果（VM-FT）</li>
<li>基于预写日志 Write-ahead log (WAL)：磁盘字节改变的日志</li>
<li>基于行的逻辑日志：按照修改的逻辑</li>
<li>基于触发器：应用层控制</li>
</ul>
</li>
<li>复制滞后和一致性
<ul>
<li>写后读：个人能读到自己之前的写</li>
<li>单调读：多次读取的版本号不减</li>
<li>前缀一致读：读的顺序取绝于当时写的顺序</li>
</ul>
</li>
</ul>
</li>
<li>多主节点复制
<ul>
<li>场景：多中心、离线工作、协作编辑</li>
<li>需要解决/规避同时写冲突</li>
</ul>
</li>
<li>无主节点复制
<ul>
<li>失效节点修复：
<ul>
<li>读修复：检测到过期的值，适合频繁读取情形</li>
<li>反熵过程：不断检测差异并复制缺失数据，不保证顺序，可能严重滞后</li>
</ul>
</li>
<li>quorum 一致：
<ul>
<li>一次写入、读取需要确认的节点数目有要求，可以保证读到最新值 $w+r&gt;n$</li>
<li>由于：同时读写，回滚错误、宽松 quorum 等原因，该 quorum 一致性不是确定性保证</li>
<li>宽松 quorum：不满足条件时，先缓存等网络重连后继续写入</li>
</ul>
</li>
<li>检测并发写
<ul>
<li>每个 key 对应一个 version 号，每次写递增 version 号</li>
<li>读 key 时候返回所有未覆盖的值和 version 号，写之前必须读</li>
<li>写时必须包含之前读的 version 号，并手动 merge 读到的结果</li>
<li>可以覆盖低 version 号的结果，高版本不动</li>
<li>注意，删除需要特殊的 remove 标记（简单移除会被误认为未更新）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="partition">partition</h3>
<ul>
<li>$hash\mod N$，但是丧失顺序
<ul>
<li>不能避免攻击/单 key 高流量</li>
<li>单 key 加盐</li>
<li>对比 node 数目，多建分区防止 mod 抖动</li>
</ul>
</li>
<li>service discovery：找到划分所在 node
<ol>
<li>随机找一个节点，节点之间协调</li>
<li>路由表连接到节点</li>
<li>客户端知道划分，自己找到对应节点</li>
</ol>
</li>
</ul>
]]></content:encoded></item><item><title>笔记：Computer Network by Tanenbaum(大概第6章)</title><link>https://livypad.github.io/post/2022-08-31-netbytanebaum/</link><pubDate>Wed, 31 Aug 2022 00:18:17 +0800</pubDate><guid>https://livypad.github.io/post/2022-08-31-netbytanebaum/</guid><description>Computer Network by Tanenbaum ch1 term 分层 ch2 物理层 信道容量 介质 调制 ch3 数据链路层 frame 检错纠错 hamming protocol 乌托邦式的单工协议 简单的 停-等 协议，无错信道 简单的 停-等 协议，信道可能出错</description><content:encoded><![CDATA[<ul>
<li><a href="#computer-network-by-tanenbaum">Computer Network by Tanenbaum</a>
<ul>
<li><a href="#ch1">ch1</a>
<ul>
<li><a href="#term">term</a></li>
<li><a href="#%E5%88%86%E5%B1%82">分层</a></li>
</ul>
</li>
<li><a href="#ch2-%E7%89%A9%E7%90%86%E5%B1%82">ch2 物理层</a>
<ul>
<li><a href="#%E4%BF%A1%E9%81%93%E5%AE%B9%E9%87%8F">信道容量</a></li>
<li><a href="#%E4%BB%8B%E8%B4%A8">介质</a></li>
<li><a href="#%E8%B0%83%E5%88%B6">调制</a></li>
</ul>
</li>
<li><a href="#ch3-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82">ch3 数据链路层</a>
<ul>
<li><a href="#frame">frame</a></li>
<li><a href="#%E6%A3%80%E9%94%99%E7%BA%A0%E9%94%99">检错纠错</a>
<ul>
<li><a href="#hamming">hamming</a></li>
</ul>
</li>
<li><a href="#protocol">protocol</a>
<ul>
<li><a href="#%E4%B9%8C%E6%89%98%E9%82%A6%E5%BC%8F%E7%9A%84%E5%8D%95%E5%B7%A5%E5%8D%8F%E8%AE%AE">乌托邦式的单工协议</a></li>
<li><a href="#%E7%AE%80%E5%8D%95%E7%9A%84-%E5%81%9C-%E7%AD%89-%E5%8D%8F%E8%AE%AE%E6%97%A0%E9%94%99%E4%BF%A1%E9%81%93">简单的 停-等 协议，无错信道</a></li>
<li><a href="#%E7%AE%80%E5%8D%95%E7%9A%84-%E5%81%9C-%E7%AD%89-%E5%8D%8F%E8%AE%AE%E4%BF%A1%E9%81%93%E5%8F%AF%E8%83%BD%E5%87%BA%E9%94%99">简单的 停-等 协议，信道可能出错</a></li>
<li><a href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8D%8F%E8%AE%AE">滑动窗口协议</a>
<ul>
<li><a href="#1-%E4%BD%8D-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">1 位 滑动窗口</a></li>
<li><a href="#%E5%A4%9A%E4%BD%8D%E7%AA%97%E5%8F%A3">多位窗口</a></li>
<li><a href="#go-back-n-%E5%9B%9E%E9%80%80-n-%E5%8D%8F%E8%AE%AE">Go-Back-N 回退 N 协议</a></li>
<li><a href="#selective-repeat-%E9%80%89%E6%8B%A9%E9%87%8D%E4%BC%A0">selective repeat 选择重传</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#ch4-%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82">ch4 介质访问控制子层</a>
<ul>
<li><a href="#%E5%A4%9A%E8%B7%AF%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE">多路访问协议</a>
<ul>
<li><a href="#aloha">ALOHA</a></li>
<li><a href="#%E5%88%86%E6%A7%BD-aloha">分槽 ALOHA</a></li>
<li><a href="#csma">CSMA</a>
<ul>
<li><a href="#persistent%E7%AD%89%E5%88%B0%E5%8D%A0%E7%94%A8%E7%BB%93%E6%9D%9F%E7%9B%B4%E6%8E%A5%E5%BC%80%E5%A7%8B%E5%8F%91">Persistent：等到占用结束直接开始发</a></li>
<li><a href="#nonpersistent">Nonpersistent</a></li>
<li><a href="#p-persistent">p-persistent</a></li>
</ul>
</li>
<li><a href="#csmacd-collision-detection">CSMA/CD collision detection</a></li>
<li><a href="#csmaca-collision-avoidance">CSMA/CA collision avoidance</a></li>
<li><a href="#bit-map-%E4%BD%8D%E5%9B%BE%E5%8D%8F%E8%AE%AE-%E6%97%A0%E5%86%B2%E7%AA%81">Bit-Map 位图协议 无冲突</a></li>
<li><a href="#token-ring-%E4%BB%A4%E7%89%8C%E7%8E%AF-%E6%97%A0%E5%86%B2%E7%AA%81">token ring 令牌环 无冲突</a></li>
<li><a href="#binary-countdown-%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%AE%A1%E6%95%B0-%E6%97%A0%E5%86%B2%E7%AA%81">binary countdown 二进制计数 无冲突</a></li>
<li><a href="#the-adaptive-tree-walk-protocol-%E8%87%AA%E9%80%82%E5%BA%94%E6%A0%91%E9%81%8D%E5%8E%86%E5%8D%8F%E8%AE%AE">The Adaptive Tree Walk Protocol 自适应树遍历协议</a></li>
</ul>
</li>
<li><a href="#%E4%BB%A5%E5%A4%AA%E7%BD%91">以太网</a>
<ul>
<li><a href="#%E8%AE%BE%E6%96%BD">设施</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#ch5-%E7%BD%91%E7%BB%9C%E5%B1%82">ch5 网络层</a>
<ul>
<li><a href="#%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95">路由算法</a>
<ul>
<li><a href="#dijstra-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84">Dijstra 最短路径</a></li>
<li><a href="#flooding-%E6%B3%9B%E6%B4%AA">flooding 泛洪</a></li>
<li><a href="#distance-vector-routing-%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F%E8%B7%AF%E7%94%B1">distance vector routing 距离向量路由</a></li>
<li><a href="#link-state-routing-%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E8%B7%AF%E7%94%B1">link state routing 链路状态路由</a></li>
<li><a href="#%E5%B1%82%E6%AC%A1%E8%B7%AF%E7%94%B1">层次路由</a></li>
<li><a href="#%E5%B9%BF%E6%92%AD%E8%B7%AF%E7%94%B1">广播路由</a></li>
</ul>
</li>
<li><a href="#%E7%BB%84%E6%92%AD%E8%B7%AF%E7%94%B1">组播路由</a>
<ul>
<li><a href="#anycast-routing-%E9%80%89%E6%92%AD%E8%B7%AF%E7%94%B1">anycast routing 选播路由</a></li>
</ul>
</li>
<li><a href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95">拥塞控制算法</a>
<ul>
<li><a href="#traffic-aware-routing">Traffic-Aware Routing</a></li>
<li><a href="#admission-control">admission control</a></li>
<li><a href="#load-shedding">load shedding</a></li>
<li><a href="#traffic-shaping">traffic shaping</a></li>
<li><a href="#active-queue-management-%E4%B8%BB%E5%8A%A8%E9%98%9F%E5%88%97%E7%AE%A1%E7%90%86">active queue management 主动队列管理</a></li>
<li><a href="#random-early-detection-%E9%9A%8F%E6%9C%BA%E6%97%A9%E6%9C%9F%E6%A3%80%E6%B5%8B">Random Early Detection 随机早期检测</a></li>
<li><a href="#choke-packets">choke packets</a></li>
<li><a href="#explicit-congestion-notification-%E6%98%BE%E5%BC%8F%E6%8B%A5%E5%A1%9E%E9%80%9A%E7%9F%A5">Explicit Congestion Notification 显式拥塞通知</a></li>
<li><a href="#hop-by-hop-backpressure">Hop-by-Hop Backpressure</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#ch6-%E4%BC%A0%E8%BE%93%E5%B1%82">ch6 传输层</a>
<ul>
<li><a href="#socket">Socket</a>
<ul>
<li><a href="#%E5%8E%9F%E8%AF%AD">原语</a></li>
<li><a href="#%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E7%A8%8B%E5%BA%8F">文件传输程序</a>
<ul>
<li><a href="#%E5%AE%A2%E6%88%B7%E7%AB%AF">客户端</a></li>
<li><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF">服务器端</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="computer-network-by-tanenbaum">Computer Network by Tanenbaum</h1>
<h2 id="ch1">ch1</h2>
<h3 id="term">term</h3>
<blockquote>
<p>broadcast</p>
<p>广播</p>
</blockquote>
<blockquote>
<p>point-to-point link</p>
<p>单播</p>
</blockquote>
<blockquote>
<p>multicasting</p>
<p>组播：只对一部分用户发送</p>
</blockquote>
<h3 id="分层">分层</h3>
<ul>
<li>physical layer
<ul>
<li>物理层。传输 raw bit</li>
</ul>
</li>
<li>data link layer
<ul>
<li>数据链路层。传输数据帧</li>
<li>为了控制通路，有时需要 介质控制子层 medium access control layer</li>
</ul>
</li>
<li>network layer
<ul>
<li>网络层。路由，包收发</li>
</ul>
</li>
<li>transport layer
<ul>
<li>传输层。主要负责向两个主机中进程之间的通信提供服务。TCP 协议</li>
</ul>
</li>
<li>application layer
<ul>
<li>应用层。HTTP，DNS</li>
</ul>
</li>
</ul>
<h2 id="ch2-物理层">ch2 物理层</h2>
<blockquote>
<p>SNR</p>
<p>Signal-to-Noise Ratio，信噪比，dB（分贝）单位（$10\log_{10}S/N$）</p>
</blockquote>
<h3 id="信道容量">信道容量</h3>
<p>$$\text{maximum data rate} = 2B \log_2 V \rm{bits/sec}$$</p>
<p>$$\text{maximum number of bits/sec} = B \log_2(1 + S/N)$$</p>
<h3 id="介质">介质</h3>
<ol>
<li>双绞线，几公里级，电话线，cat567</li>
<li>同轴电缆，Cu 制</li>
<li>光纤，带宽高，损失少</li>
<li>无线通信
<ol>
<li>一般使用单一窄频段( $\Delta f/f\ll 1$ )</li>
<li>跳频 frequency hopping spread spectrum</li>
<li>CDMA 码分多址，Code Division Multiple Access</li>
<li>FDM 频分复用，Frequency Division Multiplexing ^67f4ec</li>
<li>TDM 时分复用，Time Division Multiplexing</li>
<li>UWB 超宽频谱，Ultra-WideBand</li>
<li>RF
<ul>
<li>低频高 path loss， $1/r^2$ 损失，地波 VLF，LF，MF</li>
<li>高频直线，损失少，电离层反射 HF，VHF</li>
</ul>
</li>
</ol>
</li>
</ol>
<p><img loading="lazy" src="/assets/img/note/net/freq.png" alt="freq"  />
</p>
<p><img loading="lazy" src="/assets/img/note/net/tech.png" alt="tech"  />
</p>
<h3 id="调制">调制</h3>
<p><img loading="lazy" src="/assets/img/note/net/modulation.png" alt="modulation"  />
</p>
<h2 id="ch3-数据链路层">ch3 数据链路层</h2>
<ol>
<li>为网络层提供接口</li>
<li>检错纠错</li>
<li>调节数据流量，防止堵塞</li>
</ol>
<p>在 数据链路层 完成检错、确认等比起在网络层，更快速，更加底层。</p>
<h3 id="frame">frame</h3>
<p>从原始 bit 区分 frame。一般使用字符计数法和一种其它方法的组合</p>
<ol>
<li>bit 计数，若出错，对帧的影响较大</li>
<li>flag byte，填充 byte</li>
<li>flag bit，填充 bit</li>
<li>直接违反物理层编码，只适用于物理层编码有冗余的网络</li>
</ol>
<h3 id="检错纠错">检错纠错</h3>
<p>$(n,m)$ 码，当中 $n=m+r$</p>
<ol>
<li>hamming</li>
<li>二进制卷积</li>
<li>solmen Reed</li>
<li>低密度奇偶校验</li>
</ol>
<ul>
<li>奇偶</li>
<li>校验和</li>
<li>CRC</li>
</ul>
<h4 id="hamming">hamming</h4>
<blockquote>
<p>Hamming distance</p>
<p>海明距离，两个码字之间不同的对应比特位数目</p>
</blockquote>
<p>为了检查出 $d$ 个 bit 错，可以使用海明距离为 $d+1$ 的编码；为了纠正 $d$ 个错，可以使用海明距离为 $2d+1$ 的编码</p>
<p>对 $2^m$ 个有效信息(信息位数为 $m$ )中任何一个，有 $n=m+r$ 个与其距离为 1 的无效码字（n 位每位都可能出错），因此，每个 $2^m$ 中的合法消息需要 $n+1$ 个位模式来标识它们。有 $(n+1)2^m\le2^n$ ，或者是</p>
<p>$$(m+r+1)\le2^r$$</p>
<p>给定 $m$ ，利用该式可以得出校正单比特误码的校验位数目的下界。可采用 k 个码字组成 $k\times n$ 矩阵，按列发送，接收方恢复成 $k\times n$ 矩阵。$kr$个校验位， $km$ 个数据位，可纠正最多为 k 个的突发性连续比特错</p>
<h3 id="protocol">protocol</h3>
<ul>
<li>传输层协议 TCP 也提供可靠传输服务</li>
<li>链路层的可靠传输服务通常用于高误码率的连路上，如无线链路</li>
<li>对于误码率低的链路，链路层协议可以不实现可靠传输功能</li>
</ul>
<p><img loading="lazy" src="/assets/img/note/net/layer.png" alt="layer"  />
</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#define MAX_PKT 1024 </span><span class="cm">/* determines packet size in bytes */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span><span class="nb">false</span><span class="p">,</span> <span class="nb">true</span><span class="p">}</span> <span class="n">boolean</span><span class="p">;</span><span class="cm">/* boolean type */</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">seq_nr</span><span class="p">;</span><span class="cm">/* sequence or ack numbers */</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="n">MAX_PKT</span><span class="p">];}</span> <span class="n">packet</span><span class="p">;</span><span class="cm">/* packet definition */</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span><span class="n">data</span><span class="p">,</span> <span class="n">ack</span><span class="p">,</span> <span class="n">nak</span><span class="p">}</span> <span class="n">frame_kind</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* frame kind definition */</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* frames are transported in this layer */</span>
</span></span><span class="line"><span class="cl">    <span class="n">frame_kind</span> <span class="n">kind</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* what kind of frame is it? */</span>
</span></span><span class="line"><span class="cl">    <span class="n">seq_nr</span> <span class="n">seq</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* sequence number */</span>
</span></span><span class="line"><span class="cl">    <span class="n">seq_nr</span> <span class="n">ack</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* acknowledgement number */</span>
</span></span><span class="line"><span class="cl">    <span class="n">packet</span> <span class="n">info</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* the network layer packet */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">frame</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* Wait for an event to happen; return its type in event. */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">wait_for_event</span><span class="p">(</span><span class="n">event_type</span> <span class="o">*</span><span class="n">event</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* Fetch a packet from the network layer for transmission on the channel. */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">from_network_layer</span><span class="p">(</span><span class="n">packet</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* Deliver information from an inbound frame to the network layer. */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">to_network_layer</span><span class="p">(</span><span class="n">packet</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* Go get an inbound frame from the physical layer and copy it to r. */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">from_physical_layer</span><span class="p">(</span><span class="n">frame</span> <span class="o">*</span><span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* Pass the frame to the physical layer for transmission. */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">to_physical_layer</span><span class="p">(</span><span class="n">frame</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* Start the clock running and enable the timeout event. */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">start_timer</span><span class="p">(</span><span class="n">seq_nr</span> <span class="n">k</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* Stop the clock and disable the timeout event. */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">stop_timer</span><span class="p">(</span><span class="n">seq_nr</span> <span class="n">k</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* Start an auxiliary timer and enable the ack_timeout event. */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">start_ack_timer</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* Stop the auxiliary timer and disable the ack_timeout event. */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">stop_ack_timer</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* Allow the network layer to cause a network layer ready event. */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">enable_network_layer</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* Forbid the network layer from causing a network layer ready event. */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">disable_network_layer</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* Macro inc is expanded in-line: increment k circularly. */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define inc(k) if (k &lt; MAX_SEQ) k = k + 1; else k = 0
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>1 帧包含 4 个字段：</p>
<ol>
<li>kind：种类：控制信息帧还是数据帧</li>
<li>seq：帧序号</li>
<li>ack：回应</li>
<li>info：数据</li>
</ol>
<h4 id="乌托邦式的单工协议">乌托邦式的单工协议</h4>
<p>单边发送，单边接收。发送方和接收方的网络层总是处于准备就绪状态。数据处理的时间忽略不计。可用的缓存空间无穷大。最强的一个条件是数据链路层之间的通信信道永远不会损坏帧或者丢失帧。</p>
<ul>
<li>不进行流量控制</li>
<li>不检错纠错</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/* Protocol 1 (Utopia) provides for data transmission in one direction only, from
</span></span></span><span class="line"><span class="cl"><span class="cm">sender to receiver. The communication channel is assumed to be error free
</span></span></span><span class="line"><span class="cl"><span class="cm">and the receiver is assumed to be able to process all the input infinitely quickly.
</span></span></span><span class="line"><span class="cl"><span class="cm">Consequently, the sender just sits in a loop pumping data out onto the line as
</span></span></span><span class="line"><span class="cl"><span class="cm">fast as it can. */</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span><span class="n">frame_arrival</span><span class="p">}</span> <span class="n">event_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;protocol.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">sender1</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">frame</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* buffer for an outbound frame */</span>
</span></span><span class="line"><span class="cl">    <span class="n">packet</span> <span class="n">buffer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* buffer for an outbound packet */</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">from_network_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* go get something to send */</span>
</span></span><span class="line"><span class="cl">        <span class="n">s</span><span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* copy it into s for transmission */</span>
</span></span><span class="line"><span class="cl">        <span class="n">to_physical_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* send it on its way */</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* Tomorrow, and tomorrow, and tomorrow,
</span></span></span><span class="line"><span class="cl"><span class="cm">    Creeps in this petty pace from day to day
</span></span></span><span class="line"><span class="cl"><span class="cm">    To the last syllable of recorded time.
</span></span></span><span class="line"><span class="cl"><span class="cm">    – Macbeth, V, v */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">receiver1</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">frame</span> <span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">event_type</span> <span class="n">event</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* filled in by wait, but not used here */</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">wait_for_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* only possibility is frame_arrival */</span>
</span></span><span class="line"><span class="cl">        <span class="n">from_physical_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* go get the inbound frame */</span>
</span></span><span class="line"><span class="cl">        <span class="n">to_network_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="p">.</span><span class="n">info</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* pass the data to the network layer */</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="简单的-停-等-协议无错信道">简单的 停-等 协议，无错信道</h4>
<blockquote>
<p>stop-and-wait</p>
<p>发送方在接收方确认接受前，都等待的协议，用于流量控制</p>
</blockquote>
<p>双方交替发 frame，每个 frame 中含有上个 frame 的确认信息</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/* Protocol 2 (Stop-and-wait) also provides for a one-directional flow of data from
</span></span></span><span class="line"><span class="cl"><span class="cm">sender to receiver. The communication channel is once again assumed to be error
</span></span></span><span class="line"><span class="cl"><span class="cm">free, as in protocol 1. However, this time the receiver has only a finite buffer
</span></span></span><span class="line"><span class="cl"><span class="cm">capacity and a finite processing speed, so the protocol must explicitly prevent
</span></span></span><span class="line"><span class="cl"><span class="cm">the sender from flooding the receiver with data faster than it can be handled. */</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span><span class="n">frame_arrival</span><span class="p">}</span> <span class="n">event_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;protocol.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">void</span> <span class="nf">sender2</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">frame</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* buffer for an outbound frame */</span>
</span></span><span class="line"><span class="cl">    <span class="n">packet</span> <span class="n">buffer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* buffer for an outbound packet */</span>
</span></span><span class="line"><span class="cl">    <span class="n">event_type</span> <span class="n">event</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* frame_arrival is the only possibility */</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">from_network_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* go get something to send */</span>
</span></span><span class="line"><span class="cl">        <span class="n">s</span><span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* copy it into s for transmission */</span>
</span></span><span class="line"><span class="cl">        <span class="n">to_physical_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* bye-bye little frame */</span>
</span></span><span class="line"><span class="cl">        <span class="n">wait_for_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* do not proceed until given the go ahead */</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">receiver2</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">frame</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* buffers for frames */</span>
</span></span><span class="line"><span class="cl">    <span class="n">event_type</span> <span class="n">event</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* frame_arrival is the only possibility */</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">wait_for_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* only possibility is frame_arrival */</span>
</span></span><span class="line"><span class="cl">        <span class="n">from_physical_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* go get the inbound frame */</span>
</span></span><span class="line"><span class="cl">        <span class="n">to_network_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="p">.</span><span class="n">info</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* pass the data to the network layer */</span>
</span></span><span class="line"><span class="cl">        <span class="n">to_physical_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* send a dummy frame to awaken sender */</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="简单的-停-等-协议信道可能出错">简单的 停-等 协议，信道可能出错</h4>
<ul>
<li>需要加入计时器，防止 frame 丢失</li>
<li>需要标记帧号码，防止重复接收</li>
</ul>
<p>考虑 $m$ 帧和 $m+1$ 帧。如果 $m$ 帧没有发送成功，接收方不会确认；如果发送成功，接收方就会发确认消息。所以下一次发送方要么重发 $m$ 帧，要么接收到正确的确认消息，发 $m+1$ 帧。所以每次只需要区分 2 帧，帧号码只需要 1 位（单 bit）</p>
<blockquote>
<p>PAR (Positive</p>
<p>Positive Acknowledgement with Retransmission,带有重传的肯定确认</p>
</blockquote>
<blockquote>
<p>ARQ</p>
<p>Automatic Repeat reQuest,自动重复请求</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/* Protocol 3 (PAR) allows unidirectional data flow over an unreliable channel. */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define MAX_SEQ 1
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="cm">/* must be 1 for protocol 3 */</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span><span class="n">frame_arrival</span><span class="p">,</span> <span class="n">cksum_err</span><span class="p">,</span> <span class="n">timeout</span><span class="p">}</span> <span class="n">event_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;protocol.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">void</span> <span class="nf">sender3</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">seq_nr</span> <span class="n">next_frame_to_send</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* seq number of next outgoing frame */</span>
</span></span><span class="line"><span class="cl">    <span class="n">frame</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* scratch variable */</span>
</span></span><span class="line"><span class="cl">    <span class="n">packet</span> <span class="n">buffer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* buffer for an outbound packet */</span>
</span></span><span class="line"><span class="cl">    <span class="n">event_type</span> <span class="n">event</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">next_frame_to_send</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* initialize outbound sequence numbers */</span>
</span></span><span class="line"><span class="cl">    <span class="n">from_network_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* fetch first packet */</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">s</span><span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* construct a frame for transmission */</span>
</span></span><span class="line"><span class="cl">        <span class="n">s</span><span class="p">.</span><span class="n">seq</span> <span class="o">=</span> <span class="n">next_frame_to_send</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* insert sequence number in frame */</span>
</span></span><span class="line"><span class="cl">        <span class="n">to_physical_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* send it on its way */</span>
</span></span><span class="line"><span class="cl">        <span class="n">start_timer</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">seq</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* if answer takes too long, time out */</span>
</span></span><span class="line"><span class="cl">        <span class="n">wait_for_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* frame_arrival, cksum_err, timeout */</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">==</span> <span class="n">frame_arrival</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">from_physical_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* get the acknowledgement */</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">ack</span> <span class="o">==</span> <span class="n">next_frame_to_send</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">stop_timer</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">ack</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* turn the timer off */</span>
</span></span><span class="line"><span class="cl">                <span class="n">from_network_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* get the next one to send */</span>
</span></span><span class="line"><span class="cl">                <span class="n">inc</span><span class="p">(</span><span class="n">next_frame_to_send</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* invert next_frame_to_send */</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">receiver3</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">seq_nr</span> <span class="n">frame_expected</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">frame</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">event_type</span> <span class="n">event</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">frame_expected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">wait_for_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* possibilities: frame_arrival, cksum_err */</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">==</span> <span class="n">frame_arrival</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* a valid frame has arrived */</span>
</span></span><span class="line"><span class="cl">            <span class="n">from_physical_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* go get the newly arrived frame */</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">seq</span> <span class="o">==</span> <span class="n">frame_expected</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* this is what we have been waiting for */</span>
</span></span><span class="line"><span class="cl">                <span class="n">to_network_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="p">.</span><span class="n">info</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* pass the data to the network layer */</span>
</span></span><span class="line"><span class="cl">                <span class="n">inc</span><span class="p">(</span><span class="n">frame_expected</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* next time expect the other sequence nr */</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">s</span><span class="p">.</span><span class="n">ack</span> <span class="o">=</span> <span class="mi">1</span> <span class="err">−</span> <span class="n">frame_expected</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* tell which frame is being acked */</span>
</span></span><span class="line"><span class="cl">            <span class="n">to_physical_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* send acknowledgement */</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="滑动窗口协议">滑动窗口协议</h4>
<p>双工，而不是使用两个单工协议。</p>
<blockquote>
<p>piggybacking</p>
<p>捎带确认，不单独发送确认帧，而是把确认信息放在下一数据帧当中</p>
</blockquote>
<p>使用 sending window 和 receiving window。窗口数目对应帧所需缓存区大小</p>
<ul>
<li>sending window
<ul>
<li>窗口中保存需要发送的帧</li>
<li>新到的帧窗口扩张</li>
<li>收到确认后，窗口缩小</li>
</ul>
</li>
<li>receiving window
<ul>
<li>只接受窗口内序号的帧</li>
</ul>
</li>
</ul>
<p><img loading="lazy" src="/assets/img/note/net/slidingwin.png" alt="sliding windows"  />
</p>
<h5 id="1-位-滑动窗口">1 位 滑动窗口</h5>
<p><img loading="lazy" src="/assets/img/note/net/1bit.png" alt="1bit"  />
</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/* Protocol 4 (Sliding window) is bidirectional. */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define MAX_SEQ 1
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="cm">/* must be 1 for protocol 4 */</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span><span class="n">frame_arrival</span><span class="p">,</span> <span class="n">cksum_err</span><span class="p">,</span> <span class="n">timeout</span><span class="p">}</span> <span class="n">event_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;protocol.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">void</span> <span class="nf">protocol4</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">seq_nr</span> <span class="n">next_frame_to_send</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 0 or 1 only */</span>
</span></span><span class="line"><span class="cl">    <span class="n">seq_nr</span> <span class="n">frame_expected</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 0 or 1 only */</span>
</span></span><span class="line"><span class="cl">    <span class="n">frame</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* scratch variables */</span>
</span></span><span class="line"><span class="cl">    <span class="n">packet</span> <span class="n">buffer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* current packet being sent */</span>
</span></span><span class="line"><span class="cl">    <span class="n">event_type</span> <span class="n">event</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">next_frame_to_send</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* next frame on the outbound stream */</span>
</span></span><span class="line"><span class="cl">    <span class="n">frame_expected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* frame_expected next */</span>
</span></span><span class="line"><span class="cl">    <span class="n">from_network_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* fetch a packet from the network layer */</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* prepare to send the initial frame */</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="p">.</span><span class="n">seq</span> <span class="o">=</span> <span class="n">next_frame_to_send</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* insert sequence number into frame */</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="p">.</span><span class="n">ack</span> <span class="o">=</span> <span class="mi">1</span> <span class="err">−</span> <span class="n">frame_expected</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* piggybacked ack */</span>
</span></span><span class="line"><span class="cl">    <span class="n">to_physical_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* transmit the frame */</span>
</span></span><span class="line"><span class="cl">    <span class="n">start_timer</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">seq</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* start the timer running */</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">wait_for_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* frame_arrival, cksum_err, or timeout */</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">==</span> <span class="n">frame_arrival</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* a frame has arrived undamaged */</span>
</span></span><span class="line"><span class="cl">            <span class="n">from_physical_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* go get it */</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">seq</span> <span class="o">==</span> <span class="n">frame_expected</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* handle inbound frame stream */</span>
</span></span><span class="line"><span class="cl">                <span class="n">to_network_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="p">.</span><span class="n">info</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* pass packet to_network_layer */</span>
</span></span><span class="line"><span class="cl">                <span class="n">inc</span><span class="p">(</span><span class="n">frame_expected</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* invert seq number expected next */</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">ack</span> <span class="o">==</span> <span class="n">next_frame_to_send</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* handle outbound frame stream */</span>
</span></span><span class="line"><span class="cl">                <span class="n">stop_timer</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">ack</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* turn the timer off */</span>
</span></span><span class="line"><span class="cl">                <span class="n">from_network_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* fetch new pkt from_network_layer */</span>
</span></span><span class="line"><span class="cl">                <span class="n">inc</span><span class="p">(</span><span class="n">next_frame_to_send</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* invert sender’s sequence number */</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">s</span><span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* construct outbound frame */</span>
</span></span><span class="line"><span class="cl">        <span class="n">s</span><span class="p">.</span><span class="n">seq</span> <span class="o">=</span> <span class="n">next_frame_to_send</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* insert sequence number into it */</span>
</span></span><span class="line"><span class="cl">        <span class="n">s</span><span class="p">.</span><span class="n">ack</span> <span class="o">=</span> <span class="mi">1</span> <span class="err">−</span> <span class="n">frame_expected</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* seq number of last received frame */</span>
</span></span><span class="line"><span class="cl">        <span class="n">to_physical_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* transmit a frame */</span>
</span></span><span class="line"><span class="cl">        <span class="n">start_timer</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">seq</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* start the timer running */</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="多位窗口">多位窗口</h5>
<p>由于信道传输时间不可忽略，1 位滑动窗口的异常启动问题不可忽略，需要提高带宽利用率。</p>
<blockquote>
<p>bandwidth-delya product</p>
<p>$\text{带宽(bits/sec)}\times \text{单次传输时间}$</p>
<p>在以帧数为单位时，记作 BD</p>
</blockquote>
<p>在阻塞前，一次性发送$w=2BD+1$。如果考虑发送方连续发送帧并且在往返时间内收到一个确认，那么两倍的带宽-延时就是发送方可以连续发送的帧的个数；$+1$是因为必须接收完整个帧之后确认帧才会被发出。pipelining （排队发送帧）就能提高链路利用率。</p>
<p>$$\text{link utilization}=\frac{w}{1+2BD}$$</p>
<ul>
<li>go-back-n：放弃出错帧之后的正确帧（相当于窗口大小 1）</li>
<li>selective repeat，只放弃错误帧，缓存之后的正确帧</li>
</ul>
<p>两种策略分别平衡缓存区和带宽利用率。</p>
<p><img loading="lazy" src="/assets/img/note/net/gobackn.png" alt="go-back-n"  />
</p>
<h5 id="go-back-n-回退-n-协议">Go-Back-N 回退 N 协议</h5>
<p>最多发送$MAX\_SEQ$个帧。虽然不需要缓存出错后到来的帧，但是它也没有因此完全摆脱缓存问题。由于发送方可能在将来的某个时刻要重传所有未被确认的帧，所以，它必须把已经发送出去的帧一直保留，直到它能肯定接收方已经接受了这些帧。对之前的帧，可以用软件模拟每个帧的时间计数器</p>
<blockquote>
<p>cumulative acknowledgement</p>
<p>累计确认，当$n$号帧到达，之前序号的帧自动被确认（因为回退特性）</p>
</blockquote>
<p><img loading="lazy" src="/assets/img/note/net/stime.png" alt="software timer"  />
</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/* Protocol 5 (Go-back-n) allows multiple outstanding frames. The sender may transmit up
</span></span></span><span class="line"><span class="cl"><span class="cm">to MAX_SEQ frames without waiting for an ack. In addition, unlike in the previous
</span></span></span><span class="line"><span class="cl"><span class="cm">protocols, the network layer is not assumed to have a new packet all the time. Instead,
</span></span></span><span class="line"><span class="cl"><span class="cm">the network layer causes a network layer ready event when there is a packet to send. */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define MAX_SEQ 7
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span><span class="n">frame_arrival</span><span class="p">,</span> <span class="n">cksum_err</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">network_layer_ready</span><span class="p">}</span> <span class="n">event_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;protocol.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">static</span> <span class="n">boolean</span> <span class="nf">between</span><span class="p">(</span><span class="n">seq_nr</span> <span class="n">a</span><span class="p">,</span> <span class="n">seq_nr</span> <span class="n">b</span><span class="p">,</span> <span class="n">seq_nr</span> <span class="n">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* Return true if a &lt;= b &lt; c circularly; false otherwise. */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(((</span><span class="n">a</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;</span> <span class="n">c</span><span class="p">))</span> <span class="o">||</span> <span class="p">((</span><span class="n">c</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">))</span> <span class="o">||</span> <span class="p">((</span><span class="n">b</span> <span class="o">&lt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">send_data</span><span class="p">(</span><span class="n">seq_nr</span> <span class="n">frame_nr</span><span class="p">,</span> <span class="n">seq_nr</span> <span class="n">frame_expected</span><span class="p">,</span> <span class="n">packet</span> <span class="n">buffer</span><span class="p">[</span> <span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* Construct and send a data frame. */</span>
</span></span><span class="line"><span class="cl">    <span class="n">frame</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* scratch variable */</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="n">frame_nr</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* insert packet into frame */</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="p">.</span><span class="n">seq</span> <span class="o">=</span> <span class="n">frame_nr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* insert sequence number into frame */</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="p">.</span><span class="n">ack</span> <span class="o">=</span> <span class="p">(</span><span class="n">frame_expected</span> <span class="o">+</span> <span class="n">MAX_SEQ</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">MAX_SEQ</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span><span class="cm">/* piggyback ack */</span>
</span></span><span class="line"><span class="cl">    <span class="n">to_physical_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* transmit the frame */</span>
</span></span><span class="line"><span class="cl">    <span class="n">start_timer</span><span class="p">(</span><span class="n">frame_nr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* start the timer running */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">protocol5</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">seq_nr</span> <span class="n">next_frame_to_send</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* MAX_SEQ &gt; 1; used for outbound stream */</span>
</span></span><span class="line"><span class="cl">    <span class="n">seq_nr</span> <span class="n">ack_expected</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* oldest frame as yet unacknowledged */</span>
</span></span><span class="line"><span class="cl">    <span class="n">seq_nr</span> <span class="n">frame_expected</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* next frame_expected on inbound stream */</span>
</span></span><span class="line"><span class="cl">    <span class="n">frame</span> <span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* scratch variable */</span>
</span></span><span class="line"><span class="cl">    <span class="n">packet</span> <span class="n">buffer</span><span class="p">[</span><span class="n">MAX_SEQ</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* buffers for the outbound stream */</span>
</span></span><span class="line"><span class="cl">    <span class="n">seq_nr</span> <span class="n">nbuffered</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* number of output buffers currently in use */</span>
</span></span><span class="line"><span class="cl">    <span class="n">seq_nr</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* used to index into the buffer array */</span>
</span></span><span class="line"><span class="cl">    <span class="n">event_type</span> <span class="n">event</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">enable_network_layer</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* allow network layer ready events */</span>
</span></span><span class="line"><span class="cl">    <span class="n">ack_expected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* next ack_expected inbound */</span>
</span></span><span class="line"><span class="cl">    <span class="n">next_frame_to_send</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* next frame going out */</span>
</span></span><span class="line"><span class="cl">    <span class="n">frame_expected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* number of frame_expected inbound */</span>
</span></span><span class="line"><span class="cl">    <span class="n">nbuffered</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* initially no packets are buffered */</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">wait_for_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* four possibilities: see event_type above */</span>
</span></span><span class="line"><span class="cl">        <span class="k">switch</span><span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">network_layer_ready</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* the network layer has a packet to send */</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* Accept, save, and transmit a new frame. */</span>
</span></span><span class="line"><span class="cl">            <span class="n">from_network_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">[</span><span class="n">next_frame_to_send</span><span class="p">]);</span> <span class="cm">/* fetch new packet */</span>
</span></span><span class="line"><span class="cl">            <span class="n">nbuffered</span> <span class="o">=</span> <span class="n">nbuffered</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* expand the sender’s window */</span>
</span></span><span class="line"><span class="cl">            <span class="n">send_data</span><span class="p">(</span><span class="n">next_frame_to_send</span><span class="p">,</span> <span class="n">frame_expected</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span><span class="cm">/* transmit the frame */</span>
</span></span><span class="line"><span class="cl">            <span class="n">inc</span><span class="p">(</span><span class="n">next_frame_to_send</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* advance sender’s upper window edge */</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">frame_arrival</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* a data or control frame has arrived */</span>
</span></span><span class="line"><span class="cl">            <span class="n">from_physical_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* get incoming frame from_physical_layer */</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">seq</span> <span class="o">==</span> <span class="n">frame_expected</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* Frames are accepted only in order. */</span>
</span></span><span class="line"><span class="cl">                <span class="n">to_network_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="p">.</span><span class="n">info</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* pass packet to_network_layer */</span>
</span></span><span class="line"><span class="cl">                <span class="n">inc</span><span class="p">(</span><span class="n">frame_expected</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* advance lower edge of receiver’s window */</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* Ack n implies n − 1, n − 2, etc. Check for this. */</span>
</span></span><span class="line"><span class="cl">            <span class="k">while</span> <span class="p">(</span><span class="n">between</span><span class="p">(</span><span class="n">ack_expected</span><span class="p">,</span> <span class="n">r</span><span class="p">.</span><span class="n">ack</span><span class="p">,</span> <span class="n">next_frame_to_send</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* Handle piggybacked ack. */</span>
</span></span><span class="line"><span class="cl">                <span class="n">nbuffered</span> <span class="o">=</span> <span class="n">nbuffered</span> <span class="err">−</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* one frame fewer buffered */</span>
</span></span><span class="line"><span class="cl">                <span class="n">stop_timer</span><span class="p">(</span><span class="n">ack_expected</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* frame arrived intact; stop_timer */</span>
</span></span><span class="line"><span class="cl">                <span class="n">inc</span><span class="p">(</span><span class="n">ack_expected</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* contract sender’s window */</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">cksum_err</span><span class="p">:</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* just ignore bad frames */</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">timeout</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* trouble; retransmit all outstanding frames */</span>
</span></span><span class="line"><span class="cl">            <span class="n">next_frame_to_send</span> <span class="o">=</span> <span class="n">ack_expected</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* start retransmitting here */</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">nbuffered</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">send_data</span><span class="p">(</span><span class="n">next_frame_to_send</span><span class="p">,</span> <span class="n">frame_expected</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span><span class="cm">/* resend_frame */</span>
</span></span><span class="line"><span class="cl">                <span class="n">inc</span><span class="p">(</span><span class="n">next_frame_to_send</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* prepare to send the next one */</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">nbuffered</span> <span class="o">&lt;</span> <span class="n">MAX_SEQ</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">enable_network_layer</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span>
</span></span><span class="line"><span class="cl">            <span class="n">disable_network_layer</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="selective-repeat-选择重传">selective repeat 选择重传</h5>
<p>针对错误更加频繁的情景。窗口移动后，和老的不重叠，防止老的重传和新的帧混淆。$\frac{(MAX\_SEQ+1)}{2}$。启用一个辅助计时器，在没有反向数据帧时候单独发出确认帧。</p>
<blockquote>
<p>NAK</p>
<p>negative acknowledgement，否认确定记号。触发某一帧的重传</p>
</blockquote>
<p><img loading="lazy" src="/assets/img/note/net/wsize.png" alt="window size"  />
</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/* Protocol 6 (Selective repeat) accepts frames out of order but passes packets to the
</span></span></span><span class="line"><span class="cl"><span class="cm">network layer in order. Associated with each outstanding frame is a timer. When the timer
</span></span></span><span class="line"><span class="cl"><span class="cm">expires, only that frame is retransmitted, not all the outstanding frames, as in protocol 5. */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define MAX_SEQ 7
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="cm">/* should be 2ˆn − 1 */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define NR_BUFS ((MAX_SEQ + 1)/2)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span><span class="n">frame_arrival</span><span class="p">,</span> <span class="n">cksum_err</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">network_layer_ready</span><span class="p">,</span> <span class="n">ack_timeout</span><span class="p">}</span> <span class="n">event_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;protocol.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">boolean</span> <span class="n">no_nak</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* no_nak has been sent yet */</span>
</span></span><span class="line"><span class="cl"><span class="n">seq_nr</span> <span class="n">oldest_frame</span> <span class="o">=</span> <span class="n">MAX_SEQ</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* initial value is only for the simulator */</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="n">boolean</span> <span class="nf">between</span><span class="p">(</span><span class="n">seq_nr</span> <span class="n">a</span><span class="p">,</span> <span class="n">seq_nr</span> <span class="n">b</span><span class="p">,</span> <span class="n">seq_nr</span> <span class="n">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* Same as between in protocol 5, but shorter and more obscure. */</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">((</span><span class="n">a</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;</span> <span class="n">c</span><span class="p">))</span> <span class="o">||</span> <span class="p">((</span><span class="n">c</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">))</span> <span class="o">||</span> <span class="p">((</span><span class="n">b</span> <span class="o">&lt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">send_frame</span><span class="p">(</span><span class="n">frame_kind</span> <span class="n">fk</span><span class="p">,</span> <span class="n">seq_nr</span> <span class="n">frame_nr</span><span class="p">,</span> <span class="n">seq_nr</span> <span class="n">frame_expected</span><span class="p">,</span> <span class="n">packet</span> <span class="n">buffer</span><span class="p">[</span> <span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* Construct and send a data, ack, or nak frame. */</span>
</span></span><span class="line"><span class="cl">    <span class="n">frame</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* scratch variable */</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="p">.</span><span class="n">kind</span> <span class="o">=</span> <span class="n">fk</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* kind == data, ack, or nak */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">fk</span> <span class="o">==</span> <span class="n">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">s</span><span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="n">frame_nr</span> <span class="o">%</span> <span class="n">NR_BUFS</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="p">.</span><span class="n">seq</span> <span class="o">=</span> <span class="n">frame_nr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* only meaningful for data frames */</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="p">.</span><span class="n">ack</span> <span class="o">=</span> <span class="p">(</span><span class="n">frame_expected</span> <span class="o">+</span> <span class="n">MAX_SEQ</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">MAX_SEQ</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">fk</span> <span class="o">==</span> <span class="n">nak</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">no_nak</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* one nak per frame, please */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">to_physical_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* transmit the frame */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">fk</span> <span class="o">==</span> <span class="n">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">start_timer</span><span class="p">(</span><span class="n">frame_nr</span> <span class="o">%</span> <span class="n">NR_BUFS</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">stop_ack_timer</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* no need for separate ack frame */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">protocol6</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">seq_nr</span> <span class="n">ack_expected</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* lower edge of sender’s window */</span>
</span></span><span class="line"><span class="cl">    <span class="n">seq_nr</span> <span class="n">next_frame_to_send</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* upper edge of sender’s window + 1 */</span>
</span></span><span class="line"><span class="cl">    <span class="n">seq_nr</span> <span class="n">frame_expected</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* lower edge of receiver’s window */</span>
</span></span><span class="line"><span class="cl">    <span class="n">seq_nr</span> <span class="n">too</span> <span class="n">far</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* upper edge of receiver’s window + 1 */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* index into buffer pool */</span>
</span></span><span class="line"><span class="cl">    <span class="n">frame</span> <span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* scratch variable */</span>
</span></span><span class="line"><span class="cl">    <span class="n">packet</span> <span class="n">out_buf</span><span class="p">[</span><span class="n">NR_BUFS</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* buffers for the outbound stream */</span>
</span></span><span class="line"><span class="cl">    <span class="n">packet</span> <span class="n">in_buf</span><span class="p">[</span><span class="n">NR_BUFS</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* buffers for the inbound stream */</span>
</span></span><span class="line"><span class="cl">    <span class="n">boolean</span> <span class="n">arrived</span><span class="p">[</span><span class="n">NR_BUFS</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* inbound bit map */</span>
</span></span><span class="line"><span class="cl">    <span class="n">seq_nr</span> <span class="n">nbuffered</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* how many output buffers currently used */</span>
</span></span><span class="line"><span class="cl">    <span class="n">event_type</span> <span class="n">event</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">enable_network_layer</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* initialize */</span>
</span></span><span class="line"><span class="cl">    <span class="n">ack_expected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* next ack_expected on the inbound stream */</span>
</span></span><span class="line"><span class="cl">    <span class="n">next_frame_to_send</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* number of next outgoing frame */</span>
</span></span><span class="line"><span class="cl">    <span class="n">frame_expected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">too_far</span> <span class="o">=</span> <span class="n">NR_BUFS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">nbuffered</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* initially no packets are buffered */</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_BUFS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">arrived</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">wait_for_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* five possibilities: see event_type above */</span>
</span></span><span class="line"><span class="cl">        <span class="k">switch</span><span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">network_layer_ready</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* accept, save, and transmit a new frame */</span>
</span></span><span class="line"><span class="cl">            <span class="n">nbuffered</span> <span class="o">=</span> <span class="n">nbuffered</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* expand the window */</span>
</span></span><span class="line"><span class="cl">            <span class="n">from_network_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">out_buf</span><span class="p">[</span><span class="n">next_frame_to_send</span> <span class="o">%</span> <span class="n">NR_BUFS</span><span class="p">]);</span> <span class="cm">/* fetch new packet */</span>
</span></span><span class="line"><span class="cl">            <span class="n">send_frame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">next_frame_to_send</span><span class="p">,</span> <span class="n">frame_expected</span><span class="p">,</span> <span class="n">out_buf</span><span class="p">);</span><span class="cm">/* transmit the frame */</span>
</span></span><span class="line"><span class="cl">            <span class="n">inc</span><span class="p">(</span><span class="n">next_frame_to_send</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* advance upper window edge */</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">frame_arrival</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* a data or control frame has arrived */</span>
</span></span><span class="line"><span class="cl">            <span class="n">from_physical_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* fetch incoming frame from_physical_layer */</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="cm">/* An undamaged frame has arrived. */</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">((</span><span class="n">r</span><span class="p">.</span><span class="n">seq</span> <span class="o">!=</span> <span class="n">frame_expected</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">no_nak</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="n">send_frame</span><span class="p">(</span><span class="n">nak</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">frame_expected</span><span class="p">,</span> <span class="n">out_buf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">else</span>
</span></span><span class="line"><span class="cl">                    <span class="n">start_ack_timer</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">between</span><span class="p">(</span><span class="n">frame_expected</span><span class="p">,</span><span class="n">r</span><span class="p">.</span><span class="n">seq</span><span class="p">,</span><span class="n">too</span> <span class="n">far</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">arrived</span><span class="p">[</span><span class="n">r</span><span class="p">.</span><span class="n">seq</span><span class="o">%</span><span class="n">NR_BUFS</span><span class="p">]</span><span class="o">==</span><span class="nb">false</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="cm">/* Frames may be accepted in any order. */</span>
</span></span><span class="line"><span class="cl">                    <span class="n">arrived</span><span class="p">[</span><span class="n">r</span><span class="p">.</span><span class="n">seq</span> <span class="o">%</span> <span class="n">NR_BUFS</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="cm">/* mark buffer as full */</span>
</span></span><span class="line"><span class="cl">                    <span class="n">in_buf</span><span class="p">[</span><span class="n">r</span><span class="p">.</span><span class="n">seq</span> <span class="o">%</span> <span class="n">NR_BUFS</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="p">.</span><span class="n">info</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="cm">/* insert data into buffer */</span>
</span></span><span class="line"><span class="cl">                    <span class="k">while</span> <span class="p">(</span><span class="n">arrived</span><span class="p">[</span><span class="n">frame_expected</span> <span class="o">%</span> <span class="n">NR_BUFS</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="cm">/* Pass frames and advance window. */</span>
</span></span><span class="line"><span class="cl">                        <span class="n">to_network_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">in_buf</span><span class="p">[</span><span class="n">frame_expected</span> <span class="o">%</span> <span class="n">NR_BUFS</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">                        <span class="n">no_nak</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                        <span class="n">arrived</span><span class="p">[</span><span class="n">frame_expected</span> <span class="o">%</span> <span class="n">NR_BUFS</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                        <span class="n">inc</span><span class="p">(</span><span class="n">frame_expected</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                        <span class="cm">/* advance lower edge of receiver’s window */</span>
</span></span><span class="line"><span class="cl">                        <span class="n">inc</span><span class="p">(</span><span class="n">too</span> <span class="n">far</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                        <span class="cm">/* advance upper edge of receiver’s window */</span>
</span></span><span class="line"><span class="cl">                        <span class="n">start_ack_timer</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                        <span class="cm">/* to see if a separate ack is needed */</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">((</span><span class="n">r</span><span class="p">.</span><span class="n">kind</span><span class="o">==</span><span class="n">nak</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">between</span><span class="p">(</span><span class="n">ack_expected</span><span class="p">,(</span><span class="n">r</span><span class="p">.</span><span class="n">ack</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="p">(</span><span class="n">MAX_SEQ</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">next_frame_to_send</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="n">send_frame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">ack</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">MAX_SEQ</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">frame_expected</span><span class="p">,</span> <span class="n">out_buf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">while</span> <span class="p">(</span><span class="n">between</span><span class="p">(</span><span class="n">ack_expected</span><span class="p">,</span> <span class="n">r</span><span class="p">.</span><span class="n">ack</span><span class="p">,</span> <span class="n">next_frame_to_send</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">nbuffered</span> <span class="o">=</span> <span class="n">nbuffered</span> <span class="err">−</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* handle piggybacked ack */</span>
</span></span><span class="line"><span class="cl">                <span class="n">stop_timer</span><span class="p">(</span><span class="n">ack_expected</span> <span class="o">%</span> <span class="n">NR_BUFS</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* frame arrived intact */</span>
</span></span><span class="line"><span class="cl">                <span class="n">inc</span><span class="p">(</span><span class="n">ack_expected</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* advance lower edge of sender’s window */</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">cksum_err</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">no_nak</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">send_frame</span><span class="p">(</span><span class="n">nak</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">frame_expected</span><span class="p">,</span> <span class="n">out_buf</span><span class="p">);</span> <span class="cm">/* damaged frame */</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">timeout</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">send_frame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">oldest_frame</span><span class="p">,</span> <span class="n">frame_expected</span><span class="p">,</span> <span class="n">out_buf</span><span class="p">);</span> <span class="cm">/* we timed out */</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">ack_timeout</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">send_frame</span><span class="p">(</span><span class="n">ack</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">frame_expected</span><span class="p">,</span> <span class="n">out_buf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* ack timer expired; send ack */</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">nbuffered</span> <span class="o">&lt;</span> <span class="n">NR_BUFS</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">enable_network_layer</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span>
</span></span><span class="line"><span class="cl">            <span class="n">disable_network_layer</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="ch4-介质访问控制子层">ch4 介质访问控制子层</h2>
<blockquote>
<p>MAC</p>
<p>Medium Access Control</p>
</blockquote>
<p>在多用户之间分配单广播信道。FDM（频分复用）效率不高。信道速度 $C \rm{bps}$ ，每帧 $1/\mu\rm{bit}$ ，帧到达速度 $\lambda\rm{frames/sec}$ 。实际延时</p>
<p>$$T=\frac{1}{\mu C -\lambda}$$</p>
<p>如果信道等分 $N$ 份，延时大幅度增加。因此需要动态分配信道</p>
<p>$$T_N=\frac{1}{\mu (C/N) -(\lambda/N)}=\frac{N}{\mu C -\lambda}=NT$$</p>
<ol>
<li>流量独立，在 $\Delta_t$ 时间间隔中，帧数期望为 $\lambda\Delta_t$ （假定是泊松分布，而暂时不考虑突发流量）</li>
<li>单信道，核心，没有其他外部手段通信/核对信息</li>
<li>冲突可观察</li>
<li>时间连续/分槽 slotted</li>
<li>载波侦听 carrirer sense 或不听</li>
</ol>
<h3 id="多路访问协议">多路访问协议</h3>
<blockquote>
<p>contention system</p>
<p>竞争系统：共享信道，被同时发送帧而都失效</p>
</blockquote>
<p><img loading="lazy" src="/assets/img/note/net/thorouput.png" alt="thorouput"  />
</p>
<h4 id="aloha">ALOHA</h4>
<p>有数据直接发，如果碰撞，在等待随机时间之后重发。</p>
<p>假设帧等长，发送用时$t$，帧产生服从泊松分布，一个“帧时”平均有 G 帧，实际产生 k 帧概率为</p>
<p>$$\mathrm{Pr[k]}=\frac{G^ke^{-G}}{k!}$$</p>
<p>一帧在$2t$中任意有 1 帧产生都会损毁，因此吞吐量最终为</p>
<p>$$S=Ge^{-2G}$$</p>
<p><img loading="lazy" src="/assets/img/note/net/aloha.png" alt="aloha"  />
</p>
<h4 id="分槽-aloha">分槽 ALOHA</h4>
<p>要求每帧必须在时间槽开始时才能尝试发送，不能在任意时刻发送，只需要考虑单槽$t$内的碰撞。吞吐量</p>
<p>$$S=Ge^{-G}$$</p>
<p>1 帧需要 k 次尝试的几率为</p>
<p>$$P_k=e^{-G}(1-e^{-G})^{k-1}$$</p>
<p>传输次数期望为</p>
<p>$$E=\sum kP_k=\sum ke^{-G}(1-e^{-G})^{k-1}=e^G$$</p>
<h4 id="csma">CSMA</h4>
<blockquote>
<p>CSMA</p>
<p>Carrier Sense Multiple Access，载波侦听多路访问协议</p>
</blockquote>
<p>在发送自己帧之前，监听是否信道被占用，不占用再发送；如果占用</p>
<h5 id="persistent等到占用结束直接开始发">Persistent：等到占用结束直接开始发</h5>
<p>会在同时多站等发时候冲突</p>
<h5 id="nonpersistent">Nonpersistent</h5>
<p>等待一段时间后再检测</p>
<h5 id="p-persistent">p-persistent</h5>
<p>针对分槽时间，每个槽如果空闲，以$p$的概率发，$1-p$的概率等下个时间槽。</p>
<p>如果有 k 个站需要传数据，站得发送的概率$P$为</p>
<p>$$P=kp(1-p)^{k-1}$$</p>
<p>在$p=\frac{1}{k}$时候有$P_\max$为</p>
<p>$$P_\max=(\frac{k-1}{k})^{k-1}$$</p>
<p>而且$k\to\infty$时候有$P\to\frac{1}{e}$。</p>
<h4 id="csmacd-collision-detection">CSMA/CD collision detection</h4>
<p>在发送前，信道空闲时候，发送竞争信号，竞争胜利者发送数据帧</p>
<p><img loading="lazy" src="/assets/img/note/net/csmacd.png" alt="CSMA/CD"  />
</p>
<h4 id="csmaca-collision-avoidance">CSMA/CA collision avoidance</h4>
<blockquote>
<p>binary exponential backoff</p>
<p>二进制指数后退。在$i$次碰撞后，在<a href="#p-persistent">p-persistent CSMA</a>基础上改为等待$0\sim2^i-1$个时间槽</p>
</blockquote>
<p>实际中，有时间槽次数上限和碰撞次数上限</p>
<p>竞争时间间隔为$j$的概率</p>
<p>$$P_{t=jT_0}=P(1-P)^{j-1}$$</p>
<p>每次竞争平均时间槽数为</p>
<p>$$E=\sum_{j=0} jP(1-P)^{j-1}=\frac{1}{P}$$</p>
<h4 id="bit-map-位图协议-无冲突">Bit-Map 位图协议 无冲突</h4>
<p>信道中有公共信息广播时间。在该时间里，每个站有一个槽，发送信息表示接下来需要发送数据帧；沉默表示接下来不发。然后站按照申请的结果发。平均等待$N$个槽时间</p>
<h4 id="token-ring-令牌环-无冲突">token ring 令牌环 无冲突</h4>
<p>所有站连接成一个单环结构，传递令牌。得到令牌的发数据，发完继续传；如果不用发数据直接向下传</p>
<h4 id="binary-countdown-二进制计数-无冲突">binary countdown 二进制计数 无冲突</h4>
<p>信道中有公共信息广播时间，所有站监听。如果需要发数据，从高位开始，在对应时间槽中发送自己优先级（唯一，二进制表示）消息，消息之间是<strong>或</strong>关系。只有知道自己是优先级最高的才能接下来发送。竞争用时$\log_2N$</p>
<h4 id="the-adaptive-tree-walk-protocol-自适应树遍历协议">The Adaptive Tree Walk Protocol 自适应树遍历协议</h4>
<p>注意到，如果竞争站的数目$k$比较小时候，<a href="#p-persistent">p-persistent CSMA 的获得信道概率</a>会上升。因此可以通过分组减少竞争，极大提升信道使用效果</p>
<p>自适应树中，将站看作是二叉树的叶节点，从根节点开始搜索。如果某个节点冲突，向下探寻左、右子节点；如果左节点不冲突了，给左节点下需求站发送数据；下一时间槽给右节点的站。在公共广播期间，站按照自身的父节点被搜索到的顺序竞争时间槽。</p>
<p>如果$q$个站随机均匀分布，在让每个槽中参与竞争的平均站数为 1 时，得到最优树高$1+\log_2q$</p>
<h3 id="以太网">以太网</h3>
<h4 id="设施">设施</h4>
<table>
<thead>
<tr>
<th></th>
<th>hub 集线器</th>
<th>switch 交换机</th>
</tr>
</thead>
<tbody>
<tr>
<td>pro</td>
<td>易排错</td>
<td>扩容；无冲突；安全</td>
</tr>
<tr>
<td>con</td>
<td>不能扩容，逻辑上等同单线缆</td>
<td>自带 buffer 防止同时发送端口</td>
</tr>
</tbody>
</table>
<h2 id="ch5-网络层">ch5 网络层</h2>
<ol>
<li>向上提供的服务应该独立于路由器技术</li>
<li>应该向传输层屏蔽路由器的数量、类型和拓扑关系</li>
<li>传输层可用的网络地址应该有一个统一编址方案，甚至可以跨越 LAN 和 WAN</li>
</ol>
<blockquote>
<p>datagram</p>
<p>数据报网络，所有的数据包都被独立地注入到网络中，并且每个数据包独立路由，不需要提前建立任何设置</p>
</blockquote>
<blockquote>
<p>virtual circuit</p>
<p>虚电路网络，在发送数据包之前，必须首先建立起一条从源路由器到目标路由器之间的路径</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>datagram</th>
<th style="text-align:left">virtual-circuit</th>
</tr>
</thead>
<tbody>
<tr>
<td>线路初始化</td>
<td>不需要</td>
<td style="text-align:left">需要</td>
</tr>
<tr>
<td>寻址</td>
<td>包带有源和目标地址</td>
<td style="text-align:left">包带有短 VC 号</td>
</tr>
<tr>
<td>状态信息</td>
<td>路由不包含连接信息</td>
<td style="text-align:left">每条虚电路（VC）需要路由记录每个连接</td>
</tr>
<tr>
<td>路由</td>
<td>每个包单独路由</td>
<td style="text-align:left">VC 设置时候路由，包遵守</td>
</tr>
<tr>
<td>路由失效影响</td>
<td>无，除了因为崩溃丢的包</td>
<td style="text-align:left">故障路由相关 VC 均中断</td>
</tr>
<tr>
<td>服务质量</td>
<td>困难</td>
<td style="text-align:left">简单，如果建立 VC 时候资源足够</td>
</tr>
<tr>
<td>拥塞控制</td>
<td>困难</td>
<td style="text-align:left">简单，如果建立 VC 时候资源足够</td>
</tr>
</tbody>
</table>
<h3 id="路由算法">路由算法</h3>
<blockquote>
<p>routing algorithm</p>
<p>路由算法。网络层软件决定入境数据包在哪条线外发</p>
</blockquote>
<blockquote>
<p>optimality principle</p>
<p>路由最优化原理。如果路由 J 在 I 到 K 最优路径，那么 J 到 K 最优路径也是同样的路由</p>
</blockquote>
<blockquote>
<p>sink tree</p>
<p>汇集树。从所有的源到一个指定目标的最优路径的集合构成了一棵以目标节点为根的树/DAG（有向无环图）</p>
</blockquote>
<blockquote>
<p>spanning tree</p>
<p>包含所有路由器的树，不一定是最优路径（和汇集树相区别）</p>
</blockquote>
<h4 id="dijstra-最短路径">Dijstra 最短路径</h4>
<p>每次找到距离源距离最近（距离=到已发现集合的某点距离+该点距离源距离）的新节点，加入发现集合</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#define MAX_NODES 1024
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="cm">/* maximum number of nodes */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define INFINITY 1000000000
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="cm">/* a number larger than every maximum path */</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">dist</span><span class="p">[</span><span class="n">MAX_NODES</span><span class="p">][</span><span class="n">MAX_NODES</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* dist[i][j] is the distance from i to j */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">shortest</span> <span class="nf">path</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">path</span><span class="p">[])</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">state</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* the path being worked on */</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">predecessor</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* previous node */</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* length from source to this node */</span>
</span></span><span class="line"><span class="cl">        <span class="k">enum</span> <span class="p">{</span><span class="n">permanent</span><span class="p">,</span> <span class="n">tentative</span><span class="p">}</span> <span class="n">label</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* label state */</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="n">state</span><span class="p">[</span><span class="n">MAX_NODES</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">min</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">state</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">state</span><span class="p">[</span><span class="n">n</span><span class="p">];</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* initialize state */</span>
</span></span><span class="line"><span class="cl">        <span class="n">p</span><span class="o">-&gt;</span><span class="n">predecessor</span> <span class="o">=</span> <span class="err">−</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">p</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">INFINITY</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">p</span><span class="o">-&gt;</span><span class="n">label</span> <span class="o">=</span> <span class="n">tentative</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="p">[</span><span class="n">t</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">state</span><span class="p">[</span><span class="n">t</span><span class="p">].</span><span class="n">label</span> <span class="o">=</span> <span class="n">permanent</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">k</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* k is the initial working node */</span>
</span></span><span class="line"><span class="cl">    <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* Is there a better path from k? */</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span> <span class="c1">//n node
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">label</span> <span class="o">==</span> <span class="n">tentative</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">length</span> <span class="o">+</span> <span class="n">dist</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">predecessor</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">length</span> <span class="o">+</span> <span class="n">dist</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* Find the tentatively labeled node with the smallest label. */</span>
</span></span><span class="line"><span class="cl">        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">min</span> <span class="o">=</span> <span class="n">INFINITY</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">label</span> <span class="o">==</span> <span class="n">tentative</span> <span class="o">&amp;&amp;</span> <span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span> <span class="o">&lt;</span> <span class="n">min</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">min</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">state</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">label</span> <span class="o">=</span> <span class="n">permanent</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">k</span> <span class="o">!=</span> <span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* Copy the path into the output array. */</span>
</span></span><span class="line"><span class="cl">    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">do</span> <span class="p">{</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span> <span class="n">k</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">predecessor</span><span class="p">;</span> <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="flooding-泛洪">flooding 泛洪</h4>
<p>每一个入境数据包发送到除了该数据包到达的那条线路以外的每条出境线路</p>
<ol>
<li>泛洪包带有寿命，计数减到 0 之后不再发</li>
<li>追踪泛洪包防止二次发送。泛洪包带序号，一个序号对应一次泛洪，一次泛洪只发送一次</li>
</ol>
<ul>
<li>保证广播</li>
<li>robust</li>
</ul>
<h4 id="distance-vector-routing-距离向量路由">distance vector routing 距离向量路由</h4>
<p>每个路由器维护一张表（即一个矢量)，表中列出了当前已知的到每个目标的最佳距离，以及所使用的链路。这些表通过邻居之间相互交换信息而不断被更新，最终每个路由器都了解到达每个目的地的最佳链路。</p>
<p>又名 Bellman-Fold 算法</p>
<blockquote>
<p>Count-to-Infinity</p>
<p>无穷计数问题。坏消息传递慢，距离每次增 1 而已（没有一个路由器具有一个比它所有邻居的最小值还大于 1 的值，从邻居获得道路信息不包含自身是否在道路上）</p>
</blockquote>
<h4 id="link-state-routing-链路状态路由">link state routing 链路状态路由</h4>
<ol>
<li>发现它的邻居节点，并了解其网络地址</li>
<li>设置到每个邻居节点的距离或者成本度量值</li>
<li>构造一个包含所有刚刚获知的链路信息包</li>
<li>将这个包发送给所有其他的路由器，并接收来自所有其他路由器的信息包</li>
<li>计算出到每个其他路由器的最短路径</li>
</ol>
<p>每个路由都知道网络拓扑结构，每个路由自行完成<a href="#dijstra-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84">Dijstra 最短路径算法</a></p>
<h4 id="层次路由">层次路由</h4>
<p>分层。可以证明对于 $N$ 路由数目网络最优层数 $\ln N$，每个路由器查找表条目 $e\ln N$。</p>
<h4 id="广播路由">广播路由</h4>
<blockquote>
<p>multidestination routing</p>
<p>多目标路由。每个数据包包含一组目标地址，路由对于某条线上转发时候只保留线连接区域地址，直到只发给 1 个目标地址</p>
</blockquote>
<blockquote>
<p>reverse path forwarding</p>
<p>逆向路径转发。检测数据包是否来自汇集树（或者放宽为优化的生成树），否则丢弃，结合<a href="#flooding-%E6%B3%9B%E6%B4%AA">泛洪</a></p>
</blockquote>
<ol>
<li>每个路由单独发包</li>
<li><a href="#flooding-%E6%B3%9B%E6%B4%AA">泛洪</a></li>
<li>多目标路由</li>
</ol>
<h3 id="组播路由">组播路由</h3>
<blockquote>
<p>core-based tree</p>
<p>基于核心树。只对核心（core/root）建生成树</p>
</blockquote>
<ol>
<li>干脆 <a href="#%E5%B9%BF%E6%92%AD%E8%B7%AF%E7%94%B1">广播路由</a></li>
<li>修建生成树，按需要传播</li>
<li>其他路由先发到核心，核心走核心树</li>
</ol>
<h4 id="anycast-routing-选播路由">anycast routing 选播路由</h4>
<blockquote>
<p>anycast</p>
<p>数据包发送到特定一个组中最近的一个路由</p>
</blockquote>
<h3 id="拥塞控制算法">拥塞控制算法</h3>
<blockquote>
<p>bufferfloat</p>
<p>路由内存充足反而容易导致拥塞。数据包（本来会因为内存不足丢弃）排到队列前面时，它们早己经超时（重复地）并且它们的副本也己经发送</p>
</blockquote>
<p><img loading="lazy" src="/assets/img/note/net/congestc.png" alt="congestion control"  />
</p>
<h4 id="traffic-aware-routing">Traffic-Aware Routing</h4>
<p>流量感知路由。将负载考虑到路由选择上，但不能直接使用流量调整，防止路由选择波动。</p>
<h4 id="admission-control">admission control</h4>
<p>准入控制。只能针对虚电路网络，在可承担负载情况下才建立新连接。</p>
<h4 id="load-shedding">load shedding</h4>
<p>负载脱落。直接抛弃负载保证不拥塞。抛弃优先级可以结合流量费用设定。</p>
<blockquote>
<p>wine</p>
<p>旧数据包保留：如文件传输</p>
</blockquote>
<blockquote>
<p>milk</p>
<p>新数据包保留：如流媒体</p>
</blockquote>
<h4 id="traffic-shaping">traffic shaping</h4>
<p>流量整形。</p>
<p>桶容量 $B$ ，数据速率 $R$</p>
<blockquote>
<p>leaky bucket</p>
<p>漏桶。向缓冲区发包，包以 $R$ 离开缓冲区</p>
</blockquote>
<blockquote>
<p>token bucket</p>
<p>令牌桶。令牌以 $R$ 速度累计， 得到令牌才能发包</p>
</blockquote>
<p>流量突发时长 $S$ ，突发产生速率 $M$ ，则桶算法有</p>
<p>$$B+RS=MS$$</p>
<p>还可以级联桶，调控平均速率和突发最大速率。</p>
<p><img loading="lazy" src="/assets/img/note/net/bucket.png" alt="bucket algorithm"  />
</p>
<h4 id="active-queue-management-主动队列管理">active queue management 主动队列管理</h4>
<p>主动管理负载避免拥塞，路由监控自己使用的资源。期待延迟为 $d$ ，队列长度 $s$ ，有关系式</p>
<p>$$d_{new}=\alpha d_{old}+(1-\alpha)s$$</p>
<blockquote>
<p>Exponentially Weighted Moving Average</p>
<p>EWMA，指数加权移动平均。 $\alpha$ 是路由遗忘历史信息的常数。等同于低通滤波器。 期待延迟 $d$ 超过阈值预示拥塞发生</p>
</blockquote>
<h4 id="random-early-detection-随机早期检测">Random Early Detection 随机早期检测</h4>
<p>RED。因为路由难以得到显式信息通知拥塞，只有包丢失是容易感知的，但是包丢失对于避免拥塞太晚了。当某条链路上的平均队列长度超过某个阈值时，该链路就被认为即将拥塞，因此路由器随机丢弃一小部分数据包。隐含传递拥塞信号</p>
<h4 id="choke-packets">choke packets</h4>
<p>直接向发送方回传拥塞发生的通知数据包。</p>
<h4 id="explicit-congestion-notification-显式拥塞通知">Explicit Congestion Notification 显式拥塞通知</h4>
<p>ECN。不单独<a href="#choke-packets">发拥塞通知包</a>，在包中间标志位标记拥塞信息。</p>
<h4 id="hop-by-hop-backpressure">Hop-by-Hop Backpressure</h4>
<p>防止路程过长，拥塞通知延迟太久。同时用<a href="#choke-packets">choke packets（拥塞通知包）</a>通知中间路由控制流量。</p>
<h2 id="ch6-传输层">ch6 传输层</h2>
<p>传输层主要跑在用户机上，而<a href="#ch5-%E7%BD%91%E7%BB%9C%E5%B1%82">网络层</a>跑在路由器上</p>
<h3 id="socket">Socket</h3>
<h4 id="原语">原语</h4>
<table>
<thead>
<tr>
<th>原语</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>socket</td>
<td>建立一个新通讯端点</td>
</tr>
<tr>
<td>bind</td>
<td>将 socket 与一个本地地址关联</td>
</tr>
<tr>
<td>listen</td>
<td>声明愿意接受连接；给出队列长度</td>
</tr>
<tr>
<td>accept</td>
<td>被动创建一个入境连接</td>
</tr>
<tr>
<td>connect</td>
<td>主动尝试创建连接</td>
</tr>
<tr>
<td>send</td>
<td>通过连接传输数据</td>
</tr>
<tr>
<td>receive</td>
<td>通过连接接受数据</td>
</tr>
<tr>
<td>close</td>
<td>断开连接</td>
</tr>
</tbody>
</table>
<h4 id="文件传输程序">文件传输程序</h4>
<h5 id="客户端">客户端</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/* This page contains a client program that can request a file from the server program
</span></span></span><span class="line"><span class="cl"><span class="cm"> * on the next page. The server responds by sending the whole file.
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;netdb.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;netinet/in.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define SERVER_PORT 8080
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="cm">/* arbitrar y, but client &amp; server must agree */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define BUF_SIZE 4096
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="cm">/* block transfer size */</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">bytes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">BUF_SIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* buffer for incoming file */</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">hostent</span><span class="o">*</span> <span class="n">h</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* info about server */</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">sockaddr</span> <span class="n">in_channel</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* holds IP address */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Usage: client server-name file-name&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">h</span> <span class="o">=</span> <span class="n">gethostbyname</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* look up host’s IP address */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">h</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;gethostbyname failed to locate %s&#34;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">PF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="n">IPPROTO_TCP</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;socket call failed&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">channel</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">channel</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">channel</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">channel</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">h_addr</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">h_length</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">channel</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">SERVER_PORT</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">c</span> <span class="o">=</span> <span class="n">connect</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="nc">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">channel</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">channel</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;connect failed&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* Connection is now established. Send file name including 0 byte at end. */</span>
</span></span><span class="line"><span class="cl">    <span class="n">write</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">strlen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* Go get the file and write it to standard output. */</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">bytes</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">BUF_SIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* read from socket */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* check for end of file */</span>
</span></span><span class="line"><span class="cl">        <span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* wr ite to standard output */</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="服务器端">服务器端</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="cm">/* This is the server code */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;netdb.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;netinet/in.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/fcntl.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define SERVER_PORT 8080
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="cm">/* arbitrar y, but client &amp; server must agree */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define BUF_SIZE 4096
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="cm">/* block transfer size */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define QUEUE_SIZE 10
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">sa</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">on</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">BUF_SIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* buffer for outgoing file */</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">sockaddr_in</span> <span class="n">channel</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* holds IP address */</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* Build address structure to bind to socket. */</span>
</span></span><span class="line"><span class="cl">    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">channel</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">channel</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* zero channel */</span>
</span></span><span class="line"><span class="cl">    <span class="n">channel</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">channel</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">channel</span><span class="p">.</span><span class="n">sin</span> <span class="o">+</span> <span class="n">port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">SERVER_PORT</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* Passive open. Wait for connection. */</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="n">IPPROTO_TCP</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* create socket */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;socket call failed&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">setsockopt</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">on</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">on</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">b</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="nc">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">channel</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">channel</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;bind failed&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">l</span> <span class="o">=</span> <span class="n">listen</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">QUEUE_SIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* specify queue size */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;listen failed&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* Socket is now set up and bound. Wait for connection and process it. */</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">sa</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* block for connection request */</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">sa</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">printf</span><span class="p">(</span><span class="s">&#34;accept failed&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">read</span><span class="p">(</span><span class="n">sa</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">BUF_SIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* read file name from socket */</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* Get and return the file. */</span>
</span></span><span class="line"><span class="cl">        <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* open the file to be sent back */</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">printf</span><span class="p">(</span><span class="s">&#34;open failed&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">bytes</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">BUF_SIZE</span><span class="p">);</span> <span class="cm">/* read from file */</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* check for end of file */</span>
</span></span><span class="line"><span class="cl">            <span class="n">write</span><span class="p">(</span><span class="n">sa</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* wr ite bytes to socket */</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* close file */</span>
</span></span><span class="line"><span class="cl">        <span class="n">close</span><span class="p">(</span><span class="n">sa</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* close connection */</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div>]]></content:encoded></item><item><title>启动共情的责任人</title><link>https://livypad.github.io/post/2022-08-15-empathy/</link><pubDate>Mon, 15 Aug 2022 01:04:00 +0800</pubDate><guid>https://livypad.github.io/post/2022-08-15-empathy/</guid><description>对于文艺作品，启动共情的责任人 Chinese Version 观众可以理解文艺作品的情绪，但是观众自身没有投入情绪，应该归咎于谁？我个人认为，应该归咎于文艺作品创作者，</description><content:encoded><![CDATA[<h1 id="对于文艺作品启动共情的责任人">对于文艺作品，启动共情的责任人</h1>
<h2 id="chinese-version">Chinese Version</h2>
<p>观众可以理解文艺作品的情绪，但是观众自身没有投入情绪，应该归咎于谁？我个人认为，应该归咎于文艺作品创作者，而不是指责观众。考虑一个极端的例子，假定能搞到政府的某种负面有关事情的涉及名单（eg，新冠死亡名单）和对应人的背景，那你也不可能同等强度的对每个条目对应的人投入足量且相对平衡的情绪。不然的话，一个名单对应的数目，总比一个故事多数十，乃至成百上千吧。那投入情绪真能实现对应倍数吗？某种意义上，文艺作品就是利用了智人的脑结构的特殊性质，而智人投入情绪也不是按照什么非常合理的原则的。那这样的话，如何调动情绪显然就应该是创作者考虑的问题。</p>
<h2 id="english-version">English Version</h2>
<p>When the audience can understand the emotions of an artwork with lack of emotional engagement, who should be blamed for? The creators of the artwork should be blamed, not the audience.</p>
<p>Consider an extreme example, assuming that you get access to a government list of something negative, say, a list of Covid-19 deaths, and background information of corresponding people, it is just not realistic to invest a sufficient and relatively intensity-balanced amount of emotions into each person corresponding to each entry. Otherwise, a list usually can contain dozens of, hundreds of or even thousands of stories compared with the particular one described in an artwork. Is it really possible to offer the same multiples of concern? In a sense, literature takes advantage of the special nature of the brain structure of homo sapiens. And emotional engagement of homo sapiens is not based on some very reasonable principles. To draw a conclusion, it is the matter of the creator to consider how to evoke empathy.</p>
<p><img loading="lazy" src="/assets/img/empathy.jpg" alt="empathy"  />
</p>
]]></content:encoded></item><item><title>遥远的时间有关的童话/寓言（？</title><link>https://livypad.github.io/post/2022-06-21-fairytalerabbit/</link><pubDate>Tue, 21 Jun 2022 00:00:00 +0000</pubDate><guid>https://livypad.github.io/post/2022-06-21-fairytalerabbit/</guid><description>遥远的时间有关的童话/寓言（？ 小时候看儿童向杂志看到一个略显黑暗（？）的童话/寓言（？。有个小兔子不喜欢上学，喜欢星期天放假。一个老兔子给了</description><content:encoded><![CDATA[<h1 id="遥远的时间有关的童话寓言">遥远的时间有关的童话/寓言（？</h1>
<p>小时候看儿童向杂志看到一个略显黑暗（？）的童话/寓言（？。有个小兔子不喜欢上学，喜欢星期天放假。一个老兔子给了 ta 一筐胡萝卜，吃一根就能到星期天了。小兔子就天天吃那筐胡萝卜，天天过星期天。有一天胡萝卜吃完了，小兔子也老了。因为胡罗卜的机制是跳过星期一到六。</p>
<p>记忆会自动分类记录不同的状态，日子过得就像那个小兔子。学习时会自动续接之前看到到的页码，做的题，而不会考虑之前的视频到哪一 p，知乎看到哪个问题。用记忆回顾关键点，真的会忽视中间其他领域用时。大学这种，以假期定界的生活。每年大休息状态：寒假和暑假；大工作状态：两个学期。4 年就只是 8 个学期。8 个萝卜就过去 4 年了。</p>
]]></content:encoded></item><item><title>FFmpeg转换音乐文件格式</title><link>https://livypad.github.io/post/2022-03-23-ffmpeg/</link><pubDate>Wed, 23 Mar 2022 00:00:00 +0000</pubDate><guid>https://livypad.github.io/post/2022-03-23-ffmpeg/</guid><description>FFmpeg是一个开源强大的音视频库。这里用 FFmpeg“大炮打蚊子”，用来当格式工厂用，转音乐文件格式。下面是*Unix 环境下用find命</description><content:encoded><![CDATA[<p><a href="https://ffmpeg.org/">FFmpeg</a>是一个开源强大的音视频库。这里用 FFmpeg“大炮打蚊子”，用来当格式工厂用，转音乐文件格式。下面是*Unix 环境下用<code>find</code>命令搭配 FFmpeg，将当前工作路径下的所用*.flac 转化为*.mp3 格式。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">find . -name <span class="s2">&#34;*.flac&#34;</span> -maxdepth <span class="m">1</span> -exec ffmpeg -i <span class="o">{}</span> -ab 320k -map_metadata <span class="m">0</span> -id3v2_version <span class="m">3</span> <span class="o">{}</span>.mp3 <span class="se">\;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="rust-的-cli-toy-程序">Rust 的 cli toy 程序</h1>
<p>由此，可以顺手搞一个 rust 的 cli 程序，实现任何音乐格式的互转。主要是使用<code>walkdir</code>这个库，不用自己实现遍历。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-toml" data-lang="toml"><span class="line"><span class="cl"><span class="p">[</span><span class="nx">package</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">name</span> <span class="p">=</span> <span class="s2">&#34;music_converter&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">version</span> <span class="p">=</span> <span class="s2">&#34;0.1.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">edition</span> <span class="p">=</span> <span class="s2">&#34;2018&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">dependencies</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">walkdir</span> <span class="p">=</span> <span class="s2">&#34;2&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">borrow</span>::<span class="n">Borrow</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">env</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">path</span>::<span class="n">Path</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">process</span>::<span class="p">{</span><span class="n">Command</span><span class="p">,</span><span class="w"> </span><span class="n">Stdio</span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">walkdir</span>::<span class="n">WalkDir</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">cin</span><span class="p">(</span><span class="n">print_info</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">print_info</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">io</span>::<span class="n">stdin</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">.</span><span class="n">read_line</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">input</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;Failed to read line&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">input</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">path_match</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">path</span>: <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="nc">Path</span><span class="p">,</span><span class="w"> </span><span class="n">ext</span>: <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">not_full_name</span>: <span class="kt">bool</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="o">&amp;&#39;</span><span class="na">a</span><span class="w"> </span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">not_full_name</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">file_ext</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">path</span><span class="p">.</span><span class="n">extension</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">file_ext</span><span class="p">.</span><span class="n">to_str</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ext</span><span class="p">.</span><span class="n">trim</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">path_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">path</span><span class="p">.</span><span class="n">to_str</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">file_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">path</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">.</span><span class="n">clone</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">.</span><span class="n">file_stem</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">.</span><span class="n">unwrap</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">.</span><span class="n">to_str</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">.</span><span class="n">unwrap</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">.</span><span class="n">to_string</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">file_name</span><span class="p">.</span><span class="n">push_str</span><span class="p">(</span><span class="s">&#34;.mp3&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nb">Some</span><span class="p">((</span><span class="n">path_name</span><span class="p">.</span><span class="n">borrow</span><span class="p">(),</span><span class="w"> </span><span class="n">file_name</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nb">None</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">None</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">ext</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">path</span><span class="p">.</span><span class="n">clone</span><span class="p">().</span><span class="n">file_name</span><span class="p">().</span><span class="n">unwrap</span><span class="p">().</span><span class="n">to_str</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">path_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">path</span><span class="p">.</span><span class="n">to_str</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">file_name_no_ext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">path</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">.</span><span class="n">clone</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">.</span><span class="n">file_stem</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">.</span><span class="n">unwrap</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">.</span><span class="n">to_str</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">.</span><span class="n">unwrap</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">.</span><span class="n">to_string</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">file_name_no_ext</span><span class="p">.</span><span class="n">push_str</span><span class="p">(</span><span class="s">&#34;.mp3&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">Some</span><span class="p">((</span><span class="n">path_name</span><span class="p">.</span><span class="n">borrow</span><span class="p">(),</span><span class="w"> </span><span class="n">file_name_no_ext</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">None</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">call_ffmpeg</span><span class="p">(</span><span class="n">src_name</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">tgt_name</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">child</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Command</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;ffmpeg&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">.</span><span class="n">args</span><span class="p">([</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="s">&#34;-i&#34;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">src_name</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="s">&#34;-ab&#34;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="s">&#34;320k&#34;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="s">&#34;-map_metadata&#34;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="s">&#34;0&#34;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="s">&#34;-id3v2_version&#34;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="s">&#34;3&#34;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">tgt_name</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">])</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">.</span><span class="n">stdout</span><span class="p">(</span><span class="n">Stdio</span>::<span class="n">null</span><span class="p">())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">.</span><span class="n">spawn</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;Failed to execute command&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ecode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">child</span><span class="p">.</span><span class="n">wait</span><span class="p">().</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;failed to wait on child&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">ecode</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">current_dir</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">env</span>::<span class="n">current_dir</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">current_dir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">current_dir</span><span class="p">.</span><span class="n">as_path</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;音乐转换器，请保证音乐文件在该脚本所在目录&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cin</span><span class="p">(</span><span class="s">&#34;输入模式，q退出，ls列出当前目录下某一拓展名的文件，r递归转换，nr非递归转换，o单文件转换&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">match</span><span class="w"> </span><span class="n">mode</span><span class="p">.</span><span class="n">to_lowercase</span><span class="p">().</span><span class="n">trim</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="s">&#34;ls&#34;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">ext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cin</span><span class="p">(</span><span class="s">&#34;输入要查看的拓展名&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">WalkDir</span>::<span class="n">new</span><span class="p">(</span><span class="n">current_dir</span><span class="p">).</span><span class="n">into_iter</span><span class="p">().</span><span class="n">for_each</span><span class="p">(</span><span class="o">|</span><span class="n">e</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                            </span><span class="kd">let</span><span class="w"> </span><span class="n">path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">path</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                            </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">((</span><span class="n">src_path</span><span class="p">,</span><span class="w"> </span><span class="n">_tgt_name</span><span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">path_match</span><span class="p">(</span><span class="n">path</span><span class="p">,</span><span class="w"> </span><span class="n">ext</span><span class="p">.</span><span class="n">trim</span><span class="p">(),</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                            </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">src_path</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">});</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="s">&#34;r&#34;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">ext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cin</span><span class="p">(</span><span class="s">&#34;输入待转换的拓展名&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">WalkDir</span>::<span class="n">new</span><span class="p">(</span><span class="n">current_dir</span><span class="p">).</span><span class="n">into_iter</span><span class="p">().</span><span class="n">for_each</span><span class="p">(</span><span class="o">|</span><span class="n">e</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                            </span><span class="kd">let</span><span class="w"> </span><span class="n">path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">path</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                            </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">((</span><span class="n">src_path</span><span class="p">,</span><span class="w"> </span><span class="n">tgt_name</span><span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">path_match</span><span class="p">(</span><span class="n">path</span><span class="p">,</span><span class="w"> </span><span class="n">ext</span><span class="p">.</span><span class="n">trim</span><span class="p">(),</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                </span><span class="n">call_ffmpeg</span><span class="p">(</span><span class="n">src_path</span><span class="p">,</span><span class="w"> </span><span class="n">tgt_name</span><span class="p">.</span><span class="n">as_str</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">});</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="s">&#34;nr&#34;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">ext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cin</span><span class="p">(</span><span class="s">&#34;输入待转换的拓展名&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">WalkDir</span>::<span class="n">new</span><span class="p">(</span><span class="n">current_dir</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="p">.</span><span class="n">max_depth</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="p">.</span><span class="n">into_iter</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="p">.</span><span class="n">for_each</span><span class="p">(</span><span class="o">|</span><span class="n">e</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                            </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                </span><span class="kd">let</span><span class="w"> </span><span class="n">path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">path</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">((</span><span class="n">src_path</span><span class="p">,</span><span class="w"> </span><span class="n">tgt_name</span><span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                    </span><span class="n">path_match</span><span class="p">(</span><span class="n">path</span><span class="p">,</span><span class="w"> </span><span class="n">ext</span><span class="p">.</span><span class="n">trim</span><span class="p">(),</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                    </span><span class="n">call_ffmpeg</span><span class="p">(</span><span class="n">src_path</span><span class="p">,</span><span class="w"> </span><span class="n">tgt_name</span><span class="p">.</span><span class="n">as_str</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="p">});</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="s">&#34;o&#34;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">filename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cin</span><span class="p">(</span><span class="s">&#34;输入待转换的文件名&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">WalkDir</span>::<span class="n">new</span><span class="p">(</span><span class="n">current_dir</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="p">.</span><span class="n">max_depth</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="p">.</span><span class="n">into_iter</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="p">.</span><span class="n">for_each</span><span class="p">(</span><span class="o">|</span><span class="n">e</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                            </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                </span><span class="kd">let</span><span class="w"> </span><span class="n">path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">path</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">((</span><span class="n">src_path</span><span class="p">,</span><span class="w"> </span><span class="n">tgt_name</span><span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                    </span><span class="n">path_match</span><span class="p">(</span><span class="n">path</span><span class="p">,</span><span class="w"> </span><span class="n">filename</span><span class="p">.</span><span class="n">trim</span><span class="p">(),</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                    </span><span class="n">call_ffmpeg</span><span class="p">(</span><span class="n">src_path</span><span class="p">,</span><span class="w"> </span><span class="n">tgt_name</span><span class="p">.</span><span class="n">as_str</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="p">});</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="s">&#34;q&#34;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">break</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;input not support&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="n">mode</span><span class="p">.</span><span class="n">trim</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&#34;123&#34;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;hi&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div>]]></content:encoded></item><item><title>“如意”的两种实现</title><link>https://livypad.github.io/post/2022-03-15-asyouwish/</link><pubDate>Tue, 15 Mar 2022 00:00:00 +0000</pubDate><guid>https://livypad.github.io/post/2022-03-15-asyouwish/</guid><description>“如意” 中文 “万事如意”其实可以有两种实现方式：可以是提出心意之后即时实现；也可以是提前预知会被提出的心意并提前准备好。后一种方式时间更加宽</description><content:encoded><![CDATA[<h1 id="如意">“如意”</h1>
<h2 id="中文">中文</h2>
<p>“万事如意”其实可以有两种实现方式：可以是提出心意之后即时实现；也可以是提前预知会被提出的心意并提前准备好。后一种方式时间更加宽松，对“灯神”能力需求可以降低。只要分支预测准确率足够高，提前准备带来的优势应该是可以超过偶发的预测失败以及维护一个预测器的额外代价（重新即时准备，旧的准备浪费）。所以说，“万事如意”的“灯神“不一定是神通广大，可能只是你太容易被 ta 理解。</p>
<h2 id="english">English</h2>
<p>In fact, &ldquo;as you wish“ can be accomplished in two different strategies, a genie can either fulfill ones&rsquo; dream or wish after its proposal, or it can predict that particular wish and prepare for it in advance. The latter strategy has a much looser time constraint on genie, therefore requiring less magic power. As long as branch predictor&rsquo;s accuracy is high enough, the advantage of prediction might outweigh the extra cost of maintaining the predictor and penalty of misprediction (former preparation becomes useless and the wish need to be fulfilled instantly). To draw a conclusion, a genie who promise to follow any order may not be extremely resourceful, instead, maybe you are too easy to understand and to be predicted.</p>
]]></content:encoded></item><item><title>IO效率与人</title><link>https://livypad.github.io/post/2022-02-20-ioeff/</link><pubDate>Sun, 20 Feb 2022 00:00:00 +0000</pubDate><guid>https://livypad.github.io/post/2022-02-20-ioeff/</guid><description>IO 效率与人 状态信息 Scales D J, Nelson M, Venkitachalam G. The design of a practical system for fault-tolerant virtual machines [J]. ACM SIGOPS Operating Systems Review, 2010, 44(4): 30–39. VMware 公司有一篇 VM-FT的论文，介绍了如何借助虚拟机技术，构建</description><content:encoded><![CDATA[<h1 id="io-效率与人">IO 效率与人</h1>
<h2 id="状态信息">状态信息</h2>
<blockquote>
<p>Scales D J, Nelson M, Venkitachalam G. The design of a practical system for fault-tolerant virtual machines [J]. ACM SIGOPS Operating Systems Review, 2010, 44(4): 30–39.</p>
</blockquote>
<p>VMware 公司有一篇 <strong>VM-FT</strong>的论文，介绍了如何借助虚拟机技术，构建一个主/从备份的容错系统。大部分计算机的指令是确定性的（deterministic），给定当前状态和指令，执行之后的状态是确定的。外界对内部的输入、产生随机数等少部分情况下，计算机执行是非确定性的（non-deterministic）。<strong>VM-FT</strong>论文的核心思想是通过虚拟机拦截下主机所有 non-deterministic 的指令，产生一个 log，通过网络发给从机，这样可以在完全不了解上层应用情况下，实现双机器运行任何软件的同步备份。这样依赖状态机的假设的方法存在一个问题，无法应对多核情况。多核执行时候的细微先后顺序是不能确定的，从而从相同状态和指令序列出发不能保证最后相同状态结果。</p>
<p>为了清晰传递自己的一个想法，自然希望能直接传递自己思想活动状态；别人直接“共情”我的思想活动，这是最容易理解的方式（？）；通过传递大量思考当中的细节（类比于指令），别人直接复现这些细节，相当于传递思想活动状态。但问题是人的大脑的神经元连接天然并行，比多核的执行顺序和并行度高的多的多；思考当中的各种补充细节，也相应的比指令序列多的多；表述这些细节，还需要自己加工成语言文字（即使这种直接表达思考细节，而不是构建成文章已经省略了很多文章结构的思考，语言文字的输出带宽还是比不上思想产生的速度）。VMware 最后似乎对于多核，还是放弃了状态机方法，回到传统的传 checkpoint 整体传状态。</p>
<blockquote>
<p>或许需要一个卡拉（？</p>
</blockquote>
<h2 id="传统书信的低带宽">传统书信的低带宽（？</h2>
<blockquote>
<p>为什么要在聊天时候发网页链接、屏幕截图？</p>
</blockquote>
<ul>
<li>为了可信，有出处可以溯源</li>
<li>为了避免讨论时候自己概括让对方先入为主</li>
<li>为了提供自己这边的输出带宽（？</li>
</ul>
<p>如果是我自己概括网页、截图内容，信息流动是<strong>网页/截图-&gt;信息理解-&gt;概括成语言文字-&gt;打字-&gt;对方理解语言文字</strong>；发链接和截图的话，信息流动是<strong>网页/截图-&gt;信息理解-&gt;发送链接/截图-&gt;对方理解网页/截图</strong>。阅读理解图文内容，并形成一个初步的感受印象和思考的速度很快，而且如前所说，思维里面可以顺序稍微模糊；但是如果需要再次概括输出，语言文字是线性的，需要考虑组织文字逻辑的问题。如果直接发链接/截图，可以跳过语言组织环节。</p>
<p>因此我莫名的害怕传统书信（？。现代的即时通讯工具即使加上能发链接/截图的优化，如前所述有时候还是不能匹配思维产生速度。如果媒介换成书信，只能使用语言文字，极高的延迟（？），那必然至少需要改变现在的交流模式。如果再碰上达西那种一封信不愿意多几张信纸写多几件事的家伙，那这个信息量就可想而知了。</p>
]]></content:encoded></item><item><title>王子游戏以及该游戏的不平衡性</title><link>https://livypad.github.io/post/2022-01-20-prince/</link><pubDate>Thu, 20 Jan 2022 00:00:00 +0000</pubDate><guid>https://livypad.github.io/post/2022-01-20-prince/</guid><description>王子游戏以及该游戏的不平衡性 规则 共有王子，公主和侍女（只能说真话的一边），皇后、女伯爵和侍卫（只能说假话的一边），男爵和牧师（可以任意选择说</description><content:encoded><![CDATA[<h1 id="王子游戏以及该游戏的不平衡性">王子游戏以及该游戏的不平衡性</h1>
<h2 id="规则">规则</h2>
<ul>
<li>共有王子，公主和侍女（只能说真话的一边），皇后、女伯爵和侍卫（只能说假话的一边），男爵和牧师（可以任意选择说真假话）</li>
<li>大家除了王子互相知晓彼此身份，王子对其他人身份都不知道</li>
<li>王子需要向其他人每人问一个问题，再问完全员之后，可以选择任意一人再问一个问题。问题必须从下列 3 个中选择，回答必须按照上述身份的规则给出：
<ol>
<li>你的身份是什么</li>
<li>指定的某人身份是什么</li>
<li>公主是谁</li>
</ol>
</li>
<li>问完所有问题，王子需要指定谁是公主，按下列情况结束游戏并判断胜负
<ol>
<li>王子指定的人是公主：王子、公主和侍女获胜</li>
<li>王子指定的人是皇后：皇后、女伯爵和侍卫获胜</li>
<li>王子指定的人既不是公主也不是皇后，而是其他任何身份：牧师和男爵获胜</li>
</ol>
</li>
</ul>
<h2 id="理想条件">理想条件</h2>
<p>在好人优势更大的情况下：</p>
<ul>
<li>可以无限次问问题</li>
<li>一个已知明牌的假话哥</li>
</ul>
<p>注意其中的可以无限次问问题的条件。该条件下，每个人对局面看法都是已知的，而且真话哥没有别的选择，<em><strong>唯一的变化来自于假话哥和胡话哥的配合</strong></em>。如果假话哥和胡话哥之间配合，能保证了两边局面完全对称，两边胜率完全平分，可以认为这样的策略是两边都能接受的策略。</p>
<h2 id="均衡的策略">均衡的策略</h2>
<p>3 组人分为 真话组、假话组、胡话组，组内部自称好侍女和公主。</p>
<p>明牌专说假话的人</p>
<ul>
<li>称自己是胡话哥（确实为假）</li>
<li>说别人三个组都是逆顺序的侍女和公主（逆了顺序，一定为假话）</li>
<li>公主在任意一组自称侍女的位置（逆了顺序，一定为假话）</li>
</ul>
<p>这样明牌说假话的人事实上王子从 ta 口中不能得到任何有用信息。</p>
<p>可能有以下两种可能性(<em>胡话组</em>用斜体，<strong>假话组</strong>是粗体)。第一种情况，<em>胡话组</em>和真话组对明牌假话人身份认同一致；第二种情况，<em>胡话组</em>和<strong>假话组</strong>对明牌假话人身份认同一致。两种情况对于王子绝对对称</p>
<ul>
<li>两个互称胡话的组，对明牌假话人意见一致</li>
<li>两个互称胡话的组，对剩下那个组都认为是假话组，且次序一致</li>
<li>必有一个组被其他两组认为是胡话组，且次序相反：注意到第 2 种情况，假话组由于要说假话，对胡话组判断和真话组对胡话组判断次序相反；所以第 1 种情况，胡话组和假话组对真话组下判断时，注意次序相反就行</li>
</ul>
<p>因此只有靠运气选组，也就是最后运气成分选到公主。</p>
<p><img loading="lazy" src="/assets/img/2022-01-20-1.png" alt="情形1"  />
</p>
<p><img loading="lazy" src="/assets/img/2022-01-20-2.png" alt="情形2"  />
</p>
<h2 id="运气成分">运气成分</h2>
<blockquote>
<p>概率计算不保证正确</p>
</blockquote>
<p>已知上述 2 种情况，真话组</p>
<ul>
<li>要么被 2 组同时认为是胡话且次序相反（此时被 2 组同时认为是假话的组是假话组）</li>
<li>要么被 2 组同时认为是假话（此时被 2 组同时认为是胡话的组是胡话组）</li>
</ul>
<p>所以王子理论胜率也只有抛硬币的 $50\%$ ，其他两组分享 $25\%$ 。在不理想条件下，王子理论胜率应该更低。</p>
]]></content:encoded></item><item><title>历史</title><link>https://livypad.github.io/post/2022-01-16-history/</link><pubDate>Sun, 16 Jan 2022 00:00:00 +0000</pubDate><guid>https://livypad.github.io/post/2022-01-16-history/</guid><description>学习历史 那些摆出一个多年前的某文章等材料，以当时多先进来批判当下多落后的，事实上绝大多数人也不会在提自己的观点时候搞详细的文献/历史综述（包</description><content:encoded><![CDATA[<h1 id="学习历史">学习历史</h1>
<p>那些摆出一个多年前的某文章等材料，以当时多先进来批判当下多落后的，事实上绝大多数人也不会在提自己的观点时候搞详细的文献/历史综述（包括现在的我）。这或许是某种程度上的双标。</p>
<p>对于大众而言，实在不可能指望有多少材料是真的能在当时普及的。即使别人看了材料能认同当中的观点，可是当年这材料很可能根本就没传播到 ta，然后现在拿出材料希望别人持有那样的观点。一边期待一个“冷门”材料被别人掌握，一边自己也不搞综述这种去广泛关注历史和掌握各种材料。这就是双标吧。</p>
<p>如果你只是偶然的从历史中学到一课，那么你没有资格指责别人偶然的没有学到过这一课；如果你系统的学习历史中得到这一课，那么请你拿出自己系统学习历史的证据，比如你搞过综述。所以事实上很多人（包括我）也没系统的学习历史（？），所以这可能就是为什么人类从历史中学到的最大的教训就是人类从不从历史中吸取教训（？</p>
]]></content:encoded></item><item><title>《长相思·山一程》 分析</title><link>https://livypad.github.io/post/2022-01-09-nostalgia/</link><pubDate>Sun, 09 Jan 2022 00:00:00 +0000</pubDate><guid>https://livypad.github.io/post/2022-01-09-nostalgia/</guid><description>《长相思·山一程》 分析 高中时候芳芳在赏析纳兰性德的《长相思·山一程》时，为了表现原词炼字功力，给出对比版本“风萧瑟，雪纷纷”。当时大家意见里</description><content:encoded><![CDATA[<h1 id="长相思山一程-分析">《长相思·山一程》 分析</h1>
<p>高中时候芳芳在赏析纳兰性德的《长相思·山一程》时，为了表现原词炼字功力，给出对比版本“风萧瑟，雪纷纷”。当时大家意见里（？，至少在我的印象中）反而认为修改版不是不能接受。而从现在的我看来，也认为反而修改版也很好，甚至可能好于原词。下面先给出原词：</p>
<blockquote>
<p>山一程，水一程，身向榆关那畔行，夜深千帐灯。</p>
<p>风一更，雪一更，聒碎乡心梦不成，故园无此声。</p>
</blockquote>
<p>我的观念中，对比原词和修改版，原词更加偏重于强调时长，修改版更加偏重于强调强度。而在整个下片考虑，强调强度应该优于强调时长。<br>
第一，从对人的情感激发能力来看，强度先于时长。极端情况下，只有时长没有强度，风雪只能“润物细无声”的话，词人只要不往外看风雪对 ta 都没什么影响，也谈不上接下来的感情波动；只有强度没有时长，雷声持续时间很短暂，但是只要几声雷声就能吓到胆小的小孩一时半会无法睡觉。下一句的“聒”字明显只能搭配上强度因素，而且由上所述，词人的“梦不成”更可能是被强度影响的结果。最后一句的“无此声”也可以解释为风雪声的强度的罕见。当然，也可以辩解时长很长的风雪在故园很罕见，这个问题在下一点中讨论。</p>
<p>第二，时长对人的影响，边际效果递减非常严重。具体到“梦不成”，也就是失眠的情景，长时间无法入睡，到底是 2 个小时（1 更的时间）还是 4 个小时（2 更的时间），区别并不是那么巨大。人在床上翻来覆去，想事情的情状并不因为时间多少几十分钟会有很大变化。所以在我看来，特意强调“一更”有点描写过度。真正有价值的信息只是知道时间很长，大家并不需要关心时间具体长度。</p>
<p>当然，还可以辩解说都数了“一更，一更”就暗示了强度大无法睡觉。但我认为，前面两点已经表现了，时长不如强度重要，所以牺牲时长，进一步特化描绘强度，更容易对应下文，反而可能艺术效果更好。</p>
<p>（失眠时长不那么重要，当然是因为这篇初稿就是我自己失眠躺床上偶然想到的，亲测不是很重要）</p>
]]></content:encoded></item><item><title>用生物拟人化</title><link>https://livypad.github.io/post/2021-10-30-creatureemotion/</link><pubDate>Sat, 30 Oct 2021 00:00:00 +0000</pubDate><guid>https://livypad.github.io/post/2021-10-30-creatureemotion/</guid><description>生物拟人 用某种非人生物概括人性格的理论（注意是概括不是描写，因为描写可以多 tag（？），这些理论一般都是映射关系），非常普遍，但这就很奇怪。</description><content:encoded><![CDATA[<h1 id="生物拟人">生物拟人</h1>
<p>用某种非人生物概括人性格的理论（注意是概括不是描写，因为描写可以多 tag（？），这些理论一般都是映射关系），非常普遍，但这就很奇怪。（这里指代的不仅是动物，furry 控什么的，也包含植物，比如比如花语，还有 hp 里面魔杖木材和巫师性格关系什么的）因为一般大家都认同人的性格复杂很多侧面。这样简单的概括即使能绝对覆盖很大，相对比例也是很可疑的。虽然这么干很简洁就是了。更何况，借用的非人生物特点，很少会考虑或者暗中体现演化亲缘关系。但显然演化近的一般共享特点也应该多一些（？。</p>
<p>即使认为这么干可以加速对陌生人性格的理解。但问题是，对于点头之交，花时间了解性格意义也不大（？；而大部分深入理解对面性格的场景，本来就是期待和对方长期相处下去，这时候还是准确性是更重要的。至于为啥要用人类本身解释世界，可能可以简单说是自大吧（？</p>
]]></content:encoded></item><item><title>[杂谈/胡说] 浅析七海灯子对喜欢的观念</title><link>https://livypad.github.io/post/2020-08-08-touko/</link><pubDate>Sat, 08 Aug 2020 00:00:00 +0000</pubDate><guid>https://livypad.github.io/post/2020-08-08-touko/</guid><description>[杂谈/胡说] 浅析七海灯子对喜欢的观念 声明 这只是笔者的个人观点，游戏之作。本意是换个说法理解原著的一些情节。和原作者/原作品/其他同人无关。</description><content:encoded><![CDATA[<h1 id="杂谈胡说-浅析七海灯子对喜欢的观念">[杂谈/胡说] 浅析七海灯子对喜欢的观念</h1>
<h2 id="声明">声明</h2>
<p>这只是笔者的个人观点，游戏之作。本意是换个说法理解原著的一些情节。和原作者/原作品/其他同人无关。分析基于笔者的个人看法，如有谬误，敬请斧正。</p>
<p>本文中说的爱/爱情/喜欢 etc.这些词汇，没有特殊说明，狭义的指代人对人的感情。</p>
<h2 id="绝对的爱">绝对的爱（？</h2>
<p>在讨论作品之前，先考虑一个问题：</p>
<p>（在指定对象后，）是否有绝对的爱？</p>
<p>这个问题可能比较奇怪，比较难回答。回答可能也比较个人化，比较见仁见智。那么，不妨换一个更清晰的问题：</p>
<p>是否 <em><strong>应当</strong></em> 有绝对的爱？</p>
<p>这个问题简单多了。爱情确实重要，但人不止要考虑爱，还要考虑国家，社会，亲情友情（暂时将爱限定于爱情）。那么，最极端的情况下，如果爱人杀人放火吸毒出轨等等无恶不作，从基本的社会道德出发，都不应‘该继续爱 ta。或者换个不是那么极端的例子，职业道德要求，老师和学生是不应该谈恋爱的（这个主要是考虑老师拥有隐含的优势地位，而且潜在的对其他学生不公平）。那么，喜欢其实是有条件性的。</p>
<h2 id="灯子的观念">灯子的观念</h2>
<p>在原著中，开始时候的灯子的爱情观念，如下引文（出自漫画第 10 话，大意如此）。</p>
<blockquote>
<p>“喜欢这样的你”什么的，不就是“你若不再是这样，就不会再喜欢你了”这个意思吗？</p>
<p>“喜欢”是用来束缚的词语</p>
</blockquote>
<p>这样的理论其实是有一定合理性的。本质上，这个理论其实也和上面讨论一样，反对一般观念里面爱的绝对性和崇高性，指出爱的条件性。换个表述。一般的观念是</p>
<p>$$
p(喜欢|对方是对方)
$$</p>
<p>而现在我们已经意识到爱是有条件的。</p>
<p>$$
p(喜欢|对方是对方，对方的行为)
$$</p>
<h2 id="作品发展后的观念">作品发展后的观念</h2>
<p>在先前对原作者的采访中，仲谷老师被问及 ta 本人的对喜欢的观念，老师表示不能透露，因为不能剧透作品的结尾。可以注意到作品在后期，沙弥香对灯子说的一番话，促进了灯子的转变。我们不妨认为这段话反映了作品（以及老师自己）的观念出自漫画第 10 话，大意如此）。</p>
<blockquote>
<p>…并不是说你不像现在这样就不可以，也不说你变得怎样都无所谓。所以怎么说呢……</p>
<p>我相信你会一直是我喜欢的样子。我认为喜欢更多是一种信赖，吧。</p>
</blockquote>
<p>（似乎看上去正常了很多）</p>
<p>其实这里可以发现，比较正常的爱情观念，同样也是排斥绝对的爱，而承认了喜欢的条件性。而灯子前期观念实际扭曲的点在于，ta 把喜欢里面的条件看的过分苛刻了。只有少数的，极其集中的行为对应较高的喜欢。不恰当的说，犹如 Dirac $\delta$函数。</p>
<p><img loading="lazy" src="/assets/img/delta%20func.png" alt="delta函数"  />
</p>
<p>而一般意义下，喜欢的条件宽泛许多。在一定范围内都是“高原”：虽然可能因为某些具体行为会有上下波动（比如一些摩擦会影响双方关系一类的），但一般来说都能保持在一个比较高的范围里面。这样的喜欢才是世间常态。</p>
<h2 id="后话">后话</h2>
<p>这篇杂谈起源于，笔者有次偶然思考灯子的观念，ta 的观点乍一眼其实是有一定道理的。仔细思考后发现其实可以直接依靠条件强弱说明。笔者的思考和本文其实选择了概率论，贝叶斯公式的视角。从贝叶斯的角度，先验的喜欢，在对方行为变化后，结合自己的条件喜欢，得到后验的喜欢。至少对笔者，这套语言更加清晰，更简单。</p>
<p>这个模型还可以有个现实应用（？）。虽然前文中指出，大部分人的条件喜欢的分布不如前期灯子观念中那样极端，边缘问题仍然存在。所谓的忠诚度测试，经典的情景双难问题（比如落水），就是在测试边缘情况。所谓的分歧，其实就是问题选择挂在喜欢概率“陡坡”处。</p>
<p>如果继续推广，可能，人们的喜欢实际上可以改成</p>
<p>$$
p(喜欢|某人的特征和行为)
$$</p>
<p>这某种意义上会导出<a href="https://what-if.xkcd.com/9/">what if 第九期知心爱人</a>里面引用的歌词所表达的，理论上，（在可能的平行世界里面），爱上其他人，生活也还行。</p>
<blockquote>
<p>But of the 9.999 hundred thousand other loves,</p>
<p>Statistically, some of them would be equally nice.</p>
</blockquote>
<p>这确实是个悲伤的，却又看起来正确性挺高的推论。(-_-)（By the way，仲谷老师的《月哭》结尾大概也有类似的悲伤）</p>
]]></content:encoded></item><item><title>VS Code，All in One（3）——v0.1.2</title><link>https://livypad.github.io/post/2020-06-23-vsc3/</link><pubDate>Tue, 23 Jun 2020 00:00:00 +0000</pubDate><guid>https://livypad.github.io/post/2020-06-23-vsc3/</guid><description>VS Code 以及其他的安利向（3）-LaTex LaTex 本身有一定的复杂性和学习门槛。在本文中，笔者尝试走一条特殊的思路写这个教程。这也是笔者自己学会 LaTex 的道</description><content:encoded><![CDATA[<h1 id="vs-code-以及其他的安利向3-latex">VS Code 以及其他的安利向（3）-LaTex</h1>
<p>LaTex 本身有一定的复杂性和学习门槛。在本文中，笔者尝试走一条特殊的思路写这个教程。这也是笔者自己学会 LaTex 的道路。但这条道路是不能覆盖 LaTex 的方方面面（笔者自己也没学会）。所以实在遇到问题，除了联系笔者增补教程，还可以求助搜索引擎。再次复习一下这个系列文章的宗旨：</p>
<p><strong>搜索引擎是最好的老师，不会的需求，直接去查询，学好</strong></p>
<p>本文的大概思路<strong>安装环境-&gt;学会数学语法-&gt;从模板学习 LaTex</strong></p>
<p>笔者会提供一个现成的可用的 Latex 源代码。在这个基础上就能编译出自己的文档了。需要的更多功能可以在之后通过搜索引擎学习。</p>
<h2 id="何为-latex">何为 LaTex</h2>
<p>相比如 markdown 这样的简单标记语言，latex 是一套更完整，复杂的标记语言+排版系统。优点有：</p>
<ol>
<li>LaTex 有极其发达的数学公式支持。支持自动编号，全文引用（可以有链接跳转）等等特性。LaTex 的数学公式语法被 markdown 和 word 自带的插入公式借用，所以说至少学习 LaTex 后，使用 word 的公式功能也更方便。</li>
<li>相比 word 所见即所得，虽然 word 也有样式等功能，LaTex 容易实现排版和内容分离。这一点还使得 LaTex 方便切换主题。内容不变可以输出排版不一样的文档。</li>
<li>bibTex 可以实现极其方便的引用文献处理。</li>
<li>LaTex 还有比如 tikz 宏包，可以直接实现简单的画图功能。</li>
</ol>
<h2 id="安装-latex-发行版">安装 LaTex 发行版</h2>
<p>发行版就是基于 LaTex 语言的编译器等等打包好的可以用的软件。根据很多大佬们的说法，CTex 套装已经非常老旧，其中配套的 WinEdt 其实是一个收费软件。我们这个教程不准备使用这个套装，而是选择 Tex Live。</p>
<p>Tex Live 可以在<a href="https://mirrors.tuna.tsinghua.edu.cn/#">Tuna（清华大学开源镜像站）</a>上下载镜像，这样速度比从国外下载会快很多。在右侧，“获取下载链接”-&gt;“应用软件”-&gt;“Tex 排版系统”-&gt;“Tex Live2020”。单击即可下载一个 iso 压缩包。</p>
<p><strong>警告，Tex Live 压缩包大概有 4GB，注意网速和流量</strong></p>
<p>解压该文件，以管理员身份（在右键文件后在菜单里选择），打开 install-tl-windows.bat 文件。这个是个自动安装脚本，如果没有特别的比如空间要求，建议可以直接“下一步”到底。全部安装，注意勾选添加到环境变量</p>
<p><strong>警告，Tex Live 安装好大概会有 8GB 大小，安装需要一定时间，请耐心等待</strong></p>
<p>Tex Live 会自带一个 Texworks Editor，也可以用来写 LaTex。但我们这个系列一切基于 VS Code。</p>
<h2 id="配置-vs-code">配置 VS Code</h2>
<p>在插件市场搜索下载插件 LaTex Workshop。这个插件基本就能帮助完成所有 LaTex 相关的任务。</p>
<p>进入设置界面。点击右上角“打开设置（JSON）”，粘贴以下设置。虽然这是个快速上手向教程，但还是建议仔细阅读这些设置的注释，尽量理解这些设置的含义。</p>
<p>写 LaTex 在 VS Code 中新建一个 <strong>英文标题（防止中文不支持）.tex</strong> 文件就能开始编写了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="s2">&#34;latex-workshop.latex.autoBuild.run&#34;</span><span class="err">:</span> <span class="s2">&#34;never&#34;</span><span class="err">,</span>
</span></span><span class="line"><span class="cl"><span class="c1">//可选默认是onFileChange，改写了文件会自动编译，可以改成never，手动编译
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="s2">&#34;latex-workshop.message.error.show&#34;</span><span class="err">:</span> <span class="kc">false</span><span class="err">,</span><span class="c1">//可选，不显示错误信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="s2">&#34;latex-workshop.message.warning.show&#34;</span><span class="err">:</span> <span class="kc">false</span><span class="err">,</span><span class="c1">//可选，不显示警告信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="s2">&#34;latex-workshop.latex.tools&#34;</span><span class="err">:</span> <span class="p">[</span><span class="c1">//必须有
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;xelatex&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&#34;command&#34;</span><span class="p">:</span> <span class="s2">&#34;xelatex&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&#34;args&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">                <span class="s2">&#34;-synctex=1&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="s2">&#34;-interaction=nonstopmode&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="s2">&#34;-file-line-error&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="s2">&#34;-pdf&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="s2">&#34;%DOCFILE%&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;pdflatex&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&#34;command&#34;</span><span class="p">:</span> <span class="s2">&#34;pdflatex&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&#34;args&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">                <span class="s2">&#34;-synctex=1&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="s2">&#34;-interaction=nonstopmode&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="s2">&#34;-file-line-error&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="s2">&#34;%DOCFILE%&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;bibtex&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&#34;command&#34;</span><span class="p">:</span> <span class="s2">&#34;bibtex&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&#34;args&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">                <span class="s2">&#34;%DOCFILE%&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">]</span><span class="err">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;latex-workshop.latex.recipes&#34;</span><span class="err">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;xelatex&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//xelatex编译一遍，一般的Latex文档这样编译
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//xelatex不支持中文标题！！！！
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nt">&#34;tools&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">                <span class="s2">&#34;xelatex&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;xe-&gt;bib-&gt;xe-&gt;xe&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//需要bibTex的文档，用于有bib文件引用的LAtex文档
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nt">&#34;tools&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">                <span class="s2">&#34;xelatex&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="s2">&#34;bibtex&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="s2">&#34;xelatex&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="s2">&#34;xelatex&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;xe-&gt;xe-&gt;xe&#34;</span><span class="p">,</span><span class="c1">//Latex文档内部有交叉引用时候这样编译
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nt">&#34;tools&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">                <span class="s2">&#34;xelatex&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="s2">&#34;xelatex&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="s2">&#34;xelatex&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;pdflatex&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//换一个编译器，一般来说xelatex对中文等支持更好，这个选项以备万一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//pdflatex可以支持中文标题
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nt">&#34;tools&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">                <span class="s2">&#34;pdflatex&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;pdf-&gt;bib-&gt;pdf-&gt;pdf&#34;</span><span class="p">,</span><span class="c1">//同上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nt">&#34;tools&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">                <span class="s2">&#34;pdflatex&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="s2">&#34;bibtex&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="s2">&#34;pdflatex&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="s2">&#34;pdflatex&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">]</span><span class="err">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;latex-workshop.latex.clean.fileTypes&#34;</span><span class="err">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//tex文件编译会有一些辅助软件，可以靠这个设置清理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="s2">&#34;*.aux&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;*.bbl&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;*.blg&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;*.idx&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;*.ind&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;*.lof&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;*.lot&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;*.out&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;*.toc&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;*.acn&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;*.acr&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;*.alg&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;*.glg&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;*.glo&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;*.gls&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;*.ist&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;*.fls&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;*.log&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;*.fdb_latexmk&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;*.gz&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">]</span><span class="err">,</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="latex-数学公式相关-a-语法">LaTex 数学公式相关 a 语法</h2>
<p>这个是 LaTex 最精华的一部分，建议至少学会这个部分。这一部分的知识也可以用于 markdown 文档编写。</p>
<p>首先，LaTex 语法一般来说，如果是英文字母描述的命令，使用\开头。\也可以用作一些特殊符号的转义，比如%是 LaTex 的注释符号，如果需要打出%本身，可以打%，作为一个整体表示百分号。</p>
<p>Latex 里面使用<code>\begin{}\end{}</code>来给出环境。</p>
<h3 id="基本符号">基本符号</h3>
<ol>
<li>指数^，下标_，如果不止一个字母/数字的上下标，用{}括起来</li>
<li>\frac{}{} 分数</li>
<li>\sqrt{} 平方根</li>
<li>\partial 偏导数</li>
<li>\ +希腊字母的名字输出希腊字母，例如\alpha 输出$\alpha$</li>
<li>\int 积分，\sum 求和，\lim 极限，\prod 连乘，^_用来表示上下限，和上下标含义一样。</li>
<li>\approx 约等于，\neq 不等号，\geq 大于等于，\leq 小于等于</li>
<li>\mathrm{}在数学公式里面输入正体，用于输入单位等。\mathbb{}花体字$\mathbb{N}$</li>
<li>\left( \right)左右大括号，这些符号必须成对使用。同理可以比如{[等，\right.表示空白。</li>
</ol>
<h3 id="数学公式环境">数学公式环境</h3>
<ol>
<li>单独的$括起来，是无编号行内公式。</li>
<li>连着两个$，之间括起来，编号好的行间公式</li>
<li><code>\begin{equation} \end{equation}</code> 之间括起来的是编号的行间公式</li>
</ol>
<h3 id="公式对齐">公式对齐</h3>
<p>上述的环境只能支持一行的公式。如果比如需要写出连等式子，可以在数学环境（上面的 2，3 条）里面使用<code>\begin{aligned} \end{aligned}</code>。在中间的数学公式就可以实现对齐。</p>
<p>&amp;是对齐符号，每行的&amp;会自动对齐，连等式子一般写成&amp;=。两个\是换行符，表示不同行公式之间的换行。</p>
<p>使用<code>\left{\right.</code>在数学环境和<code>\begin{aligned} \end{aligned}</code>，可以实现多条公式前面有个大括号括起来。</p>
<h3 id="数学公式范例">数学公式范例</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-latex" data-lang="latex"><span class="line"><span class="cl"><span class="c">%注意这里面用到了公式环境，对齐，上下标，分号，根号，大括号
</span></span></span><span class="line"><span class="cl"><span class="c"></span> <span class="k">\begin</span><span class="nb">{</span>equation<span class="nb">}</span><span class="c">%公式环境
</span></span></span><span class="line"><span class="cl"><span class="c"></span>    <span class="k">\left\{</span>
</span></span><span class="line"><span class="cl">    <span class="c">%大括号~
</span></span></span><span class="line"><span class="cl"><span class="c"></span>    <span class="k">\begin</span><span class="nb">{</span>aligned<span class="nb">}</span><span class="c">%对齐
</span></span></span><span class="line"><span class="cl"><span class="c"></span>         <span class="nb">&amp;</span> <span class="k">\mu</span><span class="nb">_</span>L=<span class="k">\frac</span><span class="nb">{</span>e<span class="nb">}{</span>2m<span class="nb">}</span>P<span class="nb">_</span>L=<span class="k">\frac</span><span class="nb">{</span>e<span class="nb">}{</span>2m<span class="nb">}</span><span class="k">\sqrt</span><span class="nb">{</span>L(L+1)<span class="nb">}</span><span class="k">\frac</span><span class="nb">{</span>h<span class="nb">}{</span>2<span class="k">\pi</span><span class="nb">}</span> <span class="k">\\</span>
</span></span><span class="line"><span class="cl">         <span class="nb">&amp;</span> <span class="k">\mu</span><span class="nb">_</span>s=<span class="k">\frac</span><span class="nb">{</span>e<span class="nb">}{</span>m<span class="nb">}</span>P<span class="nb">_</span>s=<span class="k">\frac</span><span class="nb">{</span>e<span class="nb">}{</span>m<span class="nb">}</span><span class="k">\sqrt</span><span class="nb">{</span>S(S+1)<span class="nb">}</span><span class="k">\frac</span><span class="nb">{</span>h<span class="nb">}{</span>2<span class="k">\pi</span><span class="nb">}</span>   <span class="k">\\</span>
</span></span><span class="line"><span class="cl">    <span class="k">\end</span><span class="nb">{</span>aligned<span class="nb">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">\right</span>.<span class="c">%与left成对
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="k">\end</span><span class="nb">{</span>equation<span class="nb">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>显示效果</p>
<p><img loading="lazy" src="/assets/img/vsctex2.jpg" alt="显示效果"  />
</p>
<h2 id="latex-文章模板">LaTex 文章模板</h2>
<p>这个版本是已经可以使用的。建议仔细阅读文档里面的注释，尽量理解含义。（这样您的 LaTex 就已经能走上正路了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-latex" data-lang="latex"><span class="line"><span class="cl"><span class="k">\documentclass</span><span class="na">[UTF8]</span><span class="nb">{</span>ctexart<span class="nb">}</span><span class="c">%文档宏观定义
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="k">\usepackage</span><span class="nb">{</span>lmodern<span class="nb">}</span><span class="c">%导入宏包，LaTex导入宏包多次不会报错，所以可以随便复制粘贴宏包，即使不需要
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="k">\usepackage</span><span class="nb">{</span>amssymb<span class="nb">}</span>
</span></span><span class="line"><span class="cl"><span class="k">\usepackage</span><span class="nb">{</span>amsmath<span class="nb">}</span>
</span></span><span class="line"><span class="cl"><span class="k">\usepackage</span><span class="nb">{</span>graphicx<span class="nb">}</span>
</span></span><span class="line"><span class="cl"><span class="k">\usepackage</span><span class="nb">{</span>float<span class="nb">}</span>
</span></span><span class="line"><span class="cl"><span class="k">\usepackage</span><span class="nb">{</span>adjustbox<span class="nb">}</span>
</span></span><span class="line"><span class="cl"><span class="k">\usepackage</span><span class="nb">{</span>geometry<span class="nb">}</span>
</span></span><span class="line"><span class="cl"><span class="k">\usepackage</span><span class="nb">{</span>fullpage<span class="nb">}</span>
</span></span><span class="line"><span class="cl"><span class="k">\usepackage</span><span class="nb">{</span>longtable<span class="nb">}</span>
</span></span><span class="line"><span class="cl"><span class="k">\usepackage</span><span class="nb">{</span>booktabs<span class="nb">}</span>
</span></span><span class="line"><span class="cl"><span class="k">\usepackage</span><span class="nb">{</span>tikz<span class="nb">}</span>
</span></span><span class="line"><span class="cl"><span class="k">\usepackage</span><span class="nb">{</span>listings<span class="nb">}</span>
</span></span><span class="line"><span class="cl"><span class="k">\usepackage</span><span class="nb">{</span>xcolor<span class="nb">}</span>
</span></span><span class="line"><span class="cl"><span class="k">\usepackage</span><span class="nb">{</span>subfigure<span class="nb">}</span>
</span></span><span class="line"><span class="cl"><span class="k">\lstset</span><span class="nb">{</span>
</span></span><span class="line"><span class="cl">      <span class="c">%背景框
</span></span></span><span class="line"><span class="cl"><span class="c"></span>      framexleftmargin=10mm,
</span></span><span class="line"><span class="cl">      frame=none,
</span></span><span class="line"><span class="cl">     <span class="c">%背景色
</span></span></span><span class="line"><span class="cl"><span class="c"></span>     <span class="c">%backgroundcolor=\color[rgb]{1,1,0.76},
</span></span></span><span class="line"><span class="cl"><span class="c"></span>     backgroundcolor=<span class="k">\color</span><span class="na">[RGB]</span><span class="nb">{</span>245,245,244<span class="nb">}</span>,
</span></span><span class="line"><span class="cl">    <span class="c">%样式
</span></span></span><span class="line"><span class="cl"><span class="c"></span>    keywordstyle=<span class="k">\bf\color</span><span class="nb">{</span>blue<span class="nb">}</span>,
</span></span><span class="line"><span class="cl">     identifierstyle=<span class="k">\bf</span>,
</span></span><span class="line"><span class="cl">     numberstyle=<span class="k">\color</span><span class="na">[RGB]</span><span class="nb">{</span>0,192,192<span class="nb">}</span>,
</span></span><span class="line"><span class="cl">     commentstyle=<span class="k">\it\color</span><span class="na">[RGB]</span><span class="nb">{</span>0,96,96<span class="nb">}</span>,
</span></span><span class="line"><span class="cl">     stringstyle=<span class="k">\rmfamily\slshape\color</span><span class="na">[RGB]</span><span class="nb">{</span>128,0,0<span class="nb">}</span>,  <span class="c">%显示空格
</span></span></span><span class="line"><span class="cl"><span class="c"></span>     showstringspaces=false
</span></span><span class="line"><span class="cl"> <span class="nb">}</span>
</span></span><span class="line"><span class="cl"><span class="k">\newcommand*</span><span class="nb">{</span><span class="k">\de</span><span class="nb">}{^</span><span class="k">\circ\hspace</span><span class="nb">{</span>-0.09em<span class="nb">}}</span>
</span></span><span class="line"><span class="cl"><span class="c">%温度
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="k">\newcommand*</span><span class="nb">{</span><span class="k">\dif</span><span class="nb">}{</span><span class="k">\mathop</span><span class="nb">{}</span><span class="k">\!\mathrm</span><span class="nb">{</span>d<span class="nb">}}</span>
</span></span><span class="line"><span class="cl"><span class="c">%导数的d
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="k">\newcommand*</span><span class="nb">{</span><span class="k">\e</span><span class="nb">}</span>[1]<span class="nb">{</span><span class="k">\times</span> 10<span class="nb">^{</span>#1<span class="nb">}}</span>
</span></span><span class="line"><span class="cl"><span class="c">%\e{}用来表示科学计数法
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="k">\newcommand*</span><span class="nb">{</span><span class="k">\celsius</span><span class="nb">}{</span><span class="k">\ensuremath</span><span class="nb">{^</span><span class="k">\circ\hspace</span><span class="nb">{</span>-0.09em<span class="nb">}</span><span class="k">\mathrm</span><span class="nb">{</span>C<span class="nb">}}}</span>
</span></span><span class="line"><span class="cl"><span class="c">%摄氏度
</span></span></span><span class="line"><span class="cl"><span class="c"></span>
</span></span><span class="line"><span class="cl"><span class="k">\ctexset</span><span class="nb">{</span>
</span></span><span class="line"><span class="cl">section = <span class="nb">{</span>
</span></span><span class="line"><span class="cl">format = <span class="k">\raggedright\large\bfseries</span>,
</span></span><span class="line"><span class="cl"><span class="nb">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">\title</span><span class="nb">{}</span><span class="c">%标题
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="k">\author</span><span class="nb">{}</span><span class="c">%作者名
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="k">\date</span><span class="nb">{</span><span class="k">\today</span><span class="nb">}</span><span class="c">%自动生成今天日期
</span></span></span><span class="line"><span class="cl"><span class="c"></span>
</span></span><span class="line"><span class="cl"><span class="k">\geometry</span><span class="nb">{</span>hcentering<span class="nb">}</span>
</span></span><span class="line"><span class="cl"><span class="k">\textwidth</span> 16cm<span class="c">%文章页面宽度
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="k">\linespread</span><span class="nb">{</span>1<span class="nb">}</span>
</span></span><span class="line"><span class="cl"><span class="k">\setCJKmainfont</span><span class="nb">{</span>Microsoft YaHei<span class="nb">}</span>
</span></span><span class="line"><span class="cl"><span class="c">%设置字体
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="k">\begin</span><span class="nb">{</span>document<span class="nb">}</span><span class="c">%文章开头
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="k">\maketitle</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">\begin</span><span class="nb">{</span>enumerate<span class="nb">}</span><span class="c">%有序列表
</span></span></span><span class="line"><span class="cl"><span class="c"></span>    <span class="k">\item</span> <span class="c">%每一项以此引起
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="k">\end</span><span class="nb">{</span>enumerate<span class="nb">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">\begin</span><span class="nb">{</span>itemize<span class="nb">}</span>无序列表
</span></span><span class="line"><span class="cl">    <span class="k">\item</span><span class="c">%每一项以此引起
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="k">\end</span><span class="nb">{</span>itemize<span class="nb">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">\section</span><span class="nb">{}</span><span class="c">%一级标题，编号
</span></span></span><span class="line"><span class="cl"><span class="c"></span>
</span></span><span class="line"><span class="cl"><span class="k">\section*</span><span class="nb">{}</span><span class="c">%一级标题，不编号
</span></span></span><span class="line"><span class="cl"><span class="c"></span>
</span></span><span class="line"><span class="cl"><span class="k">\subsection</span><span class="nb">{}</span><span class="c">%二级标题，编号
</span></span></span><span class="line"><span class="cl"><span class="c"></span>
</span></span><span class="line"><span class="cl"><span class="k">\subsection*</span><span class="nb">{}</span><span class="c">%二级标题，不编号
</span></span></span><span class="line"><span class="cl"><span class="c"></span>
</span></span><span class="line"><span class="cl"><span class="k">\subsubsection</span><span class="nb">{}</span><span class="c">%三级标题，编号
</span></span></span><span class="line"><span class="cl"><span class="c"></span>
</span></span><span class="line"><span class="cl"><span class="k">\subsubsection*</span><span class="nb">{}</span><span class="c">%三级标题，不编号
</span></span></span><span class="line"><span class="cl"><span class="c"></span>
</span></span><span class="line"><span class="cl"><span class="k">\begin</span><span class="nb">{</span>figure<span class="nb">}</span>[H]<span class="c">%插入图片
</span></span></span><span class="line"><span class="cl"><span class="c"></span>    <span class="k">\centering</span><span class="c">%居中
</span></span></span><span class="line"><span class="cl"><span class="c"></span>    <span class="k">\includegraphics</span><span class="na">[height=12cm,width=0.6\linewidth]</span><span class="nb">{</span>5pic1.jpg<span class="nb">}</span>
</span></span><span class="line"><span class="cl">    <span class="c">%插入图片，方括号是调整大小，大括号是图片相对路径名，如果tex文件和图片在同一个文件夹下，可以直接写名字
</span></span></span><span class="line"><span class="cl"><span class="c"></span>    <span class="k">\caption</span><span class="nb">{}</span><span class="c">%描述名字
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="k">\end</span><span class="nb">{</span>figure<span class="nb">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">\begin</span><span class="nb">{</span>figure<span class="nb">}</span>[H]<span class="c">%多图片
</span></span></span><span class="line"><span class="cl"><span class="c"></span>    <span class="k">\centering</span>
</span></span><span class="line"><span class="cl">    <span class="k">\subfigure</span><span class="na">[title]</span><span class="c">%多图片的图片名
</span></span></span><span class="line"><span class="cl"><span class="c"></span>    <span class="nb">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">\begin</span><span class="nb">{</span>minipage<span class="nb">}</span>[t]<span class="nb">{</span>0.5<span class="k">\linewidth</span><span class="nb">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">\centering</span>
</span></span><span class="line"><span class="cl">            <span class="k">\includegraphics</span><span class="na">[width=\linewidth]</span><span class="nb">{</span>5pic3.jpg<span class="nb">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">\end</span><span class="nb">{</span>minipage<span class="nb">}</span><span class="c">%
</span></span></span><span class="line"><span class="cl"><span class="c"></span>    <span class="nb">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">\subfigure</span><span class="na">[]</span><span class="c">%多图片的图片名
</span></span></span><span class="line"><span class="cl"><span class="c"></span>    <span class="nb">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">\begin</span><span class="nb">{</span>minipage<span class="nb">}</span>[t]<span class="nb">{</span>0.5<span class="k">\linewidth</span><span class="nb">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">\centering</span>
</span></span><span class="line"><span class="cl">           <span class="k">\includegraphics</span><span class="na">[width=\linewidth]</span><span class="nb">{</span>5pic4.jpg<span class="nb">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">\end</span><span class="nb">{</span>minipage<span class="nb">}</span><span class="c">%
</span></span></span><span class="line"><span class="cl"><span class="c"></span>    <span class="nb">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">\centering</span>
</span></span><span class="line"><span class="cl"><span class="k">\end</span><span class="nb">{</span>figure<span class="nb">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">\begin</span><span class="nb">{</span>lstlisting<span class="nb">}</span>[language=c]
</span></span><span class="line"><span class="cl"><span class="c">%代码框，language选择语言
</span></span></span><span class="line"><span class="cl"><span class="c"></span>    xx[j] = xx[j - 1] + d * vv[j - 1];
</span></span><span class="line"><span class="cl"><span class="k">\end</span><span class="nb">{</span>lstlisting<span class="nb">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">\end</span><span class="nb">{</span>document<span class="nb">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这个基础上删改就能编译出一篇好看的 pdf 文档了。</p>
<h2 id="表格">表格</h2>
<p>或许读者已经注意到，我给出的模板没有涉及表格。表格很重要，但是表格的语法比较复杂。这里笔者给出一个简单的解决方案<a href="https://www.ctan.org/tex-archive/support/excel2latex/">Excel2LaTex</a>。这是一个 excel 的宏文件。使用时启动加载，框选现成的 excel 表格部分，点击“加载项”里面的 Convert table to latex，就能自动生成 LaTex 的表格代码。</p>
<p><img loading="lazy" src="/assets/img/vsctex1.jpg" alt="excel2latex"  />
</p>
<p>这样会自动生成这样的 LaTex 代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-latex" data-lang="latex"><span class="line"><span class="cl"> <span class="c">% Table generated by Excel2LaTeX from sheet &#39;Sheet1&#39;
</span></span></span><span class="line"><span class="cl"><span class="c"></span> <span class="k">\begin</span><span class="nb">{</span>table<span class="nb">}</span>[htbp]
</span></span><span class="line"><span class="cl">   <span class="k">\centering</span>
</span></span><span class="line"><span class="cl">   <span class="k">\caption</span><span class="nb">{</span>Add caption<span class="nb">}</span>
</span></span><span class="line"><span class="cl">     <span class="k">\begin</span><span class="nb">{</span>tabular<span class="nb">}{</span>ccc<span class="nb">}</span>
</span></span><span class="line"><span class="cl">     C光 <span class="nb">&amp;</span> d光 <span class="nb">&amp;</span> F光 <span class="k">\\</span>
</span></span><span class="line"><span class="cl">     1.4 <span class="nb">&amp;</span> 1.5 <span class="nb">&amp;</span> 1.55 <span class="k">\\</span>
</span></span><span class="line"><span class="cl">     1.9 <span class="nb">&amp;</span> 2 <span class="nb">&amp;</span> 2.1 <span class="k">\\</span>
</span></span><span class="line"><span class="cl">     <span class="k">\end</span><span class="nb">{</span>tabular<span class="nb">}</span><span class="c">%
</span></span></span><span class="line"><span class="cl"><span class="c"></span>   <span class="k">\label</span><span class="nb">{</span>tab:addlabel<span class="nb">}</span><span class="c">%
</span></span></span><span class="line"><span class="cl"><span class="c"></span> <span class="k">\end</span><span class="nb">{</span>table<span class="nb">}</span><span class="c">%
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这样的表格一般来说不尽如人意，笔者喜欢修改一些设置。注意对比不同点和阅读注释</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-latex" data-lang="latex"><span class="line"><span class="cl"> <span class="k">\begin</span><span class="nb">{</span>table<span class="nb">}</span>[H]<span class="c">%大写H可以让表格一路排版下来，位置不浮动
</span></span></span><span class="line"><span class="cl"><span class="c"></span>   <span class="k">\centering</span><span class="c">%居中
</span></span></span><span class="line"><span class="cl"><span class="c"></span>     <span class="k">\begin</span><span class="nb">{</span>tabular<span class="nb">}{</span>ccc<span class="nb">}</span>
</span></span><span class="line"><span class="cl">     <span class="k">\toprule</span><span class="c">%插入分割线
</span></span></span><span class="line"><span class="cl"><span class="c"></span>     C光 <span class="nb">&amp;</span> d光 <span class="nb">&amp;</span> F光 <span class="k">\\</span>
</span></span><span class="line"><span class="cl">     <span class="k">\midrule</span><span class="c">%插入分割线
</span></span></span><span class="line"><span class="cl"><span class="c"></span>     1.4 <span class="nb">&amp;</span> 1.5 <span class="nb">&amp;</span> 1.55 <span class="k">\\</span>
</span></span><span class="line"><span class="cl">     1.9 <span class="nb">&amp;</span> 2 <span class="nb">&amp;</span> 2.1 <span class="k">\\</span>
</span></span><span class="line"><span class="cl">     <span class="k">\bottomrule</span><span class="c">%插入分割线
</span></span></span><span class="line"><span class="cl"><span class="c"></span>     <span class="c">%这三个rule可以生成三线表格，比较学术化，美观
</span></span></span><span class="line"><span class="cl"><span class="c"></span>     <span class="k">\end</span><span class="nb">{</span>tabular<span class="nb">}</span>
</span></span><span class="line"><span class="cl">   <span class="k">\label</span><span class="nb">{</span>tab:addlabel<span class="nb">}</span><span class="c">%标签
</span></span></span><span class="line"><span class="cl"><span class="c"></span>   <span class="k">\caption</span><span class="nb">{</span>Add caption<span class="nb">}</span><span class="c">%表格标题放在表格底下
</span></span></span><span class="line"><span class="cl"><span class="c"></span> <span class="k">\end</span><span class="nb">{</span>table<span class="nb">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="内部引用">内部引用</h2>
<p>如果是文章内部自己要引用图片/表格/公式，在对应环境里面加上一句</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-latex" data-lang="latex"><span class="line"><span class="cl">   <span class="k">\label</span><span class="nb">{</span>yinyong<span class="nb">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>引用的时候</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-latex" data-lang="latex"><span class="line"><span class="cl">   <span class="k">\ref</span><span class="nb">{</span>yinyong<span class="nb">}</span><span class="c">%注意标签名字要对应
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>就会自动生成好对应的<strong>编号，不是 图片/表格/公式+编号</strong>。这样的 tex 文档要选择&quot;xe-&gt;xe-&gt;xe&quot;三次编译，才能建立起文档内部的引用关系。</p>
<h2 id="bibtex">bibTex</h2>
<p>在同一个目录里面新建一个.bib 格式文件。bibTex 的格式可以通过比如 EndNotes 等很多引用管理软件自动导出。注意第一行的“rn1”是文件的引用描述名</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-latex" data-lang="latex"><span class="line"><span class="cl">   @book<span class="nb">{</span>rn1,
</span></span><span class="line"><span class="cl">   author = <span class="nb">{</span>李约瑟<span class="nb">}</span>,
</span></span><span class="line"><span class="cl">   title = <span class="nb">{</span>中国科学技术史<span class="nb">}</span>,
</span></span><span class="line"><span class="cl">   publisher = <span class="nb">{</span>香港 : 中华书局香港分局<span class="nb">}</span>,
</span></span><span class="line"><span class="cl">   address = <span class="nb">{</span>香港<span class="nb">}</span>,
</span></span><span class="line"><span class="cl">   year = <span class="nb">{</span>1975<span class="nb">}</span>,
</span></span><span class="line"><span class="cl">   type = <span class="nb">{</span>Book<span class="nb">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在写.tex 文件的时候，在需要引用的地方，写</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-latex" data-lang="latex"><span class="line"><span class="cl">   <span class="k">\cite</span><span class="nb">{</span>rn1<span class="nb">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在文章结尾处</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-latex" data-lang="latex"><span class="line"><span class="cl">    <span class="k">\bibliographystyle</span><span class="nb">{</span>gbt7714-2005<span class="nb">}</span><span class="c">%选择引用文献格式
</span></span></span><span class="line"><span class="cl"><span class="c"></span>    <span class="k">\bibliography</span><span class="nb">{</span>.bib<span class="nb">}</span><span class="c">%对应的.bib文件名字
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>选择&quot;xe-&gt;bib-&gt;xe-&gt;xe&quot;四次编译。LaTex 会根据文献最早在 tex 文档里面出现的顺序，在文章结尾自动排版文献的顺序。而且，出现在 bib 文件中，但最后 tex 文件中没有引用的文章，不会出现在最后的 pdf 文档当中。</p>
<p>bibTex 的优势就在于此，自由选择引用的格式，无需操心编号问题。</p>
]]></content:encoded></item><item><title>VS Code，All in One（2）——v0.2.0</title><link>https://livypad.github.io/post/2020-06-22-vsc2/</link><pubDate>Mon, 22 Jun 2020 00:00:00 +0000</pubDate><guid>https://livypad.github.io/post/2020-06-22-vsc2/</guid><description>VS Code 以及其他的安利向（2）-markdown 何为 markdown markdown（有时候简称 md）是一个轻量的标记语言。和 word 不一样，Markdown 按照描</description><content:encoded><![CDATA[<h1 id="vs-code-以及其他的安利向2-markdown">VS Code 以及其他的安利向（2）-markdown</h1>
<h2 id="何为-markdown">何为 markdown</h2>
<p>markdown（有时候简称 md）是一个轻量的标记语言。和 word 不一样，Markdown 按照描述符来修饰语法。这个格式有以下一些优点：</p>
<ol>
<li>轻量级，基本上就是纯文本文件，方便进行版本管理。不像 docx 是 xml 文件的打包。</li>
<li>语法极其简单，容易入门（相比下一篇要写到的复杂的标记语言 Latex）</li>
<li>由于语法简单，阅读源码也能保持一定的体验</li>
<li>可以选择不同的预览格式</li>
<li>现在相对比较流行，应用广泛</li>
<li>可以拓展支持 Latex 公式</li>
</ol>
<h2 id="环境">环境</h2>
<h3 id="markdown-all-in-onehttpsmarketplacevisualstudiocomitemsitemnameyzhangmarkdown-all-in-one"><a href="https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one">Markdown All in One</a></h3>
<p>VS Code 下写 markdown，最基本的只需要安装插件<a href="https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one">Markdown All in One</a>。这个插件可以提供最基本的侧边预览（在文件右上角），以及打印成 html 格式文件（ctrl+shift+p，打印到 html）的功能。</p>
<h3 id="word-count-cjkhttpsmarketplacevisualstudiocomitemsitemnameholmescnvscode-wordcount-cjk"><a href="https://marketplace.visualstudio.com/items?itemName=holmescn.vscode-wordcount-cjk">Word Count CJK</a></h3>
<p>国人开发的，对 markdown 文件的字数统计。可以直接修改设置的 json 文件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="s2">&#34;wordcount_cjk.statusBarTextTemplate&#34;</span><span class="err">:</span> <span class="s2">&#34;共 ${cjk} 字，共${en_words}单词&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>也可以在设置的图形界面，在拓展一栏直接找到 Status Bar Text Template，添加共 “${cjk} 字，共${en_words}单词”，这样就能同时统计中文和英文。</p>
<h3 id="docs-authoring-packhttpsmarketplacevisualstudiocomitemsitemnamedocsmsftdocs-authoring-pack"><a href="https://marketplace.visualstudio.com/items?itemName=docsmsft.docs-authoring-pack">Docs Authoring Pack</a></h3>
<p>一个合集。可以在状态栏给不熟悉语法的读者一些快捷键。而笔者主要只是用到 ta 的 markdown 格式检查功能。虽然 markdown 语法上简洁随意，但遵守一定的规范会让源代码阅读更加好看。可以在<a href="https://github.com/DavidAnson/markdownlint/blob/v0.20.3/doc/Rules.md">这里查看规则</a>。</p>
<p>还可以这样修订规则，选择部分规则不检查。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="s2">&#34;markdownlint.config&#34;</span><span class="err">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;MD036&#34;</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span><span class="c1">//可以复合使用加粗
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nt">&#34;MD028&#34;</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span><span class="c1">//引言间可以有空行分割
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nt">&#34;MD010&#34;</span><span class="p">:</span><span class="kc">false</span><span class="p">,</span><span class="c1">//允许空格
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span><span class="err">,</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="语法">语法</h2>
<h3 id="当我们在谈论文章的时候我们在谈论什么">当我们在谈论文章的时候我们在谈论什么</h3>
<p>在介绍 markdown 语法之前，需要先思考一个问题，一篇文章是什么，需要大概什么部分。</p>
<p>文章首先需要<strong>标题</strong>，文章的大标题，分节的标题。文章里面一些句子/段落需要<strong>加粗</strong>或者是<strong>斜体</strong>。文章很多时候需要列表，<strong>有序无序列表</strong>作为顺序结构。一篇文章可能需要插入，<strong>图片</strong>，<strong>表格</strong>，<strong>链接</strong>，<strong>数学公式</strong>这些辅助所里，有时候还需要插入<strong>代码块</strong>。还有，markdown 支持一个<strong>引言</strong>功能。</p>
<p>下面一个个看这些语法：</p>
<h3 id="标题">标题</h3>
<p>#用来表示标题，越多标题层次越小。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-markdown" data-lang="markdown"><span class="line"><span class="cl"><span class="gh"># 一级标题
</span></span></span><span class="line"><span class="cl"><span class="gh"></span>
</span></span><span class="line"><span class="cl"><span class="gu">## 二级标题
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="加粗斜体">加粗，斜体</h3>
<p>用*括起文本实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-markdown" data-lang="markdown"><span class="line"><span class="cl">*斜体*
</span></span><span class="line"><span class="cl"><span class="gs">**加粗**</span>
</span></span><span class="line"><span class="cl"><span class="ge">**</span>*倾斜加粗***
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="图片链接数学公式代码块">图片，链接，数学公式，代码块</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-markdown" data-lang="markdown"><span class="line"><span class="cl">    ![<span class="nt">图片名</span>](<span class="na">图片地址</span>)
</span></span><span class="line"><span class="cl">    [<span class="nt">链接名</span>](<span class="na">链接地址</span>)
</span></span><span class="line"><span class="cl">    $行内公式$
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    $$
</span></span><span class="line"><span class="cl">    行间公式
</span></span><span class="line"><span class="cl">    $$
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ```语言名字
</span></span><span class="line"><span class="cl">        代码片段
</span></span><span class="line"><span class="cl">    ```
</span></span></code></pre></td></tr></table>
</div>
</div><p>|：表格功能，这个比较复杂，这里不详细说明。</p>
<h3 id="列表">列表</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-markdown" data-lang="markdown"><span class="line"><span class="cl"><span class="k">1.</span> 有序列表
</span></span><span class="line"><span class="cl"><span class="k">2.</span> 有序列表
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">-</span> 无序列表
</span></span><span class="line"><span class="cl"><span class="k">-</span> 无序列表
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="引用">引用</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-markdown" data-lang="markdown"><span class="line"><span class="cl">    &gt;引文
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="示例">示例</h3>
<p>下面是一个 markdown 语法的示例，比较完整的示例各个基础语法，出自本人之前的博客文章</p>
<p><img loading="lazy" src="/assets/img/vscmd1.jpg" alt="示例"  />
</p>
<p>其实对于 markdown 入门，只需要记住#是表示标题的前驱就行。1 个#就是一级标题，2 个#就是二级标题，以此类推到六级标题。然后$就像 Latex 一样可以输入公式。这样的 markdown 已经能胜任很多小文章的编写工作了。</p>
<h2 id="导出">导出</h2>
<p>虽然 markdown 简单，轻量，接受度越来越广，但不是所有人都之前接触过 markdown 或者是有软件打开 md 格式文件。下面是导出“通用”格式的教程。</p>
<h3 id="html">html</h3>
<p>ctrl+shift+p 打开顶部搜索框，输入 markdown all in one 就能找到打印当前文档为 html 格式文件的选项。这个格式就已经可以发给移动端或 pc 端的他人了。html 文件就是网页文件，任何浏览器都能打开。</p>
<p>如果再本地用浏览器打开，就可以右键，使用浏览器自带的打印成 pdf 文件的功能。</p>
<h3 id="typorahttpstyporaio"><a href="https://typora.io/">Typora</a></h3>
<p>就如之前所说，md 已经得到广泛的应用，相应的市面上有很多专门的 markdown 编辑器（VS Code 是通用的文本编辑器），Typora 是其中一种。Typora 有导出为 pdf，docx 等各种常见格式的功能。Typora 还有各种 markdown 的主题，可以选择别的主题导出。</p>
<h3 id="pandochttpspandocorg"><a href="https://pandoc.org/">pandoc</a></h3>
<p>通用的命令行格式转换工具。（笔者也不是很会用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-powershell" data-lang="powershell"><span class="line"><span class="cl"><span class="n">pandoc</span> <span class="n">demo</span><span class="p">.</span><span class="nb">md </span><span class="n">-o</span> <span class="n">demo</span><span class="p">.</span><span class="n">pdf</span>
</span></span></code></pre></td></tr></table>
</div>
</div>]]></content:encoded></item><item><title>VS Code，All in One（1）——v0.2.0</title><link>https://livypad.github.io/post/2020-06-21-vsc1/</link><pubDate>Sun, 21 Jun 2020 00:00:00 +0000</pubDate><guid>https://livypad.github.io/post/2020-06-21-vsc1/</guid><description>VS Code 以及其他的安利向（1) -编辑器 关于这个系列 大学以来，笔者接触了很多新东西，很想安利出去。但是如果是一对一安利，虽然能有及时反馈，但是一是</description><content:encoded><![CDATA[<h1 id="vs-code-以及其他的安利向1--编辑器">VS Code 以及其他的安利向（1) -编辑器</h1>
<h2 id="关于这个系列">关于这个系列</h2>
<p>大学以来，笔者接触了很多新东西，很想安利出去。但是如果是一对一安利，虽然能有及时反馈，但是一是略显尴尬，打字很不方便，二是笔者懒（抱歉），不想一个个人说。所以就萌生了写这个系列小文章的想法。</p>
<p>正好 VS Code 就是笔者一直以来的各个工作的共同平台，All in One 正是取其“全能”的含义。是有这个系列文章。</p>
<p>这是一个安利+教程向的文章。限于笔者水平（和懒惰），肯定会有一些谬误或者是不全面的地方。而且笔者也只有 win10 平台经验。按照笔者的经验，遇到的绝大多数问题，是可以当即依靠<strong>搜索引擎</strong>解决的。（当然，如果您希望笔者加上去，也欢迎私下联系我更新文章。</p>
<p>学习这些应用性技能的宗旨</p>
<p><strong>搜索引擎是最好的老师</strong></p>
<h2 id="什么是-vs-code">什么是 VS Code</h2>
<p>VS Code 是微软开源出来的一款代码编辑器。在此基础上再加上一些微软自己的服务，就是现在的 VS Code 软件。VS Code 可以很容易的从<a href="https://code.visualstudio.com/Download">官网上下载</a>，<a href="https://code.visualstudio.com/insiders/">Insiders 版本</a>（预览版本，更新更快，新功能上线早，可能不稳定）。</p>
<h2 id="什么是代码编辑器">什么是代码编辑器</h2>
<p>代码编辑器，顾名思义，就是编辑代码文件的。但是问题来了，这些文件究竟是什么，为什么笔者在这里推荐代码编辑器，不是别的软件？</p>
<h3 id="代码文档-vs-docx">代码文档 vs .docx</h3>
<p>读者应该都接触过 txt 格式的文件。上过大学，学过一些计算机方面的基础课的同学，可能还会接触.c,.cpp,.py,.md,.tex 等等格式的文件。这些文件看起来拓展名千差万别，但是读者可以做一个实验。文件里面写上“123456789”，文件的大小都是 9B。而若是在一个 docx 文档里面，文档大小是 11.8 KB。这个简单的对比就反映出，本质上，之前说的各个格式，都是某种意义上的纯文本文档，拓展名只是标识这个文件是什么类型的，需要什么样的编译器/解释器。而 docx，如果用压缩软件打开，其实是一系列的 xml 文件，word 软件对这一系列的文件，掩盖了在文本文档层面的工作，而展现出一个整体的效果。</p>
<p><img loading="lazy" src="/assets/img/vscset2.jpg" alt="docx"  />
</p>
<p>从这点出发，我们就可以用同一个代码编辑器，处理不同的代码文档，毕竟 ta 们本质都是文本文档。</p>
<h3 id="代码编辑器-vs-记事本">代码编辑器 vs 记事本</h3>
<p>既然说到文本文档，大家第一反应一般都是记事本。记事本当然是可以写代码文件的，毕竟记事本是可以处理 txt 这样的文本文档的。如果不信，可以看下面的对比图。左边为 VS Code，右边是记事本，文件是笔者之前光线追迹里面提到的.py 文件。</p>
<p><img loading="lazy" src="/assets/img/vscset3.jpg" alt="txt"  />
</p>
<p>但这么一对比，直观上看，记事本毕竟没有专门的设计。相比较正牌的代码编辑器，ta 缺少比如自动补全，代码语法高亮等等好用的功能。最多说能用，但是很不趁手。</p>
<h3 id="代码编辑器-vs-集成开发环境">代码编辑器 vs 集成开发环境</h3>
<p>集成开发环境（IDE，下文也会这样简称）顾名思义，就是集成了大量的辅助功能，针对性的开发软件。例如学 c/cpp 读者可能接触过的 Visual Studio，Dev-C++，学 python 读者接触过的 PyCharm，都是所谓的 IDE。</p>
<p>与代码编辑器孰优孰劣其实是个延续已久的话题。一般来说，毕竟 IDE 集成了大量的辅助功能，在实际生产环境中，比起代码编辑器，还是更胜一筹（比如笔者虽然选择在 VS Code 里面写 cpp，但复杂调试的工作还是在 VS 2019 里面进行）。而正由于这样的强大的功能，IDE 一般来说，体积巨大，加载也比代码编辑器慢。而且，一般来说，IDE 针对少数几种语言设计，如果自己需要的不止一种，可能还有切换的麻烦。</p>
<p>相比而言，通过插件的帮助，代码编辑器可以适配绝大多数语言。而更小的体积，更精简的功能让代码编辑器加载更快，更轻量。而对一些要求不高的项目/任务，代码编辑器也能胜任，这样就不需要安装/加载体积巨大的 IDE。</p>
<h3 id="为何选择-vs-code">为何选择 VS Code</h3>
<ol>
<li>作为代码编辑器，安装插件后，就能适应很多编程语言和琐碎应用场景。</li>
<li>微软大厂更新勤快，新功能上线多，官方就有很多插件支持。而且现在已经支持用微软账户或 GitHub
账户同步设置。</li>
<li>目前 VS Code 市场份额大，而且还在上升趋势。插件开发多，教程多。</li>
<li>开源免费软件，不怕封锁。这个系列之后介绍的也主要是开源方案，适合于跨平台和对抗科技封锁。</li>
</ol>
<p><strong>本质上来说，笔者希望这个系列的教程，提供基于 VS Code 的，大量工作流程/场景的“一站式解决方案”。</strong></p>
<h2 id="安装">安装</h2>
<p>按照上述地址，或者使用搜索引擎就能很快完成 VS Code 的安装。唯一需要注意的可能就是勾选注册 VS Code 为 Path，和添加到右键菜单。现在只建议在常用设置里面，把自动保存 Auto Save 改成 afterDelay（就是允许自动保存）。这样不需要频繁按保存键。</p>
<h2 id="界面介绍">界面介绍</h2>
<p>左边是侧边栏。文件是基本编辑区，方块是拓展市场，左下角头像是配置同步设置，齿轮就是设置。</p>
<h2 id="字体和美化">字体和美化</h2>
<p><strong>这些主题，字体等设置纯属个人审美倾向</strong></p>
<p>笔者非常喜欢<a href="https://github.com/tonsky/FiraCode/releases">Fira Code</a>这个字体。这个等宽字体能很好的区分 1l0o 这样的字母，还支持连字符的特性。例如输入！=就会自动转换为$\neq$，非常美观。中文可以选择微软雅黑或者是<a href="https://github.com/adobe-fonts/source-han-sans/tree/release">思源黑体</a>。同样在设置里面更改字体<img loading="lazy" src="/assets/img/vscset1.jpg" alt="字体设置"  />
</p>
<p>同样的，单击齿轮图标，可以修改配色和文件图标。更多的文件图标和配色主题，在之前介绍的拓展里面搜索下载。文件图标推荐选择 Material Icon Theme。亮色主题使用自带的 Light+就很好，需要更换也可以选择 Github Theme 里面的亮色主题。自带的 Dark+背景有点太黑了，所以笔者推荐 One Dark Pro，这个暗色主题适合写 Python，md，写 c++有点太多红色了。如果写 Latex，笔者喜欢 Linux Themes for VS Code 当中的 Adapta Nokto，公式比较鲜艳，而且照明环境下，不显得太黑。</p>
<h2 id="杂项">杂项</h2>
<h3 id="中文支持">中文支持</h3>
<p>在拓展市场中搜索 Chinese (Simplified) Language Pack for Visual Studio Code 就能找到官方的汉化插件。按照指示安装就能配置好中文支持。</p>
<p><strong>注意：该中文是不一定保证完全覆盖的。很多时候还是会接触到英文界面</strong></p>
<h3 id="文件编码">文件编码</h3>
<p>在状态栏上，右下角例如 UTF-8 就是当前文件的编码。如果一直使用 VS Code 这不构出问题。但是现在还是有很多软件，其文件的默认编码为 GBK 等，包括 Matlab，Code Composer Studio，微软自家的 VS2019 等。而 VS Code 的默认编码方式为 UTF-8。编码不一样打开文件就会乱码。要解决文件乱码问题</p>
<ol>
<li>单击编码标签，选择“通过编码重新打开”，选择原文件的编码.这样就能解决显示问题</li>
<li>再单击编码标签，选择“通过编码保存”，选择 UTF-8。下次再用 VS Code 打开就不会出现乱码。</li>
</ol>
<h3 id="设置同步">设置同步</h3>
<p>左下角的头像就是设置同步账号，按提示操作就能同步自己的 VS Code 配置。可以选择使用微软账户（一般安装 win10 系统，上云端的就是微软账户）或者是 Github 账户同步。</p>
<h3 id="ctrlshiftp">ctrl+shift+p</h3>
<p>VS Code 的通用顶部功能搜索框。可以依靠这一功能，快速搜索需要的操作而不用背诵快捷键</p>
<h3 id="drawio-integration">Draw.io Integration</h3>
<p>一个本地画流程图的实用插件。新建一个后缀为.dio 的文件，打开就是绘制流程图的界面。简单易上手。</p>
<h3 id="binary">Binary</h3>
<p>可以查看文件的二进制预览形式。</p>
<h3 id="gitlens">Gitlens</h3>
<p>git 功能的拓展，查看历史更方便。但是笔者自己对 git 的理解也不多，暂时不深入说明。</p>
<h3 id="vsc-netease-music">VSC Netease Music</h3>
<p>在 VS Code 里面听网易云音乐。现在由于 VS Code 自身的问题，还需要修复。所以这里就暂不推荐该拓展。有余力的可以按照官方指引修复。</p>
<h3 id="用户代码片段">用户代码片段</h3>
<p>用户代码片段，乍一眼看上去可能会感觉到不知所云，其实这个功能是用来提供自定义代码补全的。点击设置按钮即可为全局或者是特定语言进行设置。而设置的语法参考教程就行。下面是对 latex 语言的设置举例（latex 教程见本系列后续文章）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Place your snippets for latex here. Each snippet is defined under a snippet name and has a prefix, body and
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// same ids are connected.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Example:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// &#34;Print to console&#34;: {
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 	&#34;prefix&#34;: &#34;log&#34;,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 	&#34;body&#34;: [
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 		&#34;console.log(&#39;$1&#39;);&#34;,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 		&#34;$2&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 	],
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 	&#34;description&#34;: &#34;Log output to console&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nt">&#34;Input a figure&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;prefix&#34;</span><span class="p">:</span> <span class="s2">&#34;fig&#34;</span><span class="p">,</span> <span class="c1">//代码自动补全的名字
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nt">&#34;body&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">      <span class="s2">&#34;\\begin{figure}[H]&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="s2">&#34;\t\\centering&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="s2">&#34;\t\\includegraphics[width=\\linewidth]{$1}&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="s2">&#34;\t\\caption{$2}&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="s2">&#34;\\end{figure}&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="s2">&#34;$0&#34;</span> <span class="c1">//正式的代码段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;Input a figure&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;aligned&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;prefix&#34;</span><span class="p">:</span> <span class="s2">&#34;aligned&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;body&#34;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&#34;\\begin{aligned}&#34;</span><span class="p">,</span> <span class="s2">&#34;\t$1&#34;</span><span class="p">,</span> <span class="s2">&#34;\\end{aligned}$0&#34;</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;Input an aligned env&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div>]]></content:encoded></item><item><title>简单信号处理</title><link>https://livypad.github.io/post/2020-06-18-sigpro/</link><pubDate>Thu, 18 Jun 2020 00:00:00 +0000</pubDate><guid>https://livypad.github.io/post/2020-06-18-sigpro/</guid><description>简单信号处理 题目 物理知识告诉我们，对运动物体发射波，反射的波会受到多普勒效应的影响，造成反射波的频率的改变。而这一改变和物与发射源运动速度相</description><content:encoded><![CDATA[<h1 id="简单信号处理">简单信号处理</h1>
<h2 id="题目">题目</h2>
<p>物理知识告诉我们，对运动物体发射波，反射的波会受到多普勒效应的影响，造成反射波的频率的改变。而这一改变和物与发射源运动速度相关。这就是多普勒测速的基本原理。本题只需要处理出频率变化量。</p>
<p>简化实际情况，假设发射信号为$x(t)=A\cos(\omega_0 t+\phi)$，而接受信号接收到反射静止物体和运动物体的信号，为$y(t)=B\cos(\omega_0(t-t_0)+\phi)+D\cos(\omega_0(t-t_0)+\phi)$。而且为了方便，假定机器保留了原始的输出信号。</p>
<h2 id="流程图">流程图</h2>
<p>基本设计思路如下</p>
<p><img loading="lazy" src="/assets/img/sig1.png" alt="流程图"  />
</p>
<p>这个设计的基本思路是借鉴了双边带抑制载波调制的思路。借鉴自乘和滤波，获得低频的多普勒偏移频率。</p>
<h2 id="数学证明">数学证明</h2>
<p>为了简化推导，接收的信号的时延，可以划归到相位变化中。即</p>
<p>$$
y(t)=B\cos(\omega_0t+\phi_1)+D\cos((\omega_0+\omega_d)t+\phi_2)\tag{1}
$$</p>
<p>将信号和原始信号导入乘法器，得到</p>
<p>$$
x(t)*y(t)=\frac{AB}{2}(\cos(2\omega_0t+\phi_1)+\cos\phi_1)+\\ \frac{AD}{2}(\cos((2\omega_0+\omega_d)t+\phi_2)+\cos(\omega_d t+\phi_2)) \tag{2}
$$</p>
<p>观察这个形式，很容易注意到，频率分量为$2\omega_0,2\omega_0+\omega_d,\omega_d,0$,分别是高频部分和低频部分。那么非常自然的想到，让信号通过一个低通滤波器即可。</p>
<p>$$
proc1(t)=\frac{AB}{2}\cos\phi_1+\frac{AD}{2}\cos(\omega_d t+\phi_2)\tag{3}
$$</p>
<p>接下来想办法去除直流分量，就可以得到多普勒频率信号本身。由于实际上，我们是对离散量进行处理，那么去除直流量，可以简化成，求出信号在一段时间中离散值的平均数，减去即可。</p>
<p>$$
proc1(t).average()=\frac{AB}{2}\cos\phi_1\tag{4}
$$</p>
<p>最后得到想要的信号。</p>
<p>$$
\begin{aligned}
proc2(t)&amp;=proc1(t)-proc1(t).average()\\
&amp;=\frac{AD}{2}\cos(\omega_d t+\phi_2)
\end{aligned}\tag{5}
$$</p>
<h2 id="实现细节">实现细节</h2>
<p>由于这是数字信号处理，所以不需要再加上专门的“去直流”。对离散值直接求平均减去即可。</p>
<p>滤波器采用 8 阶 Butterworth 低通滤波器。</p>
<h2 id="结果">结果</h2>
<p><img loading="lazy" src="/assets/img/sig2.png" alt="结果"  />
</p>
<p>图一为频谱，红色为相乘信号，蓝色为输出信号。图二为时域。蓝色信号为输出，红色信号是初始发出的雷达信号，作为对比。</p>
<h2 id="源代码">源代码</h2>
<p>完整源代码如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</span></span><span class="line"><span class="cl"><span class="n">w</span> <span class="o">=</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">105</span><span class="p">]</span>  <span class="c1">#频率</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>  <span class="c1">#幅值</span>
</span></span><span class="line"><span class="cl"><span class="n">ph</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.4</span><span class="p">,</span> <span class="mf">0.73</span><span class="p">]</span>  <span class="c1">#相位</span>
</span></span><span class="line"><span class="cl"><span class="n">N</span> <span class="o">=</span> <span class="mi">1000</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#初始信号</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">xtsig</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">t</span> <span class="o">+</span> <span class="n">ph</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#回波</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">ytsig</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">t</span> <span class="o">+</span> <span class="n">ph</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">            <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">t</span> <span class="o">+</span> <span class="n">ph</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">mul</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ytsig</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">xtsig</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">mulxy</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">=</span> <span class="n">xtsig</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">#滤波</span>
</span></span><span class="line"><span class="cl"><span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">butter</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mf">0.02</span><span class="p">,</span> <span class="s1">&#39;lowpass&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">low</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">mulxy</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">#去除直流分量</span>
</span></span><span class="line"><span class="cl"><span class="n">ave</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">low</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">low</span> <span class="o">=</span> <span class="n">low</span> <span class="o">-</span> <span class="n">ave</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">f1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">mulxy</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">absf1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">f1</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">f2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">absf2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">f2</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">f3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">low</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">absf3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">f3</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">211</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">p1</span><span class="p">,</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">absf1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">p2</span><span class="p">,</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">absf2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">p3</span><span class="p">,</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">absf3</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">212</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">p4</span><span class="p">,</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">low</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">p5</span><span class="p">,</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div>]]></content:encoded></item><item><title>关于这个博客的搭建</title><link>https://livypad.github.io/post/2020-06-17-blog/</link><pubDate>Wed, 17 Jun 2020 00:00:00 +0000</pubDate><guid>https://livypad.github.io/post/2020-06-17-blog/</guid><description>关于这个博客的搭建 缘由 自己搭建博客很有意思。（人就是要折腾 很好的展示自己的平台 界面相对自由 如何搭建 Jekll 是个简单的博客服务。而 GitHub Pages 基于 Jekyll 构建，可</description><content:encoded><![CDATA[<h1 id="关于这个博客的搭建">关于这个博客的搭建</h1>
<h2 id="缘由">缘由</h2>
<ol>
<li>自己搭建博客很有意思。（人就是要折腾</li>
<li>很好的展示自己的平台</li>
<li>界面相对自由</li>
</ol>
<h2 id="如何搭建">如何搭建</h2>
<p>Jekll 是个简单的博客服务。而 GitHub Pages 基于 Jekyll 构建，可以很简单地（就像在这篇文章接下来介绍的）在 GitHub 上免费发布网站和个人博客。</p>
<p><strong>警告，下列操作涉及的网站很多只有英文界面</strong></p>
<p><strong>这只是一个非常初级的教程，而且笔者水平有限，必有谬误，敬请指正</strong></p>
<p><strong>网络不是法外之地，希望大家不要滥用博客功能</strong></p>
<h3 id="github-初始化">Github 初始化</h3>
<p>注册一个<a href="https://github.com/">Github</a>账户。创建一个 Respority（代码存储库）。用户名按照 username.GitHub.io 这样的格式。在 Settings(设置)下面找到 Github Pages，选择一个主题。Github 就会自动创建好一个用于个人博客的库。这个时候，博客就可以通过在浏览器输入 username.GitHub.io 访问。</p>
<p>为了方便博客的编写，笔者自己采用的方法是下载<a href="https://desktop.github.com/">Github 的桌面客户端</a>，并搭配<a href="https://code.visualstudio.com/">VS Code</a>作为对应编辑器使用（现在微软由于收购了 Github，这两者的结合还是很方便的）。</p>
<h3 id="博客设置">博客设置</h3>
<p>Github 默认创建的博客虽然已经可以访问，但是一般来说还不是很全面。而笔者的建议是，</p>
<ol>
<li>用 Github 的桌面端软件把原来的 Respority Clone（复制）到本地</li>
<li>在 Jekll 官网上下载一个好看的主题（或者如果喜欢的话，也可以选择笔者的）</li>
<li>直接将解压后的主题文件夹（除了.git 文件）直接在本地复制粘贴到原来的 Respority 对应的文件夹下面</li>
<li>同步</li>
</ol>
<p>这样就能快速换成自己想要的，而且是别人已经帮配置好的主题。</p>
<h3 id="写博客">写博客</h3>
<p><strong>警告，不同的主题之间可能有一定的差异</strong></p>
<p>用我们之前下好的 VS Code 打开本地的 Respority 文件夹，就可以开始写博客了。</p>
<p>Jekll 的博客一般通过 markdown 语法进行编写。博文新建在_posts 文件夹下，命名格式为时间加题目<code>20XX-XX-XX-title.md</code>。
在 md 文件题头还要加上描述符。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-md" data-lang="md"><span class="line"><span class="cl">---
</span></span><span class="line"><span class="cl">layout: default
</span></span><span class="line"><span class="cl">title: &#34;XX&#34;
</span></span><span class="line"><span class="cl">---
</span></span></code></pre></td></tr></table>
</div>
</div><p>其他部分和一般的 markdown 语法相近。如</p>
<ul>
<li><code>#</code> 用来表示标题，1-6 个，越少标题越大</li>
<li><code>**</code>斜体</li>
<li><code>****</code>加粗</li>
<li>``````中间包含代码块</li>
</ul>
<p>如果需要插入图片，将图片放/assets/img 文件夹下，通过<code>![描述名](/assets/img/图片名)</code>来引用。</p>
<p>如果需要支持 Latex 公式，可以自行上网搜索，如何加入 mathJx 脚本，支持 latex 公式。本博客目前已经支持。</p>
<p>发布博客时，只需要提交更改，并同步即可。网页会自动帮助转换 md 文档为网页博客。</p>
]]></content:encoded></item><item><title>Welcome to Jekyll!</title><link>https://livypad.github.io/post/2020-05-06-heloworld/</link><pubDate>Wed, 06 May 2020 00:00:00 +0000</pubDate><guid>https://livypad.github.io/post/2020-05-06-heloworld/</guid><description>hello world 先试一下怎么用</description><content:encoded>&lt;h1 id="hello-world">hello world&lt;/h1>
&lt;p>先试一下怎么用&lt;/p></content:encoded></item><item><title>光线追迹</title><link>https://livypad.github.io/post/2020-05-06-light/</link><pubDate>Wed, 06 May 2020 00:00:00 +0000</pubDate><guid>https://livypad.github.io/post/2020-05-06-light/</guid><description>球差仿真计算 Python 可以做很多事情，比如进行光学追迹的简单计算。这是一个课程的小实验作业。 题目 运用光线追迹公式，对 d，F，C 光绘制出球差曲线。 编译</description><content:encoded><![CDATA[<h1 id="球差仿真计算">球差仿真计算</h1>
<p>Python 可以做很多事情，比如进行光学追迹的简单计算。这是一个课程的小实验作业。</p>
<h2 id="题目">题目</h2>
<p>运用光线追迹公式，对 d，F，C 光绘制出球差曲线。</p>
<h2 id="编译环境">编译环境</h2>
<p>使用 Anaconda 的 Python3.7.6 解释器。需要额外安装包：sympy，matploylib。</p>
<h2 id="基本设置">基本设置</h2>
<ul>
<li>物距 $l=-1000$mm</li>
<li>透镜半径 $r1=150$mm</li>
<li>透镜半径 $r2=-120$mm</li>
<li>透镜半径 $r3=200$mm</li>
<li>厚度 $d1=20$mm</li>
<li>厚度 $d2=20$mm</li>
</ul>
<p>折射率</p>
<table>
<thead>
<tr>
<th>C 光</th>
<th>d 光</th>
<th>F 光</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.4</td>
<td>1.55</td>
<td>1.6</td>
</tr>
<tr>
<td>1.9</td>
<td>2.1</td>
<td>2.2</td>
</tr>
</tbody>
</table>
<p>依据式子</p>
<p>$$
\sqrt{r[1]^2-h^2}+r[1]-\sqrt{r[2]^2-h^2}-r[2]=d[1]
$$</p>
<p>计算出，以第一个透镜为光阑，光阑投射高度$h=50.62$mm。</p>
<h2 id="球差曲线">球差曲线</h2>
<p><img loading="lazy" src="/assets/img/light.jpeg" alt="球差曲线"  />
</p>
<h2 id="源代码">源代码</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="o">*</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#理想光线追迹</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">idealight</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">l1</span><span class="o">=-</span><span class="mi">1000</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">u11</span> <span class="o">=</span> <span class="mf">0.0000001</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">i11</span> <span class="o">=</span> <span class="p">(</span><span class="n">l1</span> <span class="o">-</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">u11</span> <span class="o">/</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">i12</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">i11</span> <span class="o">/</span> <span class="n">n1</span>
</span></span><span class="line"><span class="cl">    <span class="n">u12</span> <span class="o">=</span> <span class="n">u11</span> <span class="o">+</span> <span class="n">i11</span> <span class="o">-</span> <span class="n">i12</span>
</span></span><span class="line"><span class="cl">    <span class="n">l12</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">i12</span> <span class="o">/</span> <span class="n">u12</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">l21</span> <span class="o">=</span> <span class="n">l12</span> <span class="o">-</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">u21</span> <span class="o">=</span> <span class="n">u12</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">i21</span> <span class="o">=</span> <span class="p">(</span><span class="n">l21</span> <span class="o">-</span> <span class="n">r</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="n">u21</span> <span class="o">/</span> <span class="n">r</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">i22</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">*</span> <span class="n">i21</span> <span class="o">/</span> <span class="n">n2</span>
</span></span><span class="line"><span class="cl">    <span class="n">u22</span> <span class="o">=</span> <span class="n">u21</span> <span class="o">+</span> <span class="n">i21</span> <span class="o">-</span> <span class="n">i22</span>
</span></span><span class="line"><span class="cl">    <span class="n">l22</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">u22</span> <span class="o">+</span> <span class="n">i22</span><span class="p">)</span> <span class="o">/</span> <span class="n">u22</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">l31</span> <span class="o">=</span> <span class="n">l22</span> <span class="o">-</span> <span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">u31</span> <span class="o">=</span> <span class="n">u22</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">i31</span> <span class="o">=</span> <span class="p">(</span><span class="n">l31</span> <span class="o">-</span> <span class="n">r</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">*</span> <span class="n">u31</span> <span class="o">/</span> <span class="n">r</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">i32</span> <span class="o">=</span> <span class="n">n2</span> <span class="o">*</span> <span class="n">i31</span>
</span></span><span class="line"><span class="cl">    <span class="n">u32</span> <span class="o">=</span> <span class="n">u31</span> <span class="o">+</span> <span class="n">i31</span> <span class="o">-</span> <span class="n">i32</span>
</span></span><span class="line"><span class="cl">    <span class="n">l32</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">i32</span> <span class="o">/</span> <span class="n">u32</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">l32</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#实际光线追迹</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">reallight</span><span class="p">(</span><span class="n">u11</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">l1</span><span class="o">=-</span><span class="mi">1000</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">sini11</span> <span class="o">=</span> <span class="p">(</span><span class="n">l1</span> <span class="o">-</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">u11</span><span class="p">)</span> <span class="o">/</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">sini12</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">sini11</span> <span class="o">/</span> <span class="n">n1</span>
</span></span><span class="line"><span class="cl">    <span class="n">u12</span> <span class="o">=</span> <span class="n">u11</span> <span class="o">+</span> <span class="n">asin</span><span class="p">(</span><span class="n">sini11</span><span class="p">)</span> <span class="o">-</span> <span class="n">asin</span><span class="p">(</span><span class="n">sini12</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">l12</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">sini12</span> <span class="o">/</span> <span class="n">sin</span><span class="p">(</span><span class="n">u12</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">l21</span> <span class="o">=</span> <span class="n">l12</span> <span class="o">-</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">u21</span> <span class="o">=</span> <span class="n">u12</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">sini21</span> <span class="o">=</span> <span class="p">(</span><span class="n">l21</span> <span class="o">-</span> <span class="n">r</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">u21</span><span class="p">)</span> <span class="o">/</span> <span class="n">r</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">sini22</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">*</span> <span class="n">sini21</span> <span class="o">/</span> <span class="n">n2</span>
</span></span><span class="line"><span class="cl">    <span class="n">u22</span> <span class="o">=</span> <span class="n">u21</span> <span class="o">+</span> <span class="n">asin</span><span class="p">(</span><span class="n">sini21</span><span class="p">)</span> <span class="o">-</span> <span class="n">asin</span><span class="p">(</span><span class="n">sini22</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">l22</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">u22</span><span class="p">)</span> <span class="o">+</span> <span class="n">sini22</span><span class="p">)</span> <span class="o">/</span> <span class="n">sin</span><span class="p">(</span><span class="n">u22</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">l31</span> <span class="o">=</span> <span class="n">l22</span> <span class="o">-</span> <span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">u31</span> <span class="o">=</span> <span class="n">u22</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">sini31</span> <span class="o">=</span> <span class="p">(</span><span class="n">l31</span> <span class="o">-</span> <span class="n">r</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">u31</span><span class="p">)</span> <span class="o">/</span> <span class="n">r</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">sini32</span> <span class="o">=</span> <span class="n">n2</span> <span class="o">*</span> <span class="n">sini31</span>
</span></span><span class="line"><span class="cl">    <span class="n">u32</span> <span class="o">=</span> <span class="n">u31</span> <span class="o">+</span> <span class="n">asin</span><span class="p">(</span><span class="n">sini31</span><span class="p">)</span> <span class="o">-</span> <span class="n">asin</span><span class="p">(</span><span class="n">sini32</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">l32</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">sini32</span> <span class="o">/</span> <span class="n">sin</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">l32</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#初始条件：物距，透镜半径，透镜距离,对应</span>
</span></span><span class="line"><span class="cl"><span class="c1">#初始0是因为python从0索引</span>
</span></span><span class="line"><span class="cl"><span class="n">l</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1000</span>
</span></span><span class="line"><span class="cl"><span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="o">-</span><span class="mi">120</span><span class="p">,</span> <span class="o">-</span><span class="mi">200</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">d</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="c1">#折射率 C,d,F</span>
</span></span><span class="line"><span class="cl"><span class="n">n1</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.4</span><span class="p">,</span><span class="mf">1.55</span><span class="p">,</span><span class="mf">1.6</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">n2</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.9</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#求解光阑参数：以第一个透镜为光阑</span>
</span></span><span class="line"><span class="cl"><span class="n">h</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;h&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">maxh</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span> <span class="o">-</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">h</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="o">+</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">r</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">h</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="o">-</span><span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">h</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">maxu</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">10000</span><span class="o">*</span><span class="n">atan</span><span class="p">(</span><span class="n">maxh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="o">-</span><span class="n">l</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">maxh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">))))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#初始化序列</span>
</span></span><span class="line"><span class="cl"><span class="n">divi</span><span class="o">=</span><span class="mi">500</span>
</span></span><span class="line"><span class="cl"><span class="n">uin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">maxu</span><span class="o">/</span><span class="mi">10000</span><span class="p">,</span> <span class="n">divi</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#初始化光线</span>
</span></span><span class="line"><span class="cl"><span class="n">deltac</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">divi</span>
</span></span><span class="line"><span class="cl"><span class="n">deltad</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">divi</span>
</span></span><span class="line"><span class="cl"><span class="n">deltaf</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">divi</span>
</span></span><span class="line"><span class="cl"><span class="c1">#列表</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">divi</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">deltac</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">idealight</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">n1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l</span><span class="p">)</span> <span class="o">-</span> <span class="n">reallight</span><span class="p">(</span><span class="n">uin</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">r</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">n1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">    <span class="n">deltad</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">idealight</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">n1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">n2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">l</span><span class="p">)</span> <span class="o">-</span> <span class="n">reallight</span><span class="p">(</span><span class="n">uin</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">r</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">n1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">n2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">l</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">    <span class="n">deltaf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">idealight</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">n1</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">n2</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">l</span><span class="p">)</span> <span class="o">-</span> <span class="n">reallight</span><span class="p">(</span><span class="n">uin</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">r</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">n1</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">n2</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">l</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl"><span class="c1">#画图</span>
</span></span><span class="line"><span class="cl"><span class="n">pc</span><span class="p">,</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">uin</span><span class="p">,</span> <span class="n">deltac</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">pd</span><span class="p">,</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">uin</span><span class="p">,</span> <span class="n">deltad</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;gold&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">pf</span><span class="p">,</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">uin</span><span class="p">,</span> <span class="n">deltaf</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;U/rad&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;delta/mm&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">handles</span> <span class="o">=</span> <span class="p">[</span><span class="n">pc</span><span class="p">,</span><span class="n">pd</span><span class="p">,</span><span class="n">pf</span><span class="p">],</span><span class="n">loc</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div>]]></content:encoded></item></channel></rss>