<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>读书笔记 on zhh's blog</title><link>https://livypad.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link><description>Recent content in 读书笔记 on zhh's blog</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Wed, 31 Aug 2022 00:18:17 +0800</lastBuildDate><atom:link href="https://livypad.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml"/><item><title>笔记：Computer Network by Tanenbaum(大概第6章)</title><link>https://livypad.github.io/post/2022-08-31-netbytanebaum/</link><pubDate>Wed, 31 Aug 2022 00:18:17 +0800</pubDate><guid>https://livypad.github.io/post/2022-08-31-netbytanebaum/</guid><description>Computer Network by Tanenbaum ch1 term 分层 ch2 物理层 信道容量 介质 调制 ch3 数据链路层 frame 检错纠错 hamming protocol 乌托邦式的单工协议 简单的 停-等 协议，无错信道 简单的 停-等 协议，信道可能出错</description><content:encoded><![CDATA[<ul>
<li><a href="#computer-network-by-tanenbaum">Computer Network by Tanenbaum</a>
<ul>
<li><a href="#ch1">ch1</a>
<ul>
<li><a href="#term">term</a></li>
<li><a href="#%E5%88%86%E5%B1%82">分层</a></li>
</ul>
</li>
<li><a href="#ch2-%E7%89%A9%E7%90%86%E5%B1%82">ch2 物理层</a>
<ul>
<li><a href="#%E4%BF%A1%E9%81%93%E5%AE%B9%E9%87%8F">信道容量</a></li>
<li><a href="#%E4%BB%8B%E8%B4%A8">介质</a></li>
<li><a href="#%E8%B0%83%E5%88%B6">调制</a></li>
</ul>
</li>
<li><a href="#ch3-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82">ch3 数据链路层</a>
<ul>
<li><a href="#frame">frame</a></li>
<li><a href="#%E6%A3%80%E9%94%99%E7%BA%A0%E9%94%99">检错纠错</a>
<ul>
<li><a href="#hamming">hamming</a></li>
</ul>
</li>
<li><a href="#protocol">protocol</a>
<ul>
<li><a href="#%E4%B9%8C%E6%89%98%E9%82%A6%E5%BC%8F%E7%9A%84%E5%8D%95%E5%B7%A5%E5%8D%8F%E8%AE%AE">乌托邦式的单工协议</a></li>
<li><a href="#%E7%AE%80%E5%8D%95%E7%9A%84-%E5%81%9C-%E7%AD%89-%E5%8D%8F%E8%AE%AE%E6%97%A0%E9%94%99%E4%BF%A1%E9%81%93">简单的 停-等 协议，无错信道</a></li>
<li><a href="#%E7%AE%80%E5%8D%95%E7%9A%84-%E5%81%9C-%E7%AD%89-%E5%8D%8F%E8%AE%AE%E4%BF%A1%E9%81%93%E5%8F%AF%E8%83%BD%E5%87%BA%E9%94%99">简单的 停-等 协议，信道可能出错</a></li>
<li><a href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8D%8F%E8%AE%AE">滑动窗口协议</a>
<ul>
<li><a href="#1-%E4%BD%8D-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">1 位 滑动窗口</a></li>
<li><a href="#%E5%A4%9A%E4%BD%8D%E7%AA%97%E5%8F%A3">多位窗口</a></li>
<li><a href="#go-back-n-%E5%9B%9E%E9%80%80-n-%E5%8D%8F%E8%AE%AE">Go-Back-N 回退 N 协议</a></li>
<li><a href="#selective-repeat-%E9%80%89%E6%8B%A9%E9%87%8D%E4%BC%A0">selective repeat 选择重传</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#ch4-%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82">ch4 介质访问控制子层</a>
<ul>
<li><a href="#%E5%A4%9A%E8%B7%AF%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE">多路访问协议</a>
<ul>
<li><a href="#aloha">ALOHA</a></li>
<li><a href="#%E5%88%86%E6%A7%BD-aloha">分槽 ALOHA</a></li>
<li><a href="#csma">CSMA</a>
<ul>
<li><a href="#persistent%E7%AD%89%E5%88%B0%E5%8D%A0%E7%94%A8%E7%BB%93%E6%9D%9F%E7%9B%B4%E6%8E%A5%E5%BC%80%E5%A7%8B%E5%8F%91">Persistent：等到占用结束直接开始发</a></li>
<li><a href="#nonpersistent">Nonpersistent</a></li>
<li><a href="#p-persistent">p-persistent</a></li>
</ul>
</li>
<li><a href="#csmacd-collision-detection">CSMA/CD collision detection</a></li>
<li><a href="#csmaca-collision-avoidance">CSMA/CA collision avoidance</a></li>
<li><a href="#bit-map-%E4%BD%8D%E5%9B%BE%E5%8D%8F%E8%AE%AE-%E6%97%A0%E5%86%B2%E7%AA%81">Bit-Map 位图协议 无冲突</a></li>
<li><a href="#token-ring-%E4%BB%A4%E7%89%8C%E7%8E%AF-%E6%97%A0%E5%86%B2%E7%AA%81">token ring 令牌环 无冲突</a></li>
<li><a href="#binary-countdown-%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%AE%A1%E6%95%B0-%E6%97%A0%E5%86%B2%E7%AA%81">binary countdown 二进制计数 无冲突</a></li>
<li><a href="#the-adaptive-tree-walk-protocol-%E8%87%AA%E9%80%82%E5%BA%94%E6%A0%91%E9%81%8D%E5%8E%86%E5%8D%8F%E8%AE%AE">The Adaptive Tree Walk Protocol 自适应树遍历协议</a></li>
</ul>
</li>
<li><a href="#%E4%BB%A5%E5%A4%AA%E7%BD%91">以太网</a>
<ul>
<li><a href="#%E8%AE%BE%E6%96%BD">设施</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#ch5-%E7%BD%91%E7%BB%9C%E5%B1%82">ch5 网络层</a>
<ul>
<li><a href="#%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95">路由算法</a>
<ul>
<li><a href="#dijstra-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84">Dijstra 最短路径</a></li>
<li><a href="#flooding-%E6%B3%9B%E6%B4%AA">flooding 泛洪</a></li>
<li><a href="#distance-vector-routing-%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F%E8%B7%AF%E7%94%B1">distance vector routing 距离向量路由</a></li>
<li><a href="#link-state-routing-%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E8%B7%AF%E7%94%B1">link state routing 链路状态路由</a></li>
<li><a href="#%E5%B1%82%E6%AC%A1%E8%B7%AF%E7%94%B1">层次路由</a></li>
<li><a href="#%E5%B9%BF%E6%92%AD%E8%B7%AF%E7%94%B1">广播路由</a></li>
</ul>
</li>
<li><a href="#%E7%BB%84%E6%92%AD%E8%B7%AF%E7%94%B1">组播路由</a>
<ul>
<li><a href="#anycast-routing-%E9%80%89%E6%92%AD%E8%B7%AF%E7%94%B1">anycast routing 选播路由</a></li>
</ul>
</li>
<li><a href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95">拥塞控制算法</a>
<ul>
<li><a href="#traffic-aware-routing">Traffic-Aware Routing</a></li>
<li><a href="#admission-control">admission control</a></li>
<li><a href="#load-shedding">load shedding</a></li>
<li><a href="#traffic-shaping">traffic shaping</a></li>
<li><a href="#active-queue-management-%E4%B8%BB%E5%8A%A8%E9%98%9F%E5%88%97%E7%AE%A1%E7%90%86">active queue management 主动队列管理</a></li>
<li><a href="#random-early-detection-%E9%9A%8F%E6%9C%BA%E6%97%A9%E6%9C%9F%E6%A3%80%E6%B5%8B">Random Early Detection 随机早期检测</a></li>
<li><a href="#choke-packets">choke packets</a></li>
<li><a href="#explicit-congestion-notification-%E6%98%BE%E5%BC%8F%E6%8B%A5%E5%A1%9E%E9%80%9A%E7%9F%A5">Explicit Congestion Notification 显式拥塞通知</a></li>
<li><a href="#hop-by-hop-backpressure">Hop-by-Hop Backpressure</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#ch6-%E4%BC%A0%E8%BE%93%E5%B1%82">ch6 传输层</a>
<ul>
<li><a href="#socket">Socket</a>
<ul>
<li><a href="#%E5%8E%9F%E8%AF%AD">原语</a></li>
<li><a href="#%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E7%A8%8B%E5%BA%8F">文件传输程序</a>
<ul>
<li><a href="#%E5%AE%A2%E6%88%B7%E7%AB%AF">客户端</a></li>
<li><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF">服务器端</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="computer-network-by-tanenbaum">Computer Network by Tanenbaum</h1>
<h2 id="ch1">ch1</h2>
<h3 id="term">term</h3>
<blockquote>
<p>broadcast</p>
<p>广播</p>
</blockquote>
<blockquote>
<p>point-to-point link</p>
<p>单播</p>
</blockquote>
<blockquote>
<p>multicasting</p>
<p>组播：只对一部分用户发送</p>
</blockquote>
<h3 id="分层">分层</h3>
<ul>
<li>physical layer
<ul>
<li>物理层。传输 raw bit</li>
</ul>
</li>
<li>data link layer
<ul>
<li>数据链路层。传输数据帧</li>
<li>为了控制通路，有时需要 介质控制子层 medium access control layer</li>
</ul>
</li>
<li>network layer
<ul>
<li>网络层。路由，包收发</li>
</ul>
</li>
<li>transport layer
<ul>
<li>传输层。主要负责向两个主机中进程之间的通信提供服务。TCP 协议</li>
</ul>
</li>
<li>application layer
<ul>
<li>应用层。HTTP，DNS</li>
</ul>
</li>
</ul>
<h2 id="ch2-物理层">ch2 物理层</h2>
<blockquote>
<p>SNR</p>
<p>Signal-to-Noise Ratio，信噪比，dB（分贝）单位（$10\log_{10}S/N$）</p>
</blockquote>
<h3 id="信道容量">信道容量</h3>
<p>$$\text{maximum data rate} = 2B \log_2 V \rm{bits/sec}$$</p>
<p>$$\text{maximum number of bits/sec} = B \log_2(1 + S/N)$$</p>
<h3 id="介质">介质</h3>
<ol>
<li>双绞线，几公里级，电话线，cat567</li>
<li>同轴电缆，Cu 制</li>
<li>光纤，带宽高，损失少</li>
<li>无线通信
<ol>
<li>一般使用单一窄频段( $\Delta f/f\ll 1$ )</li>
<li>跳频 frequency hopping spread spectrum</li>
<li>CDMA 码分多址，Code Division Multiple Access</li>
<li>FDM 频分复用，Frequency Division Multiplexing ^67f4ec</li>
<li>TDM 时分复用，Time Division Multiplexing</li>
<li>UWB 超宽频谱，Ultra-WideBand</li>
<li>RF
<ul>
<li>低频高 path loss， $1/r^2$ 损失，地波 VLF，LF，MF</li>
<li>高频直线，损失少，电离层反射 HF，VHF</li>
</ul>
</li>
</ol>
</li>
</ol>
<p><img loading="lazy" src="/assets/img/note/net/freq.png" alt="freq"  />
</p>
<p><img loading="lazy" src="/assets/img/note/net/tech.png" alt="tech"  />
</p>
<h3 id="调制">调制</h3>
<p><img loading="lazy" src="/assets/img/note/net/modulation.png" alt="modulation"  />
</p>
<h2 id="ch3-数据链路层">ch3 数据链路层</h2>
<ol>
<li>为网络层提供接口</li>
<li>检错纠错</li>
<li>调节数据流量，防止堵塞</li>
</ol>
<p>在 数据链路层 完成检错、确认等比起在网络层，更快速，更加底层。</p>
<h3 id="frame">frame</h3>
<p>从原始 bit 区分 frame。一般使用字符计数法和一种其它方法的组合</p>
<ol>
<li>bit 计数，若出错，对帧的影响较大</li>
<li>flag byte，填充 byte</li>
<li>flag bit，填充 bit</li>
<li>直接违反物理层编码，只适用于物理层编码有冗余的网络</li>
</ol>
<h3 id="检错纠错">检错纠错</h3>
<p>$(n,m)$ 码，当中 $n=m+r$</p>
<ol>
<li>hamming</li>
<li>二进制卷积</li>
<li>solmen Reed</li>
<li>低密度奇偶校验</li>
</ol>
<ul>
<li>奇偶</li>
<li>校验和</li>
<li>CRC</li>
</ul>
<h4 id="hamming">hamming</h4>
<blockquote>
<p>Hamming distance</p>
<p>海明距离，两个码字之间不同的对应比特位数目</p>
</blockquote>
<p>为了检查出 $d$ 个 bit 错，可以使用海明距离为 $d+1$ 的编码；为了纠正 $d$ 个错，可以使用海明距离为 $2d+1$ 的编码</p>
<p>对 $2^m$ 个有效信息(信息位数为 $m$ )中任何一个，有 $n=m+r$ 个与其距离为 1 的无效码字（n 位每位都可能出错），因此，每个 $2^m$ 中的合法消息需要 $n+1$ 个位模式来标识它们。有 $(n+1)2^m\le2^n$ ，或者是</p>
<p>$$(m+r+1)\le2^r$$</p>
<p>给定 $m$ ，利用该式可以得出校正单比特误码的校验位数目的下界。可采用 k 个码字组成 $k\times n$ 矩阵，按列发送，接收方恢复成 $k\times n$ 矩阵。$kr$个校验位， $km$ 个数据位，可纠正最多为 k 个的突发性连续比特错</p>
<h3 id="protocol">protocol</h3>
<ul>
<li>传输层协议 TCP 也提供可靠传输服务</li>
<li>链路层的可靠传输服务通常用于高误码率的连路上，如无线链路</li>
<li>对于误码率低的链路，链路层协议可以不实现可靠传输功能</li>
</ul>
<p><img loading="lazy" src="/assets/img/note/net/layer.png" alt="layer"  />
</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#define MAX_PKT 1024 </span><span class="cm">/* determines packet size in bytes */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span><span class="nb">false</span><span class="p">,</span> <span class="nb">true</span><span class="p">}</span> <span class="n">boolean</span><span class="p">;</span><span class="cm">/* boolean type */</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">seq_nr</span><span class="p">;</span><span class="cm">/* sequence or ack numbers */</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="n">MAX_PKT</span><span class="p">];}</span> <span class="n">packet</span><span class="p">;</span><span class="cm">/* packet definition */</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span><span class="n">data</span><span class="p">,</span> <span class="n">ack</span><span class="p">,</span> <span class="n">nak</span><span class="p">}</span> <span class="n">frame_kind</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* frame kind definition */</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* frames are transported in this layer */</span>
</span></span><span class="line"><span class="cl">    <span class="n">frame_kind</span> <span class="n">kind</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* what kind of frame is it? */</span>
</span></span><span class="line"><span class="cl">    <span class="n">seq_nr</span> <span class="n">seq</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* sequence number */</span>
</span></span><span class="line"><span class="cl">    <span class="n">seq_nr</span> <span class="n">ack</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* acknowledgement number */</span>
</span></span><span class="line"><span class="cl">    <span class="n">packet</span> <span class="n">info</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* the network layer packet */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">frame</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* Wait for an event to happen; return its type in event. */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">wait_for_event</span><span class="p">(</span><span class="n">event_type</span> <span class="o">*</span><span class="n">event</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* Fetch a packet from the network layer for transmission on the channel. */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">from_network_layer</span><span class="p">(</span><span class="n">packet</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* Deliver information from an inbound frame to the network layer. */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">to_network_layer</span><span class="p">(</span><span class="n">packet</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* Go get an inbound frame from the physical layer and copy it to r. */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">from_physical_layer</span><span class="p">(</span><span class="n">frame</span> <span class="o">*</span><span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* Pass the frame to the physical layer for transmission. */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">to_physical_layer</span><span class="p">(</span><span class="n">frame</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* Start the clock running and enable the timeout event. */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">start_timer</span><span class="p">(</span><span class="n">seq_nr</span> <span class="n">k</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* Stop the clock and disable the timeout event. */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">stop_timer</span><span class="p">(</span><span class="n">seq_nr</span> <span class="n">k</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* Start an auxiliary timer and enable the ack_timeout event. */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">start_ack_timer</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* Stop the auxiliary timer and disable the ack_timeout event. */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">stop_ack_timer</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* Allow the network layer to cause a network layer ready event. */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">enable_network_layer</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* Forbid the network layer from causing a network layer ready event. */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">disable_network_layer</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* Macro inc is expanded in-line: increment k circularly. */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define inc(k) if (k &lt; MAX_SEQ) k = k + 1; else k = 0
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>1 帧包含 4 个字段：</p>
<ol>
<li>kind：种类：控制信息帧还是数据帧</li>
<li>seq：帧序号</li>
<li>ack：回应</li>
<li>info：数据</li>
</ol>
<h4 id="乌托邦式的单工协议">乌托邦式的单工协议</h4>
<p>单边发送，单边接收。发送方和接收方的网络层总是处于准备就绪状态。数据处理的时间忽略不计。可用的缓存空间无穷大。最强的一个条件是数据链路层之间的通信信道永远不会损坏帧或者丢失帧。</p>
<ul>
<li>不进行流量控制</li>
<li>不检错纠错</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/* Protocol 1 (Utopia) provides for data transmission in one direction only, from
</span></span></span><span class="line"><span class="cl"><span class="cm">sender to receiver. The communication channel is assumed to be error free
</span></span></span><span class="line"><span class="cl"><span class="cm">and the receiver is assumed to be able to process all the input infinitely quickly.
</span></span></span><span class="line"><span class="cl"><span class="cm">Consequently, the sender just sits in a loop pumping data out onto the line as
</span></span></span><span class="line"><span class="cl"><span class="cm">fast as it can. */</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span><span class="n">frame_arrival</span><span class="p">}</span> <span class="n">event_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;protocol.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">sender1</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">frame</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* buffer for an outbound frame */</span>
</span></span><span class="line"><span class="cl">    <span class="n">packet</span> <span class="n">buffer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* buffer for an outbound packet */</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">from_network_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* go get something to send */</span>
</span></span><span class="line"><span class="cl">        <span class="n">s</span><span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* copy it into s for transmission */</span>
</span></span><span class="line"><span class="cl">        <span class="n">to_physical_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* send it on its way */</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* Tomorrow, and tomorrow, and tomorrow,
</span></span></span><span class="line"><span class="cl"><span class="cm">    Creeps in this petty pace from day to day
</span></span></span><span class="line"><span class="cl"><span class="cm">    To the last syllable of recorded time.
</span></span></span><span class="line"><span class="cl"><span class="cm">    – Macbeth, V, v */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">receiver1</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">frame</span> <span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">event_type</span> <span class="n">event</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* filled in by wait, but not used here */</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">wait_for_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* only possibility is frame_arrival */</span>
</span></span><span class="line"><span class="cl">        <span class="n">from_physical_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* go get the inbound frame */</span>
</span></span><span class="line"><span class="cl">        <span class="n">to_network_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="p">.</span><span class="n">info</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* pass the data to the network layer */</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="简单的-停-等-协议无错信道">简单的 停-等 协议，无错信道</h4>
<blockquote>
<p>stop-and-wait</p>
<p>发送方在接收方确认接受前，都等待的协议，用于流量控制</p>
</blockquote>
<p>双方交替发 frame，每个 frame 中含有上个 frame 的确认信息</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/* Protocol 2 (Stop-and-wait) also provides for a one-directional flow of data from
</span></span></span><span class="line"><span class="cl"><span class="cm">sender to receiver. The communication channel is once again assumed to be error
</span></span></span><span class="line"><span class="cl"><span class="cm">free, as in protocol 1. However, this time the receiver has only a finite buffer
</span></span></span><span class="line"><span class="cl"><span class="cm">capacity and a finite processing speed, so the protocol must explicitly prevent
</span></span></span><span class="line"><span class="cl"><span class="cm">the sender from flooding the receiver with data faster than it can be handled. */</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span><span class="n">frame_arrival</span><span class="p">}</span> <span class="n">event_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;protocol.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">void</span> <span class="nf">sender2</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">frame</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* buffer for an outbound frame */</span>
</span></span><span class="line"><span class="cl">    <span class="n">packet</span> <span class="n">buffer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* buffer for an outbound packet */</span>
</span></span><span class="line"><span class="cl">    <span class="n">event_type</span> <span class="n">event</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* frame_arrival is the only possibility */</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">from_network_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* go get something to send */</span>
</span></span><span class="line"><span class="cl">        <span class="n">s</span><span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* copy it into s for transmission */</span>
</span></span><span class="line"><span class="cl">        <span class="n">to_physical_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* bye-bye little frame */</span>
</span></span><span class="line"><span class="cl">        <span class="n">wait_for_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* do not proceed until given the go ahead */</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">receiver2</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">frame</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* buffers for frames */</span>
</span></span><span class="line"><span class="cl">    <span class="n">event_type</span> <span class="n">event</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* frame_arrival is the only possibility */</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">wait_for_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* only possibility is frame_arrival */</span>
</span></span><span class="line"><span class="cl">        <span class="n">from_physical_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* go get the inbound frame */</span>
</span></span><span class="line"><span class="cl">        <span class="n">to_network_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="p">.</span><span class="n">info</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* pass the data to the network layer */</span>
</span></span><span class="line"><span class="cl">        <span class="n">to_physical_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* send a dummy frame to awaken sender */</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="简单的-停-等-协议信道可能出错">简单的 停-等 协议，信道可能出错</h4>
<ul>
<li>需要加入计时器，防止 frame 丢失</li>
<li>需要标记帧号码，防止重复接收</li>
</ul>
<p>考虑 $m$ 帧和 $m+1$ 帧。如果 $m$ 帧没有发送成功，接收方不会确认；如果发送成功，接收方就会发确认消息。所以下一次发送方要么重发 $m$ 帧，要么接收到正确的确认消息，发 $m+1$ 帧。所以每次只需要区分 2 帧，帧号码只需要 1 位（单 bit）</p>
<blockquote>
<p>PAR (Positive</p>
<p>Positive Acknowledgement with Retransmission,带有重传的肯定确认</p>
</blockquote>
<blockquote>
<p>ARQ</p>
<p>Automatic Repeat reQuest,自动重复请求</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/* Protocol 3 (PAR) allows unidirectional data flow over an unreliable channel. */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define MAX_SEQ 1
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="cm">/* must be 1 for protocol 3 */</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span><span class="n">frame_arrival</span><span class="p">,</span> <span class="n">cksum_err</span><span class="p">,</span> <span class="n">timeout</span><span class="p">}</span> <span class="n">event_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;protocol.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">void</span> <span class="nf">sender3</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">seq_nr</span> <span class="n">next_frame_to_send</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* seq number of next outgoing frame */</span>
</span></span><span class="line"><span class="cl">    <span class="n">frame</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* scratch variable */</span>
</span></span><span class="line"><span class="cl">    <span class="n">packet</span> <span class="n">buffer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* buffer for an outbound packet */</span>
</span></span><span class="line"><span class="cl">    <span class="n">event_type</span> <span class="n">event</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">next_frame_to_send</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* initialize outbound sequence numbers */</span>
</span></span><span class="line"><span class="cl">    <span class="n">from_network_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* fetch first packet */</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">s</span><span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* construct a frame for transmission */</span>
</span></span><span class="line"><span class="cl">        <span class="n">s</span><span class="p">.</span><span class="n">seq</span> <span class="o">=</span> <span class="n">next_frame_to_send</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* insert sequence number in frame */</span>
</span></span><span class="line"><span class="cl">        <span class="n">to_physical_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* send it on its way */</span>
</span></span><span class="line"><span class="cl">        <span class="n">start_timer</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">seq</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* if answer takes too long, time out */</span>
</span></span><span class="line"><span class="cl">        <span class="n">wait_for_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* frame_arrival, cksum_err, timeout */</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">==</span> <span class="n">frame_arrival</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">from_physical_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* get the acknowledgement */</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">ack</span> <span class="o">==</span> <span class="n">next_frame_to_send</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">stop_timer</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">ack</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* turn the timer off */</span>
</span></span><span class="line"><span class="cl">                <span class="n">from_network_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* get the next one to send */</span>
</span></span><span class="line"><span class="cl">                <span class="n">inc</span><span class="p">(</span><span class="n">next_frame_to_send</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* invert next_frame_to_send */</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">receiver3</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">seq_nr</span> <span class="n">frame_expected</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">frame</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">event_type</span> <span class="n">event</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">frame_expected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">wait_for_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* possibilities: frame_arrival, cksum_err */</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">==</span> <span class="n">frame_arrival</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* a valid frame has arrived */</span>
</span></span><span class="line"><span class="cl">            <span class="n">from_physical_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* go get the newly arrived frame */</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">seq</span> <span class="o">==</span> <span class="n">frame_expected</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* this is what we have been waiting for */</span>
</span></span><span class="line"><span class="cl">                <span class="n">to_network_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="p">.</span><span class="n">info</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* pass the data to the network layer */</span>
</span></span><span class="line"><span class="cl">                <span class="n">inc</span><span class="p">(</span><span class="n">frame_expected</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* next time expect the other sequence nr */</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">s</span><span class="p">.</span><span class="n">ack</span> <span class="o">=</span> <span class="mi">1</span> <span class="err">−</span> <span class="n">frame_expected</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* tell which frame is being acked */</span>
</span></span><span class="line"><span class="cl">            <span class="n">to_physical_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* send acknowledgement */</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="滑动窗口协议">滑动窗口协议</h4>
<p>双工，而不是使用两个单工协议。</p>
<blockquote>
<p>piggybacking</p>
<p>捎带确认，不单独发送确认帧，而是把确认信息放在下一数据帧当中</p>
</blockquote>
<p>使用 sending window 和 receiving window。窗口数目对应帧所需缓存区大小</p>
<ul>
<li>sending window
<ul>
<li>窗口中保存需要发送的帧</li>
<li>新到的帧窗口扩张</li>
<li>收到确认后，窗口缩小</li>
</ul>
</li>
<li>receiving window
<ul>
<li>只接受窗口内序号的帧</li>
</ul>
</li>
</ul>
<p><img loading="lazy" src="/assets/img/note/net/slidingwin.png" alt="sliding windows"  />
</p>
<h5 id="1-位-滑动窗口">1 位 滑动窗口</h5>
<p><img loading="lazy" src="/assets/img/note/net/1bit.png" alt="1bit"  />
</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/* Protocol 4 (Sliding window) is bidirectional. */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define MAX_SEQ 1
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="cm">/* must be 1 for protocol 4 */</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span><span class="n">frame_arrival</span><span class="p">,</span> <span class="n">cksum_err</span><span class="p">,</span> <span class="n">timeout</span><span class="p">}</span> <span class="n">event_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;protocol.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">void</span> <span class="nf">protocol4</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">seq_nr</span> <span class="n">next_frame_to_send</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 0 or 1 only */</span>
</span></span><span class="line"><span class="cl">    <span class="n">seq_nr</span> <span class="n">frame_expected</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 0 or 1 only */</span>
</span></span><span class="line"><span class="cl">    <span class="n">frame</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* scratch variables */</span>
</span></span><span class="line"><span class="cl">    <span class="n">packet</span> <span class="n">buffer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* current packet being sent */</span>
</span></span><span class="line"><span class="cl">    <span class="n">event_type</span> <span class="n">event</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">next_frame_to_send</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* next frame on the outbound stream */</span>
</span></span><span class="line"><span class="cl">    <span class="n">frame_expected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* frame_expected next */</span>
</span></span><span class="line"><span class="cl">    <span class="n">from_network_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* fetch a packet from the network layer */</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* prepare to send the initial frame */</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="p">.</span><span class="n">seq</span> <span class="o">=</span> <span class="n">next_frame_to_send</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* insert sequence number into frame */</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="p">.</span><span class="n">ack</span> <span class="o">=</span> <span class="mi">1</span> <span class="err">−</span> <span class="n">frame_expected</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* piggybacked ack */</span>
</span></span><span class="line"><span class="cl">    <span class="n">to_physical_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* transmit the frame */</span>
</span></span><span class="line"><span class="cl">    <span class="n">start_timer</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">seq</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* start the timer running */</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">wait_for_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* frame_arrival, cksum_err, or timeout */</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">==</span> <span class="n">frame_arrival</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* a frame has arrived undamaged */</span>
</span></span><span class="line"><span class="cl">            <span class="n">from_physical_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* go get it */</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">seq</span> <span class="o">==</span> <span class="n">frame_expected</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* handle inbound frame stream */</span>
</span></span><span class="line"><span class="cl">                <span class="n">to_network_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="p">.</span><span class="n">info</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* pass packet to_network_layer */</span>
</span></span><span class="line"><span class="cl">                <span class="n">inc</span><span class="p">(</span><span class="n">frame_expected</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* invert seq number expected next */</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">ack</span> <span class="o">==</span> <span class="n">next_frame_to_send</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* handle outbound frame stream */</span>
</span></span><span class="line"><span class="cl">                <span class="n">stop_timer</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">ack</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* turn the timer off */</span>
</span></span><span class="line"><span class="cl">                <span class="n">from_network_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* fetch new pkt from_network_layer */</span>
</span></span><span class="line"><span class="cl">                <span class="n">inc</span><span class="p">(</span><span class="n">next_frame_to_send</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* invert sender’s sequence number */</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">s</span><span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* construct outbound frame */</span>
</span></span><span class="line"><span class="cl">        <span class="n">s</span><span class="p">.</span><span class="n">seq</span> <span class="o">=</span> <span class="n">next_frame_to_send</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* insert sequence number into it */</span>
</span></span><span class="line"><span class="cl">        <span class="n">s</span><span class="p">.</span><span class="n">ack</span> <span class="o">=</span> <span class="mi">1</span> <span class="err">−</span> <span class="n">frame_expected</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* seq number of last received frame */</span>
</span></span><span class="line"><span class="cl">        <span class="n">to_physical_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* transmit a frame */</span>
</span></span><span class="line"><span class="cl">        <span class="n">start_timer</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">seq</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* start the timer running */</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="多位窗口">多位窗口</h5>
<p>由于信道传输时间不可忽略，1 位滑动窗口的异常启动问题不可忽略，需要提高带宽利用率。</p>
<blockquote>
<p>bandwidth-delya product</p>
<p>$\text{带宽(bits/sec)}\times \text{单次传输时间}$</p>
<p>在以帧数为单位时，记作 BD</p>
</blockquote>
<p>在阻塞前，一次性发送$w=2BD+1$。如果考虑发送方连续发送帧并且在往返时间内收到一个确认，那么两倍的带宽-延时就是发送方可以连续发送的帧的个数；$+1$是因为必须接收完整个帧之后确认帧才会被发出。pipelining （排队发送帧）就能提高链路利用率。</p>
<p>$$\text{link utilization}=\frac{w}{1+2BD}$$</p>
<ul>
<li>go-back-n：放弃出错帧之后的正确帧（相当于窗口大小 1）</li>
<li>selective repeat，只放弃错误帧，缓存之后的正确帧</li>
</ul>
<p>两种策略分别平衡缓存区和带宽利用率。</p>
<p><img loading="lazy" src="/assets/img/note/net/gobackn.png" alt="go-back-n"  />
</p>
<h5 id="go-back-n-回退-n-协议">Go-Back-N 回退 N 协议</h5>
<p>最多发送$MAX_SEQ$个帧。虽然不需要缓存出错后到来的帧，但是它也没有因此完全摆脱缓存问题。由于发送方可能在将来的某个时刻要重传所有未被确认的帧，所以，它必须把已经发送出去的帧一直保留，直到它能肯定接收方已经接受了这些帧。对之前的帧，可以用软件模拟每个帧的时间计数器</p>
<blockquote>
<p>cumulative acknowledgement</p>
<p>累计确认，当$n$号帧到达，之前序号的帧自动被确认（因为回退特性）</p>
</blockquote>
<p><img loading="lazy" src="/assets/img/note/net/stime.png" alt="software timer"  />
</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/* Protocol 5 (Go-back-n) allows multiple outstanding frames. The sender may transmit up
</span></span></span><span class="line"><span class="cl"><span class="cm">to MAX_SEQ frames without waiting for an ack. In addition, unlike in the previous
</span></span></span><span class="line"><span class="cl"><span class="cm">protocols, the network layer is not assumed to have a new packet all the time. Instead,
</span></span></span><span class="line"><span class="cl"><span class="cm">the network layer causes a network layer ready event when there is a packet to send. */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define MAX_SEQ 7
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span><span class="n">frame_arrival</span><span class="p">,</span> <span class="n">cksum_err</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">network_layer_ready</span><span class="p">}</span> <span class="n">event_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;protocol.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">static</span> <span class="n">boolean</span> <span class="nf">between</span><span class="p">(</span><span class="n">seq_nr</span> <span class="n">a</span><span class="p">,</span> <span class="n">seq_nr</span> <span class="n">b</span><span class="p">,</span> <span class="n">seq_nr</span> <span class="n">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* Return true if a &lt;= b &lt; c circularly; false otherwise. */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(((</span><span class="n">a</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;</span> <span class="n">c</span><span class="p">))</span> <span class="o">||</span> <span class="p">((</span><span class="n">c</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">))</span> <span class="o">||</span> <span class="p">((</span><span class="n">b</span> <span class="o">&lt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">send_data</span><span class="p">(</span><span class="n">seq_nr</span> <span class="n">frame_nr</span><span class="p">,</span> <span class="n">seq_nr</span> <span class="n">frame_expected</span><span class="p">,</span> <span class="n">packet</span> <span class="n">buffer</span><span class="p">[</span> <span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* Construct and send a data frame. */</span>
</span></span><span class="line"><span class="cl">    <span class="n">frame</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* scratch variable */</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="n">frame_nr</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* insert packet into frame */</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="p">.</span><span class="n">seq</span> <span class="o">=</span> <span class="n">frame_nr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* insert sequence number into frame */</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="p">.</span><span class="n">ack</span> <span class="o">=</span> <span class="p">(</span><span class="n">frame_expected</span> <span class="o">+</span> <span class="n">MAX_SEQ</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">MAX_SEQ</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span><span class="cm">/* piggyback ack */</span>
</span></span><span class="line"><span class="cl">    <span class="n">to_physical_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* transmit the frame */</span>
</span></span><span class="line"><span class="cl">    <span class="n">start_timer</span><span class="p">(</span><span class="n">frame_nr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* start the timer running */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">protocol5</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">seq_nr</span> <span class="n">next_frame_to_send</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* MAX_SEQ &gt; 1; used for outbound stream */</span>
</span></span><span class="line"><span class="cl">    <span class="n">seq_nr</span> <span class="n">ack_expected</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* oldest frame as yet unacknowledged */</span>
</span></span><span class="line"><span class="cl">    <span class="n">seq_nr</span> <span class="n">frame_expected</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* next frame_expected on inbound stream */</span>
</span></span><span class="line"><span class="cl">    <span class="n">frame</span> <span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* scratch variable */</span>
</span></span><span class="line"><span class="cl">    <span class="n">packet</span> <span class="n">buffer</span><span class="p">[</span><span class="n">MAX_SEQ</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* buffers for the outbound stream */</span>
</span></span><span class="line"><span class="cl">    <span class="n">seq_nr</span> <span class="n">nbuffered</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* number of output buffers currently in use */</span>
</span></span><span class="line"><span class="cl">    <span class="n">seq_nr</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* used to index into the buffer array */</span>
</span></span><span class="line"><span class="cl">    <span class="n">event_type</span> <span class="n">event</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">enable_network_layer</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* allow network layer ready events */</span>
</span></span><span class="line"><span class="cl">    <span class="n">ack_expected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* next ack_expected inbound */</span>
</span></span><span class="line"><span class="cl">    <span class="n">next_frame_to_send</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* next frame going out */</span>
</span></span><span class="line"><span class="cl">    <span class="n">frame_expected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* number of frame_expected inbound */</span>
</span></span><span class="line"><span class="cl">    <span class="n">nbuffered</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* initially no packets are buffered */</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">wait_for_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* four possibilities: see event_type above */</span>
</span></span><span class="line"><span class="cl">        <span class="k">switch</span><span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">network_layer_ready</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* the network layer has a packet to send */</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* Accept, save, and transmit a new frame. */</span>
</span></span><span class="line"><span class="cl">            <span class="n">from_network_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">[</span><span class="n">next_frame_to_send</span><span class="p">]);</span> <span class="cm">/* fetch new packet */</span>
</span></span><span class="line"><span class="cl">            <span class="n">nbuffered</span> <span class="o">=</span> <span class="n">nbuffered</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* expand the sender’s window */</span>
</span></span><span class="line"><span class="cl">            <span class="n">send_data</span><span class="p">(</span><span class="n">next_frame_to_send</span><span class="p">,</span> <span class="n">frame_expected</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span><span class="cm">/* transmit the frame */</span>
</span></span><span class="line"><span class="cl">            <span class="n">inc</span><span class="p">(</span><span class="n">next_frame_to_send</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* advance sender’s upper window edge */</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">frame_arrival</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* a data or control frame has arrived */</span>
</span></span><span class="line"><span class="cl">            <span class="n">from_physical_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* get incoming frame from_physical_layer */</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">seq</span> <span class="o">==</span> <span class="n">frame_expected</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* Frames are accepted only in order. */</span>
</span></span><span class="line"><span class="cl">                <span class="n">to_network_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="p">.</span><span class="n">info</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* pass packet to_network_layer */</span>
</span></span><span class="line"><span class="cl">                <span class="n">inc</span><span class="p">(</span><span class="n">frame_expected</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* advance lower edge of receiver’s window */</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* Ack n implies n − 1, n − 2, etc. Check for this. */</span>
</span></span><span class="line"><span class="cl">            <span class="k">while</span> <span class="p">(</span><span class="n">between</span><span class="p">(</span><span class="n">ack_expected</span><span class="p">,</span> <span class="n">r</span><span class="p">.</span><span class="n">ack</span><span class="p">,</span> <span class="n">next_frame_to_send</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* Handle piggybacked ack. */</span>
</span></span><span class="line"><span class="cl">                <span class="n">nbuffered</span> <span class="o">=</span> <span class="n">nbuffered</span> <span class="err">−</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* one frame fewer buffered */</span>
</span></span><span class="line"><span class="cl">                <span class="n">stop_timer</span><span class="p">(</span><span class="n">ack_expected</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* frame arrived intact; stop_timer */</span>
</span></span><span class="line"><span class="cl">                <span class="n">inc</span><span class="p">(</span><span class="n">ack_expected</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* contract sender’s window */</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">cksum_err</span><span class="p">:</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* just ignore bad frames */</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">timeout</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* trouble; retransmit all outstanding frames */</span>
</span></span><span class="line"><span class="cl">            <span class="n">next_frame_to_send</span> <span class="o">=</span> <span class="n">ack_expected</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* start retransmitting here */</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">nbuffered</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">send_data</span><span class="p">(</span><span class="n">next_frame_to_send</span><span class="p">,</span> <span class="n">frame_expected</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span><span class="cm">/* resend_frame */</span>
</span></span><span class="line"><span class="cl">                <span class="n">inc</span><span class="p">(</span><span class="n">next_frame_to_send</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* prepare to send the next one */</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">nbuffered</span> <span class="o">&lt;</span> <span class="n">MAX_SEQ</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">enable_network_layer</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span>
</span></span><span class="line"><span class="cl">            <span class="n">disable_network_layer</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="selective-repeat-选择重传">selective repeat 选择重传</h5>
<p>针对错误更加频繁的情景。窗口移动后，和老的不重叠，防止老的重传和新的帧混淆。$\frac{(MAX_SEQ+1)}{2}$。启用一个辅助计时器，在没有反向数据帧时候单独发出确认帧。</p>
<blockquote>
<p>NAK</p>
<p>negative acknowledgement，否认确定记号。触发某一帧的重传</p>
</blockquote>
<p><img loading="lazy" src="/assets/img/note/net/wsize.png" alt="window size"  />
</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/* Protocol 6 (Selective repeat) accepts frames out of order but passes packets to the
</span></span></span><span class="line"><span class="cl"><span class="cm">network layer in order. Associated with each outstanding frame is a timer. When the timer
</span></span></span><span class="line"><span class="cl"><span class="cm">expires, only that frame is retransmitted, not all the outstanding frames, as in protocol 5. */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define MAX_SEQ 7
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="cm">/* should be 2ˆn − 1 */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define NR_BUFS ((MAX_SEQ + 1)/2)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span><span class="n">frame_arrival</span><span class="p">,</span> <span class="n">cksum_err</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">network_layer_ready</span><span class="p">,</span> <span class="n">ack_timeout</span><span class="p">}</span> <span class="n">event_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;protocol.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">boolean</span> <span class="n">no_nak</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* no_nak has been sent yet */</span>
</span></span><span class="line"><span class="cl"><span class="n">seq_nr</span> <span class="n">oldest_frame</span> <span class="o">=</span> <span class="n">MAX_SEQ</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* initial value is only for the simulator */</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="n">boolean</span> <span class="nf">between</span><span class="p">(</span><span class="n">seq_nr</span> <span class="n">a</span><span class="p">,</span> <span class="n">seq_nr</span> <span class="n">b</span><span class="p">,</span> <span class="n">seq_nr</span> <span class="n">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* Same as between in protocol 5, but shorter and more obscure. */</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">((</span><span class="n">a</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;</span> <span class="n">c</span><span class="p">))</span> <span class="o">||</span> <span class="p">((</span><span class="n">c</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">))</span> <span class="o">||</span> <span class="p">((</span><span class="n">b</span> <span class="o">&lt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">send_frame</span><span class="p">(</span><span class="n">frame_kind</span> <span class="n">fk</span><span class="p">,</span> <span class="n">seq_nr</span> <span class="n">frame_nr</span><span class="p">,</span> <span class="n">seq_nr</span> <span class="n">frame_expected</span><span class="p">,</span> <span class="n">packet</span> <span class="n">buffer</span><span class="p">[</span> <span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* Construct and send a data, ack, or nak frame. */</span>
</span></span><span class="line"><span class="cl">    <span class="n">frame</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* scratch variable */</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="p">.</span><span class="n">kind</span> <span class="o">=</span> <span class="n">fk</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* kind == data, ack, or nak */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">fk</span> <span class="o">==</span> <span class="n">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">s</span><span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="n">frame_nr</span> <span class="o">%</span> <span class="n">NR_BUFS</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="p">.</span><span class="n">seq</span> <span class="o">=</span> <span class="n">frame_nr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* only meaningful for data frames */</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="p">.</span><span class="n">ack</span> <span class="o">=</span> <span class="p">(</span><span class="n">frame_expected</span> <span class="o">+</span> <span class="n">MAX_SEQ</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">MAX_SEQ</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">fk</span> <span class="o">==</span> <span class="n">nak</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">no_nak</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* one nak per frame, please */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">to_physical_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* transmit the frame */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">fk</span> <span class="o">==</span> <span class="n">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">start_timer</span><span class="p">(</span><span class="n">frame_nr</span> <span class="o">%</span> <span class="n">NR_BUFS</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">stop_ack_timer</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* no need for separate ack frame */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">protocol6</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">seq_nr</span> <span class="n">ack_expected</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* lower edge of sender’s window */</span>
</span></span><span class="line"><span class="cl">    <span class="n">seq_nr</span> <span class="n">next_frame_to_send</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* upper edge of sender’s window + 1 */</span>
</span></span><span class="line"><span class="cl">    <span class="n">seq_nr</span> <span class="n">frame_expected</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* lower edge of receiver’s window */</span>
</span></span><span class="line"><span class="cl">    <span class="n">seq_nr</span> <span class="n">too</span> <span class="n">far</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* upper edge of receiver’s window + 1 */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* index into buffer pool */</span>
</span></span><span class="line"><span class="cl">    <span class="n">frame</span> <span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* scratch variable */</span>
</span></span><span class="line"><span class="cl">    <span class="n">packet</span> <span class="n">out_buf</span><span class="p">[</span><span class="n">NR_BUFS</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* buffers for the outbound stream */</span>
</span></span><span class="line"><span class="cl">    <span class="n">packet</span> <span class="n">in_buf</span><span class="p">[</span><span class="n">NR_BUFS</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* buffers for the inbound stream */</span>
</span></span><span class="line"><span class="cl">    <span class="n">boolean</span> <span class="n">arrived</span><span class="p">[</span><span class="n">NR_BUFS</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* inbound bit map */</span>
</span></span><span class="line"><span class="cl">    <span class="n">seq_nr</span> <span class="n">nbuffered</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* how many output buffers currently used */</span>
</span></span><span class="line"><span class="cl">    <span class="n">event_type</span> <span class="n">event</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">enable_network_layer</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* initialize */</span>
</span></span><span class="line"><span class="cl">    <span class="n">ack_expected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* next ack_expected on the inbound stream */</span>
</span></span><span class="line"><span class="cl">    <span class="n">next_frame_to_send</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* number of next outgoing frame */</span>
</span></span><span class="line"><span class="cl">    <span class="n">frame_expected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">too_far</span> <span class="o">=</span> <span class="n">NR_BUFS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">nbuffered</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* initially no packets are buffered */</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_BUFS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">arrived</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">wait_for_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* five possibilities: see event_type above */</span>
</span></span><span class="line"><span class="cl">        <span class="k">switch</span><span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">network_layer_ready</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* accept, save, and transmit a new frame */</span>
</span></span><span class="line"><span class="cl">            <span class="n">nbuffered</span> <span class="o">=</span> <span class="n">nbuffered</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* expand the window */</span>
</span></span><span class="line"><span class="cl">            <span class="n">from_network_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">out_buf</span><span class="p">[</span><span class="n">next_frame_to_send</span> <span class="o">%</span> <span class="n">NR_BUFS</span><span class="p">]);</span> <span class="cm">/* fetch new packet */</span>
</span></span><span class="line"><span class="cl">            <span class="n">send_frame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">next_frame_to_send</span><span class="p">,</span> <span class="n">frame_expected</span><span class="p">,</span> <span class="n">out_buf</span><span class="p">);</span><span class="cm">/* transmit the frame */</span>
</span></span><span class="line"><span class="cl">            <span class="n">inc</span><span class="p">(</span><span class="n">next_frame_to_send</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* advance upper window edge */</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">frame_arrival</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* a data or control frame has arrived */</span>
</span></span><span class="line"><span class="cl">            <span class="n">from_physical_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* fetch incoming frame from_physical_layer */</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="cm">/* An undamaged frame has arrived. */</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">((</span><span class="n">r</span><span class="p">.</span><span class="n">seq</span> <span class="o">!=</span> <span class="n">frame_expected</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">no_nak</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="n">send_frame</span><span class="p">(</span><span class="n">nak</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">frame_expected</span><span class="p">,</span> <span class="n">out_buf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">else</span>
</span></span><span class="line"><span class="cl">                    <span class="n">start_ack_timer</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">between</span><span class="p">(</span><span class="n">frame_expected</span><span class="p">,</span><span class="n">r</span><span class="p">.</span><span class="n">seq</span><span class="p">,</span><span class="n">too</span> <span class="n">far</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">arrived</span><span class="p">[</span><span class="n">r</span><span class="p">.</span><span class="n">seq</span><span class="o">%</span><span class="n">NR_BUFS</span><span class="p">]</span><span class="o">==</span><span class="nb">false</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="cm">/* Frames may be accepted in any order. */</span>
</span></span><span class="line"><span class="cl">                    <span class="n">arrived</span><span class="p">[</span><span class="n">r</span><span class="p">.</span><span class="n">seq</span> <span class="o">%</span> <span class="n">NR_BUFS</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="cm">/* mark buffer as full */</span>
</span></span><span class="line"><span class="cl">                    <span class="n">in_buf</span><span class="p">[</span><span class="n">r</span><span class="p">.</span><span class="n">seq</span> <span class="o">%</span> <span class="n">NR_BUFS</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="p">.</span><span class="n">info</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="cm">/* insert data into buffer */</span>
</span></span><span class="line"><span class="cl">                    <span class="k">while</span> <span class="p">(</span><span class="n">arrived</span><span class="p">[</span><span class="n">frame_expected</span> <span class="o">%</span> <span class="n">NR_BUFS</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="cm">/* Pass frames and advance window. */</span>
</span></span><span class="line"><span class="cl">                        <span class="n">to_network_layer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">in_buf</span><span class="p">[</span><span class="n">frame_expected</span> <span class="o">%</span> <span class="n">NR_BUFS</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">                        <span class="n">no_nak</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                        <span class="n">arrived</span><span class="p">[</span><span class="n">frame_expected</span> <span class="o">%</span> <span class="n">NR_BUFS</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                        <span class="n">inc</span><span class="p">(</span><span class="n">frame_expected</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                        <span class="cm">/* advance lower edge of receiver’s window */</span>
</span></span><span class="line"><span class="cl">                        <span class="n">inc</span><span class="p">(</span><span class="n">too</span> <span class="n">far</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                        <span class="cm">/* advance upper edge of receiver’s window */</span>
</span></span><span class="line"><span class="cl">                        <span class="n">start_ack_timer</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                        <span class="cm">/* to see if a separate ack is needed */</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">((</span><span class="n">r</span><span class="p">.</span><span class="n">kind</span><span class="o">==</span><span class="n">nak</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">between</span><span class="p">(</span><span class="n">ack_expected</span><span class="p">,(</span><span class="n">r</span><span class="p">.</span><span class="n">ack</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="p">(</span><span class="n">MAX_SEQ</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">next_frame_to_send</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="n">send_frame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">ack</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">MAX_SEQ</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">frame_expected</span><span class="p">,</span> <span class="n">out_buf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">while</span> <span class="p">(</span><span class="n">between</span><span class="p">(</span><span class="n">ack_expected</span><span class="p">,</span> <span class="n">r</span><span class="p">.</span><span class="n">ack</span><span class="p">,</span> <span class="n">next_frame_to_send</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">nbuffered</span> <span class="o">=</span> <span class="n">nbuffered</span> <span class="err">−</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* handle piggybacked ack */</span>
</span></span><span class="line"><span class="cl">                <span class="n">stop_timer</span><span class="p">(</span><span class="n">ack_expected</span> <span class="o">%</span> <span class="n">NR_BUFS</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* frame arrived intact */</span>
</span></span><span class="line"><span class="cl">                <span class="n">inc</span><span class="p">(</span><span class="n">ack_expected</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* advance lower edge of sender’s window */</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">cksum_err</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">no_nak</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">send_frame</span><span class="p">(</span><span class="n">nak</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">frame_expected</span><span class="p">,</span> <span class="n">out_buf</span><span class="p">);</span> <span class="cm">/* damaged frame */</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">timeout</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">send_frame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">oldest_frame</span><span class="p">,</span> <span class="n">frame_expected</span><span class="p">,</span> <span class="n">out_buf</span><span class="p">);</span> <span class="cm">/* we timed out */</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">ack_timeout</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">send_frame</span><span class="p">(</span><span class="n">ack</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">frame_expected</span><span class="p">,</span> <span class="n">out_buf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* ack timer expired; send ack */</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">nbuffered</span> <span class="o">&lt;</span> <span class="n">NR_BUFS</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">enable_network_layer</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span>
</span></span><span class="line"><span class="cl">            <span class="n">disable_network_layer</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="ch4-介质访问控制子层">ch4 介质访问控制子层</h2>
<blockquote>
<p>MAC</p>
<p>Medium Access Control</p>
</blockquote>
<p>在多用户之间分配单广播信道。FDM（频分复用）效率不高。信道速度 $C \rm{bps}$ ，每帧 $1/\mu\rm{bit}$ ，帧到达速度 $\lambda\rm{frames/sec}$ 。实际延时</p>
<p>$$T=\frac{1}{\mu C -\lambda}$$</p>
<p>如果信道等分 $N$ 份，延时大幅度增加。因此需要动态分配信道</p>
<p>$$T_N=\frac{1}{\mu (C/N) -(\lambda/N)}=\frac{N}{\mu C -\lambda}=NT$$</p>
<ol>
<li>流量独立，在 $\Delta_t$ 时间间隔中，帧数期望为 $\lambda\Delta_t$ （假定是泊松分布，而暂时不考虑突发流量）</li>
<li>单信道，核心，没有其他外部手段通信/核对信息</li>
<li>冲突可观察</li>
<li>时间连续/分槽 slotted</li>
<li>载波侦听 carrirer sense 或不听</li>
</ol>
<h3 id="多路访问协议">多路访问协议</h3>
<blockquote>
<p>contention system</p>
<p>竞争系统：共享信道，被同时发送帧而都失效</p>
</blockquote>
<p><img loading="lazy" src="/assets/img/note/net/thorouput.png" alt="thorouput"  />
</p>
<h4 id="aloha">ALOHA</h4>
<p>有数据直接发，如果碰撞，在等待随机时间之后重发。</p>
<p>假设帧等长，发送用时$t$，帧产生服从泊松分布，一个“帧时”平均有 G 帧，实际产生 k 帧概率为</p>
<p>$$\mathrm{Pr[k]}=\frac{G^ke^{-G}}{k!}$$</p>
<p>一帧在$2t$中任意有 1 帧产生都会损毁，因此吞吐量最终为</p>
<p>$$S=Ge^{-2G}$$</p>
<p><img loading="lazy" src="/assets/img/note/net/aloha.png" alt="aloha"  />
</p>
<h4 id="分槽-aloha">分槽 ALOHA</h4>
<p>要求每帧必须在时间槽开始时才能尝试发送，不能在任意时刻发送，只需要考虑单槽$t$内的碰撞。吞吐量</p>
<p>$$S=Ge^{-G}$$</p>
<p>1 帧需要 k 次尝试的几率为</p>
<p>$$P_k=e^{-G}(1-e^{-G})^{k-1}$$</p>
<p>传输次数期望为</p>
<p>$$E=\sum kP_k=\sum ke^{-G}(1-e^{-G})^{k-1}=e^G$$</p>
<h4 id="csma">CSMA</h4>
<blockquote>
<p>CSMA</p>
<p>Carrier Sense Multiple Access，载波侦听多路访问协议</p>
</blockquote>
<p>在发送自己帧之前，监听是否信道被占用，不占用再发送；如果占用</p>
<h5 id="persistent等到占用结束直接开始发">Persistent：等到占用结束直接开始发</h5>
<p>会在同时多站等发时候冲突</p>
<h5 id="nonpersistent">Nonpersistent</h5>
<p>等待一段时间后再检测</p>
<h5 id="p-persistent">p-persistent</h5>
<p>针对分槽时间，每个槽如果空闲，以$p$的概率发，$1-p$的概率等下个时间槽。</p>
<p>如果有 k 个站需要传数据，站得发送的概率$P$为</p>
<p>$$P=kp(1-p)^{k-1}$$</p>
<p>在$p=\frac{1}{k}$时候有$P_\max$为</p>
<p>$$P_\max=(\frac{k-1}{k})^{k-1}$$</p>
<p>而且$k\to\infty$时候有$P\to\frac{1}{e}$。</p>
<h4 id="csmacd-collision-detection">CSMA/CD collision detection</h4>
<p>在发送前，信道空闲时候，发送竞争信号，竞争胜利者发送数据帧</p>
<p><img loading="lazy" src="/assets/img/note/net/csmacd.png" alt="CSMA/CD"  />
</p>
<h4 id="csmaca-collision-avoidance">CSMA/CA collision avoidance</h4>
<blockquote>
<p>binary exponential backoff</p>
<p>二进制指数后退。在$i$次碰撞后，在[[ch4 介质访问控制子层#p-persistent|p-persistent CSMA]]基础上改为等待$0\sim2^i-1$个时间槽</p>
</blockquote>
<p>实际中，有时间槽次数上限和碰撞次数上限</p>
<p>竞争时间间隔为$j$的概率</p>
<p>$$P_{t=jT_0}=P(1-P)^{j-1}$$</p>
<p>每次竞争平均时间槽数为</p>
<p>$$E=\sum_{j=0} jP(1-P)^{j-1}=\frac{1}{P}$$</p>
<h4 id="bit-map-位图协议-无冲突">Bit-Map 位图协议 无冲突</h4>
<p>信道中有公共信息广播时间。在该时间里，每个站有一个槽，发送信息表示接下来需要发送数据帧；沉默表示接下来不发。然后站按照申请的结果发。平均等待$N$个槽时间</p>
<h4 id="token-ring-令牌环-无冲突">token ring 令牌环 无冲突</h4>
<p>所有站连接成一个单环结构，传递令牌。得到令牌的发数据，发完继续传；如果不用发数据直接向下传</p>
<h4 id="binary-countdown-二进制计数-无冲突">binary countdown 二进制计数 无冲突</h4>
<p>信道中有公共信息广播时间，所有站监听。如果需要发数据，从高位开始，在对应时间槽中发送自己优先级（唯一，二进制表示）消息，消息之间是<strong>或</strong>关系。只有知道自己是优先级最高的才能接下来发送。竞争用时$\log_2N$</p>
<h4 id="the-adaptive-tree-walk-protocol-自适应树遍历协议">The Adaptive Tree Walk Protocol 自适应树遍历协议</h4>
<p>注意到，如果竞争站的数目$k$比较小时候，[[ch4 介质访问控制子层#p-persistent|获得信道概率]]会上升。因此可以通过分组减少竞争，极大提升信道使用效果</p>
<p>自适应树中，将站看作是二叉树的叶节点，从根节点开始搜索。如果某个节点冲突，向下探寻左、右子节点；如果左节点不冲突了，给左节点下需求站发送数据；下一时间槽给右节点的站。在公共广播期间，站按照自身的父节点被搜索到的顺序竞争时间槽。</p>
<p>如果$q$个站随机均匀分布，在让每个槽中参与竞争的平均站数为 1 时，得到最优树高$1+\log_2q$</p>
<h3 id="以太网">以太网</h3>
<h4 id="设施">设施</h4>
<table>
<thead>
<tr>
<th></th>
<th>hub 集线器</th>
<th>switch 交换机</th>
</tr>
</thead>
<tbody>
<tr>
<td>pro</td>
<td>易排错</td>
<td>扩容；无冲突；安全</td>
</tr>
<tr>
<td>con</td>
<td>不能扩容，逻辑上等同单线缆</td>
<td>自带 buffer 防止同时发送端口</td>
</tr>
</tbody>
</table>
<h2 id="ch5-网络层">ch5 网络层</h2>
<ol>
<li>向上提供的服务应该独立于路由器技术</li>
<li>应该向传输层屏蔽路由器的数量、类型和拓扑关系</li>
<li>传输层可用的网络地址应该有一个统一编址方案，甚至可以跨越 LAN 和 WAN</li>
</ol>
<blockquote>
<p>datagram</p>
<p>数据报网络，所有的数据包都被独立地注入到网络中，并且每个数据包独立路由，不需要提前建立任何设置</p>
</blockquote>
<blockquote>
<p>virtual circuit</p>
<p>虚电路网络，在发送数据包之前，必须首先建立起一条从源路由器到目标路由器之间的路径</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>datagram</th>
<th style="text-align:left">virtual-circuit</th>
</tr>
</thead>
<tbody>
<tr>
<td>线路初始化</td>
<td>不需要</td>
<td style="text-align:left">需要</td>
</tr>
<tr>
<td>寻址</td>
<td>包带有源和目标地址</td>
<td style="text-align:left">包带有短 VC 号</td>
</tr>
<tr>
<td>状态信息</td>
<td>路由不包含连接信息</td>
<td style="text-align:left">每条虚电路（VC）需要路由记录每个连接</td>
</tr>
<tr>
<td>路由</td>
<td>每个包单独路由</td>
<td style="text-align:left">VC 设置时候路由，包遵守</td>
</tr>
<tr>
<td>路由失效影响</td>
<td>无，除了因为崩溃丢的包</td>
<td style="text-align:left">故障路由相关 VC 均中断</td>
</tr>
<tr>
<td>服务质量</td>
<td>困难</td>
<td style="text-align:left">简单，如果建立 VC 时候资源足够</td>
</tr>
<tr>
<td>拥塞控制</td>
<td>困难</td>
<td style="text-align:left">简单，如果建立 VC 时候资源足够</td>
</tr>
</tbody>
</table>
<h3 id="路由算法">路由算法</h3>
<blockquote>
<p>routing algorithm</p>
<p>路由算法。网络层软件决定入境数据包在哪条线外发</p>
</blockquote>
<blockquote>
<p>optimality principle</p>
<p>路由最优化原理。如果路由 J 在 I 到 K 最优路径，那么 J 到 K 最优路径也是同样的路由</p>
</blockquote>
<blockquote>
<p>sink tree</p>
<p>汇集树。从所有的源到一个指定目标的最优路径的集合构成了一棵以目标节点为根的树/DAG（有向无环图）</p>
</blockquote>
<blockquote>
<p>spanning tree</p>
<p>包含所有路由器的树，不一定是最优路径（和[[ch5 网络层#^7ddb3a|汇集树]]相区别）</p>
</blockquote>
<h4 id="dijstra-最短路径">Dijstra 最短路径</h4>
<p>每次找到距离源距离最近（距离=到已发现集合的某点距离+该点距离源距离）的新节点，加入发现集合</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#define MAX_NODES 1024
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="cm">/* maximum number of nodes */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define INFINITY 1000000000
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="cm">/* a number larger than every maximum path */</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">dist</span><span class="p">[</span><span class="n">MAX_NODES</span><span class="p">][</span><span class="n">MAX_NODES</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* dist[i][j] is the distance from i to j */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">shortest</span> <span class="nf">path</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">path</span><span class="p">[])</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">state</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* the path being worked on */</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">predecessor</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* previous node */</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* length from source to this node */</span>
</span></span><span class="line"><span class="cl">        <span class="k">enum</span> <span class="p">{</span><span class="n">permanent</span><span class="p">,</span> <span class="n">tentative</span><span class="p">}</span> <span class="n">label</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* label state */</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="n">state</span><span class="p">[</span><span class="n">MAX_NODES</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">min</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">state</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">state</span><span class="p">[</span><span class="n">n</span><span class="p">];</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* initialize state */</span>
</span></span><span class="line"><span class="cl">        <span class="n">p</span><span class="o">-&gt;</span><span class="n">predecessor</span> <span class="o">=</span> <span class="err">−</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">p</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">INFINITY</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">p</span><span class="o">-&gt;</span><span class="n">label</span> <span class="o">=</span> <span class="n">tentative</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="p">[</span><span class="n">t</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">state</span><span class="p">[</span><span class="n">t</span><span class="p">].</span><span class="n">label</span> <span class="o">=</span> <span class="n">permanent</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">k</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* k is the initial working node */</span>
</span></span><span class="line"><span class="cl">    <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* Is there a better path from k? */</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span> <span class="c1">//n node
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">label</span> <span class="o">==</span> <span class="n">tentative</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">length</span> <span class="o">+</span> <span class="n">dist</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">predecessor</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">length</span> <span class="o">+</span> <span class="n">dist</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* Find the tentatively labeled node with the smallest label. */</span>
</span></span><span class="line"><span class="cl">        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">min</span> <span class="o">=</span> <span class="n">INFINITY</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">label</span> <span class="o">==</span> <span class="n">tentative</span> <span class="o">&amp;&amp;</span> <span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span> <span class="o">&lt;</span> <span class="n">min</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">min</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">state</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">label</span> <span class="o">=</span> <span class="n">permanent</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">k</span> <span class="o">!=</span> <span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* Copy the path into the output array. */</span>
</span></span><span class="line"><span class="cl">    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">do</span> <span class="p">{</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span> <span class="n">k</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">predecessor</span><span class="p">;</span> <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="flooding-泛洪">flooding 泛洪</h4>
<p>每一个入境数据包发送到除了该数据包到达的那条线路以外的每条出境线路</p>
<ol>
<li>泛洪包带有寿命，计数减到 0 之后不再发</li>
<li>追踪泛洪包防止二次发送。泛洪包带序号，一个序号对应一次泛洪，一次泛洪只发送一次</li>
</ol>
<ul>
<li>保证广播</li>
<li>robust</li>
</ul>
<h4 id="distance-vector-routing-距离向量路由">distance vector routing 距离向量路由</h4>
<p>每个路由器维护一张表（即一个矢量)，表中列出了当前已知的到每个目标的最佳距离，以及所使用的链路。这些表通过邻居之间相互交换信息而不断被更新，最终每个路由器都了解到达每个目的地的最佳链路。</p>
<p>又名 Bellman-Fold 算法</p>
<blockquote>
<p>Count-to-Infinity</p>
<p>无穷计数问题。坏消息传递慢，距离每次增 1 而已（没有一个路由器具有一个比它所有邻居的最小值还大于 1 的值，从邻居获得道路信息不包含自身是否在道路上）</p>
</blockquote>
<h4 id="link-state-routing-链路状态路由">link state routing 链路状态路由</h4>
<ol>
<li>发现它的邻居节点，并了解其网络地址</li>
<li>设置到每个邻居节点的距离或者成本度量值</li>
<li>构造一个包含所有刚刚获知的链路信息包</li>
<li>将这个包发送给所有其他的路由器，并接收来自所有其他路由器的信息包</li>
<li>计算出到每个其他路由器的最短路径</li>
</ol>
<p>每个路由都知道网络拓扑结构，每个路由自行完成<a href="#dijstra-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84">Dijstra 最短路径算法</a></p>
<h4 id="层次路由">层次路由</h4>
<p>分层。可以证明对于 $N$ 路由数目网络最优层数 $\ln N$，每个路由器查找表条目 $e\ln N$。</p>
<h4 id="广播路由">广播路由</h4>
<blockquote>
<p>multidestination routing</p>
<p>多目标路由。每个数据包包含一组目标地址，路由对于某条线上转发时候只保留线连接区域地址，直到只发给 1 个目标地址</p>
</blockquote>
<blockquote>
<p>reverse path forwarding</p>
<p>逆向路径转发。检测数据包是否来自汇集树（或者放宽为优化的生成树），否则丢弃，结合<a href="#flooding-%E6%B3%9B%E6%B4%AA">泛洪</a></p>
</blockquote>
<ol>
<li>每个路由单独发包</li>
<li><a href="#flooding-%E6%B3%9B%E6%B4%AA">泛洪</a></li>
<li>多目标路由</li>
</ol>
<h3 id="组播路由">组播路由</h3>
<blockquote>
<p>core-based tree</p>
<p>基于核心树。只对核心（core/root）建生成树</p>
</blockquote>
<ol>
<li>干脆 <a href="#%E5%B9%BF%E6%92%AD%E8%B7%AF%E7%94%B1">广播路由</a></li>
<li>修建生成树，按需要传播</li>
<li>其他路由先发到核心，核心走核心树</li>
</ol>
<h4 id="anycast-routing-选播路由">anycast routing 选播路由</h4>
<blockquote>
<p>anycast</p>
<p>数据包发送到特定一个组中最近的一个路由</p>
</blockquote>
<h3 id="拥塞控制算法">拥塞控制算法</h3>
<blockquote>
<p>bufferfloat</p>
<p>路由内存充足反而容易导致拥塞。数据包（本来会因为内存不足丢弃）排到队列前面时，它们早己经超时（重复地）并且它们的副本也己经发送</p>
</blockquote>
<p><img loading="lazy" src="/assets/img/note/net/congestc.png" alt="congestion control"  />
</p>
<h4 id="traffic-aware-routing">Traffic-Aware Routing</h4>
<p>流量感知路由。将负载考虑到路由选择上，但不能直接使用流量调整，防止路由选择波动。</p>
<h4 id="admission-control">admission control</h4>
<p>准入控制。只能针对虚电路网络，在可承担负载情况下才建立新连接。</p>
<h4 id="load-shedding">load shedding</h4>
<p>负载脱落。直接抛弃负载保证不拥塞。抛弃优先级可以结合流量费用设定。</p>
<blockquote>
<p>wine</p>
<p>旧数据包保留：如文件传输</p>
</blockquote>
<blockquote>
<p>milk</p>
<p>新数据包保留：如流媒体</p>
</blockquote>
<h4 id="traffic-shaping">traffic shaping</h4>
<p>流量整形。</p>
<p>桶容量 $B$ ，数据速率 $R$</p>
<blockquote>
<p>leaky bucket</p>
<p>漏桶。向缓冲区发包，包以 $R$ 离开缓冲区</p>
</blockquote>
<blockquote>
<p>token bucket</p>
<p>令牌桶。令牌以 $R$ 速度累计， 得到令牌才能发包</p>
</blockquote>
<p>流量突发时长 $S$ ，突发产生速率 $M$ ，则桶算法有</p>
<p>$$B+RS=MS$$</p>
<p>还可以级联桶，调控平均速率和突发最大速率。</p>
<p><img loading="lazy" src="/assets/img/note/net/bucket.png" alt="bucket algorithm"  />
</p>
<h4 id="active-queue-management-主动队列管理">active queue management 主动队列管理</h4>
<p>主动管理负载避免拥塞，路由监控自己使用的资源。期待延迟为 $d$ ，队列长度 $s$ ，有关系式</p>
<p>$$d_{new}=\alpha d_{old}+(1-\alpha)s$$</p>
<blockquote>
<p>Exponentially Weighted Moving Average</p>
<p>EWMA，指数加权移动平均。 $\alpha$ 是路由遗忘历史信息的常数。等同于低通滤波器。 期待延迟 $d$ 超过阈值预示拥塞发生</p>
</blockquote>
<h4 id="random-early-detection-随机早期检测">Random Early Detection 随机早期检测</h4>
<p>RED。因为路由难以得到显式信息通知拥塞，只有包丢失是容易感知的，但是包丢失对于避免拥塞太晚了。当某条链路上的平均队列长度超过某个阈值时，该链路就被认为即将拥塞，因此路由器随机丢弃一小部分数据包。隐含传递拥塞信号</p>
<h4 id="choke-packets">choke packets</h4>
<p>直接向发送方回传拥塞发生的通知数据包。</p>
<h4 id="explicit-congestion-notification-显式拥塞通知">Explicit Congestion Notification 显式拥塞通知</h4>
<p>ECN。不单独[[ch5 网络层#choke packets|发包]]，在包中间标志位标记拥塞信息。</p>
<h4 id="hop-by-hop-backpressure">Hop-by-Hop Backpressure</h4>
<p>防止路程过长，拥塞通知延迟太久。同时用[[ch5 网络层#choke packets|choke packets]]通知中间路由控制流量。</p>
<h2 id="ch6-传输层">ch6 传输层</h2>
<p>传输层主要跑在用户机上，而<a href="#ch5-%E7%BD%91%E7%BB%9C%E5%B1%82">网络层</a>跑在路由器上</p>
<h3 id="socket">Socket</h3>
<h4 id="原语">原语</h4>
<table>
<thead>
<tr>
<th>原语</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>socket</td>
<td>建立一个新通讯端点</td>
</tr>
<tr>
<td>bind</td>
<td>将 socket 与一个本地地址关联</td>
</tr>
<tr>
<td>listen</td>
<td>声明愿意接受连接；给出队列长度</td>
</tr>
<tr>
<td>accept</td>
<td>被动创建一个入境连接</td>
</tr>
<tr>
<td>connect</td>
<td>主动尝试创建连接</td>
</tr>
<tr>
<td>send</td>
<td>通过连接传输数据</td>
</tr>
<tr>
<td>receive</td>
<td>通过连接接受数据</td>
</tr>
<tr>
<td>close</td>
<td>断开连接</td>
</tr>
</tbody>
</table>
<h4 id="文件传输程序">文件传输程序</h4>
<h5 id="客户端">客户端</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/* This page contains a client program that can request a file from the server program
</span></span></span><span class="line"><span class="cl"><span class="cm"> * on the next page. The server responds by sending the whole file.
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;netdb.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;netinet/in.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define SERVER_PORT 8080
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="cm">/* arbitrar y, but client &amp; server must agree */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define BUF_SIZE 4096
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="cm">/* block transfer size */</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">bytes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">BUF_SIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* buffer for incoming file */</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">hostent</span><span class="o">*</span> <span class="n">h</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* info about server */</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">sockaddr</span> <span class="n">in_channel</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* holds IP address */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Usage: client server-name file-name&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">h</span> <span class="o">=</span> <span class="n">gethostbyname</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* look up host’s IP address */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">h</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;gethostbyname failed to locate %s&#34;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">PF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="n">IPPROTO_TCP</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;socket call failed&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">channel</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">channel</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">channel</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">channel</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">h_addr</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">h_length</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">channel</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">SERVER_PORT</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">c</span> <span class="o">=</span> <span class="n">connect</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="nc">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">channel</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">channel</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;connect failed&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* Connection is now established. Send file name including 0 byte at end. */</span>
</span></span><span class="line"><span class="cl">    <span class="n">write</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">strlen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* Go get the file and write it to standard output. */</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">bytes</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">BUF_SIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* read from socket */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* check for end of file */</span>
</span></span><span class="line"><span class="cl">        <span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* wr ite to standard output */</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="服务器端">服务器端</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="cm">/* This is the server code */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;netdb.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;netinet/in.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/fcntl.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define SERVER_PORT 8080
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="cm">/* arbitrar y, but client &amp; server must agree */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define BUF_SIZE 4096
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="cm">/* block transfer size */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define QUEUE_SIZE 10
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">sa</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">on</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">BUF_SIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* buffer for outgoing file */</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">sockaddr_in</span> <span class="n">channel</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* holds IP address */</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* Build address structure to bind to socket. */</span>
</span></span><span class="line"><span class="cl">    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">channel</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">channel</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* zero channel */</span>
</span></span><span class="line"><span class="cl">    <span class="n">channel</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">channel</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">channel</span><span class="p">.</span><span class="n">sin</span> <span class="o">+</span> <span class="n">port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">SERVER_PORT</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* Passive open. Wait for connection. */</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="n">IPPROTO_TCP</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* create socket */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;socket call failed&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">setsockopt</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">on</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">on</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">b</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="nc">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">channel</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">channel</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;bind failed&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">l</span> <span class="o">=</span> <span class="n">listen</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">QUEUE_SIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* specify queue size */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;listen failed&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* Socket is now set up and bound. Wait for connection and process it. */</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">sa</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* block for connection request */</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">sa</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">printf</span><span class="p">(</span><span class="s">&#34;accept failed&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">read</span><span class="p">(</span><span class="n">sa</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">BUF_SIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* read file name from socket */</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* Get and return the file. */</span>
</span></span><span class="line"><span class="cl">        <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* open the file to be sent back */</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">printf</span><span class="p">(</span><span class="s">&#34;open failed&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">bytes</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">BUF_SIZE</span><span class="p">);</span> <span class="cm">/* read from file */</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* check for end of file */</span>
</span></span><span class="line"><span class="cl">            <span class="n">write</span><span class="p">(</span><span class="n">sa</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* wr ite bytes to socket */</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* close file */</span>
</span></span><span class="line"><span class="cl">        <span class="n">close</span><span class="p">(</span><span class="n">sa</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* close connection */</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div>]]></content:encoded></item><item><title>笔记：Designing data-intensive applications(开始记录）</title><link>https://livypad.github.io/post/2022-08-31-ddia/</link><pubDate>Wed, 31 Aug 2022 00:10:00 +0800</pubDate><guid>https://livypad.github.io/post/2022-08-31-ddia/</guid><description>Designing data-intensive applications: the big ideas behind reliable, scalable, and maintainable systems Foundations of Data Systems Data Models SQL：关系型，key-value 对，关联程度一般 文档型：自包含文档，少关联 图数据库：数据大量关联 Storage and Retrival</description><content:encoded><![CDATA[<h1 id="designing-data-intensive-applications-the-big-ideas-behind-reliable-scalable-and-maintainable-systems">Designing data-intensive applications: the big ideas behind reliable, scalable, and maintainable systems</h1>
<h2 id="foundations-of-data-systems">Foundations of Data Systems</h2>
<h3 id="data-models">Data Models</h3>
<ul>
<li>SQL：关系型，key-value 对，关联程度一般</li>
<li>文档型：自包含文档，少关联</li>
<li>图数据库：数据大量关联</li>
</ul>
<h3 id="storage-and-retrival">Storage and Retrival</h3>
<ul>
<li>OLTP 数据存储系统
<ul>
<li>日志结构：追加
<ul>
<li>hash-map：key 对应数据文件当中的位置偏移，只要 key 表能装入内存
<ul>
<li>高性能读写</li>
<li>对大量 key 不友好</li>
<li>区间查询不友好</li>
</ul>
</li>
<li>SSTables：排序字符串表：按顺序合并存储 k-v
<ul>
<li>可以稀疏存储 key</li>
<li>内存维护表，大于表的写进磁盘文件，一个 log 用来数据恢复</li>
</ul>
</li>
</ul>
</li>
<li>原地更新
<ul>
<li>B-Tree：固定大小的段/页组合
<ul>
<li>页大小和底层磁盘契合</li>
<li>覆盖而不是追加</li>
<li>大于页大小时候分裂页</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>OLAP 数据分析系统
<ul>
<li>数据仓库：专门用于数据分析的数据库，是工作用数据库的副本，面向查询
<ul>
<li>事实表：记录事件事实的主表，大，列多</li>
<li>列存储：列太多，一行拆开，每列单独存</li>
<li>列压缩：<code>None</code>值可以被压缩</li>
<li>聚合：面对常见操作预处理</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="encoding">Encoding</h3>
<blockquote>
<p>向前兼容</p>
<p>旧版本可读新版本的数据，一般通过忽略实现</p>
</blockquote>
<blockquote>
<p>向后兼容</p>
<p>新版本可读旧版本数据</p>
</blockquote>
<ul>
<li>语言自带：性能、通用性差、安全问题（代码生成）</li>
<li>文本文件（XML，JSON，CSV）：大，各种数据格式支持弱</li>
<li>二进制编码：小，带有更好的兼容检查支持，自带类型，自带注释</li>
</ul>
<h3 id="dataflow">Dataflow</h3>
<ul>
<li>基于数据库：数据比代码长久，旧版本更新需要忽略新的项</li>
<li>基于服务（web 服务 和 RPC）
<ul>
<li>web 服务：通过 HTTP 向服务器公开的 API 调用服务</li>
<li>RPC：远程调用有网络自身带来新问题，大跨度有兼容性问题</li>
</ul>
</li>
<li>基于消息传递：加入一个消息代理/Actor</li>
</ul>
<h2 id="distributed-data">Distributed Data</h2>
<h3 id="replication">Replication</h3>
<ul>
<li>主从复制
<ul>
<li>分主节点（可读可写）和从节点（只读）</li>
<li>新节点建立：快照+基础上的变更 log</li>
<li>恢复：选举+重新配置</li>
<li>方法
<ul>
<li>基于语句：非确定性语句改为传结果（VM-FT）</li>
<li>基于预写日志 Write-ahead log (WAL)：磁盘字节改变的日志</li>
<li>基于行的逻辑日志：按照修改的逻辑</li>
<li>基于触发器：应用层控制</li>
</ul>
</li>
<li>复制滞后和一致性
<ul>
<li>写后读：个人能读到自己之前的写</li>
<li>单调读：多次读取的版本号不减</li>
<li>前缀一致读：读的顺序取绝于当时写的顺序</li>
</ul>
</li>
</ul>
</li>
<li>多主节点复制
<ul>
<li>场景：多中心、离线工作、协作编辑</li>
<li>需要解决/规避同时写冲突</li>
</ul>
</li>
<li>无主节点复制</li>
</ul>
]]></content:encoded></item><item><title>笔记：Distributed Systems An Algorithmic Approach 2nd（更新到第9章）</title><link>https://livypad.github.io/post/2022-07-09-ghoshdsaaa/</link><pubDate>Sat, 09 Jul 2022 01:31:57 +0800</pubDate><guid>https://livypad.github.io/post/2022-07-09-ghoshdsaaa/</guid><description>Ghosh, Sukumar (2014) - Distributed Systems An Algorithmic Approach Ch 1 introduction Ch 2 interprocess communication naming rpc remote procedure call cloud computing MapReduce ch 3 Models for Communication shared variable 共享变量 linda mobile agent 模型强弱 resequencing protocol, 非 FIFO 模拟 FIFO 共享变量模拟信息传递 信息传递模拟共享变量 信</description><content:encoded><![CDATA[<ul>
<li><a href="#ghosh-sukumar-2014---distributed-systems-an-algorithmic-approach">Ghosh, Sukumar (2014) - Distributed Systems An Algorithmic Approach</a>
<ul>
<li><a href="#ch-1-introduction">Ch 1 introduction</a></li>
<li><a href="#ch-2-interprocess-communication">Ch 2 interprocess communication</a>
<ul>
<li><a href="#naming">naming</a></li>
<li><a href="#rpc-remote-procedure-call">rpc remote procedure call</a></li>
<li><a href="#cloud-computing">cloud computing</a>
<ul>
<li><a href="#mapreduce">MapReduce</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#ch-3-models-for-communication">ch 3 Models for Communication</a>
<ul>
<li><a href="#shared-variable-%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F">shared variable 共享变量</a>
<ul>
<li><a href="#linda">linda</a></li>
<li><a href="#mobile-agent">mobile agent</a></li>
</ul>
</li>
<li><a href="#%E6%A8%A1%E5%9E%8B%E5%BC%BA%E5%BC%B1">模型强弱</a>
<ul>
<li><a href="#resequencing-protocol-%E9%9D%9E-fifo-%E6%A8%A1%E6%8B%9F-fifo">resequencing protocol, 非 FIFO 模拟 FIFO</a></li>
<li><a href="#%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E6%A8%A1%E6%8B%9F%E4%BF%A1%E6%81%AF%E4%BC%A0%E9%80%92">共享变量模拟信息传递</a></li>
<li><a href="#%E4%BF%A1%E6%81%AF%E4%BC%A0%E9%80%92%E6%A8%A1%E6%8B%9F%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F">信息传递模拟共享变量</a></li>
<li><a href="#%E4%BF%A1%E9%81%93%E5%88%A4%E7%A9%BA%E7%9A%84%E4%B8%8D%E5%8F%AF%E8%83%BD%E6%80%A7">信道判空的不可能性</a></li>
</ul>
</li>
<li><a href="#%E7%B3%BB%E7%BB%9F%E5%88%86%E7%B1%BB">系统分类</a></li>
<li><a href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E6%95%B0">复杂度计数</a></li>
</ul>
</li>
<li><a href="#ch-4-representing-distributed-algorithms">ch 4 Representing Distributed Algorithms</a>
<ul>
<li><a href="#%E5%85%AC%E6%AD%A3%E6%80%A7">公正性</a></li>
<li><a href="#scheduler">scheduler</a></li>
</ul>
</li>
<li><a href="#ch-5-program-correctness">ch 5 Program Correctness</a>
<ul>
<li><a href="#%E6%96%AD%E8%A8%80%E6%8E%A8%E7%90%86-assertional-reasoning">断言推理 assertional reasoning</a></li>
<li><a href="#%E8%89%AF%E5%9F%BA%E9%9B%86-well-founeded-set">良基集 well-founeded set</a></li>
<li><a href="#%E6%97%B6%E9%97%B4%E9%80%BB%E8%BE%91-temporal-logic">时间逻辑 temporal logic</a></li>
</ul>
</li>
<li><a href="#ch-6-time-in-a-distributed-system">ch 6 Time in a Distributed System</a>
<ul>
<li><a href="#%E9%80%BB%E8%BE%91%E6%97%B6%E9%92%9F">逻辑时钟</a>
<ul>
<li><a href="#%E5%BC%B1%E6%97%B6%E9%92%9F%E6%9D%A1%E4%BB%B6-%E5%81%8F%E5%BA%8F%E5%85%B3%E7%B3%BB-prec">弱时钟条件 偏序关系 $\prec$</a></li>
<li><a href="#%E5%BC%B1%E6%97%B6%E9%92%9F%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%80%BB%E8%BE%91%E6%97%B6%E9%92%9F-logic-clock">弱时钟实现的逻辑时钟 logic clock</a></li>
<li><a href="#%E5%BC%BA%E6%97%B6%E9%92%9F%E5%85%B3%E7%B3%BB-%E5%85%A8%E5%BA%8F%E5%85%B3%E7%B3%BB-ll">强时钟关系 全序关系 $\ll$</a></li>
</ul>
</li>
<li><a href="#%E5%90%91%E9%87%8F%E6%97%B6%E9%92%9F-vector-clock">向量时钟 vector clock</a></li>
<li><a href="#%E7%89%A9%E7%90%86%E6%97%B6%E9%92%9F%E5%90%8C%E6%AD%A5">物理时钟同步</a>
<ul>
<li><a href="#berkeley-%E7%AE%97%E6%B3%95-%E5%86%85%E9%83%A8%E5%90%8C%E6%AD%A5">Berkeley 算法 内部同步</a></li>
<li><a href="#lamport-and-melliarsmith-%E7%AE%97%E6%B3%95-%E5%86%85%E9%83%A8%E5%90%8C%E6%AD%A5">Lamport and Melliar–Smith 算法 内部同步</a></li>
<li><a href="#cristian-%E7%AE%97%E6%B3%95-%E5%A4%96%E9%83%A8%E5%90%8C%E6%AD%A5">Cristian 算法 外部同步</a></li>
<li><a href="#ntp-network-time-protocol-%E5%AE%9E%E7%8E%B0">NTP network time protocol 实现</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#ch-7-mutual-exclusion">ch 7 Mutual Exclusion</a>
<ul>
<li><a href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%96%B9%E6%A1%88">消息传递模型的方案</a>
<ul>
<li><a href="#lamport-%E6%96%B9%E6%A1%88">Lamport 方案</a></li>
<li><a href="#ricartagrawala-%E6%96%B9%E6%A1%88">Ricart–Agrawala 方案</a></li>
<li><a href="#maekawa-%E6%96%B9%E6%A1%88">Maekawa 方案</a></li>
</ul>
</li>
<li><a href="#token-passing-%E7%9A%84%E6%96%B9%E6%A1%88">token-passing 的方案</a>
<ul>
<li><a href="#suzukikasami-%E6%96%B9%E6%A1%88">Suzuki–Kasami 方案</a></li>
<li><a href="#raymond-%E6%96%B9%E6%A1%88">Raymond 方案</a></li>
</ul>
</li>
<li><a href="#%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8%E7%9A%84%E6%96%B9%E6%A1%88">共享存储的方案</a>
<ul>
<li><a href="#peterson-%E6%96%B9%E6%A1%88-%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%AD%90%E6%8C%87%E4%BB%A4">Peterson 方案 不使用原子指令</a></li>
<li><a href="#test-and-set-%E5%8E%9F%E5%AD%90%E6%8C%87%E4%BB%A4">test-and-set 原子指令</a></li>
<li><a href="#load-linked-%E5%92%8C-store-conditional-%E5%8E%9F%E5%AD%90%E6%8C%87%E4%BB%A4">load-linked 和 store-conditional 原子指令</a></li>
</ul>
</li>
<li><a href="#%E7%BB%84%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5">组同步互斥</a>
<ul>
<li><a href="#%E4%B8%AD%E5%BF%83%E5%8C%96%E6%96%B9%E6%A1%88">中心化方案</a></li>
<li><a href="#%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E6%96%B9%E6%A1%88">去中心化方案</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#ch-8-distributed-snapshot">ch 8 Distributed Snapshot</a>
<ul>
<li><a href="#chandy-lamport-%E7%AE%97%E6%B3%95">Chandy-Lamport 算法</a></li>
<li><a href="#lai-yang-%E7%AE%97%E6%B3%95">Lai-Yang 算法</a></li>
<li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F-debug">分布式 debug</a></li>
</ul>
</li>
<li><a href="#ch-9-global-state-collection">ch 9 Global State Collection</a>
<ul>
<li><a href="#%E5%85%A8%E5%B1%80%E5%B9%BF%E6%92%AD">全局广播</a></li>
<li><a href="#%E7%A8%8B%E5%BA%8F%E7%BB%88%E6%AD%A2%E6%A3%80%E6%B5%8B">程序终止检测</a>
<ul>
<li><a href="#dijstra-scholten-%E7%AE%97%E6%B3%95">Dijstra-Scholten 算法</a></li>
<li><a href="#%E5%8D%95%E5%90%91%E7%8E%AF%E7%9A%84-token-passing">单向环的 token passing</a></li>
<li><a href="#%E4%BF%A1%E7%94%A8%E7%82%B9%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95-credit-recovery-algorithm">信用点分配算法 credit-recovery algorithm</a></li>
</ul>
</li>
<li><a href="#%E6%B5%AA%E6%BD%AE-wave-%E7%AE%97%E6%B3%95">浪潮 wave 算法</a></li>
</ul>
</li>
<li><a href="#ch-11-coordination-algorithms">ch 11 Coordination Algorithms</a></li>
<li><a href="#ch-12-fault-tolerant-systems">ch 12 Fault-Tolerant Systems</a></li>
<li><a href="#ch-13-distributed-consensus">ch 13 Distributed Consensus</a></li>
</ul>
</li>
</ul>
<h1 id="ghosh-sukumar-2014---distributed-systems-an-algorithmic-approach">Ghosh, Sukumar (2014) - Distributed Systems An Algorithmic Approach</h1>
<p>一本高屋建瓴讨论分布式里面重要问题的书。这篇笔记主要就是结合我的理解复述一下书里的我感觉比较重要内容的流水账。</p>
<h2 id="ch-1-introduction">Ch 1 introduction</h2>
<p>特征</p>
<ol>
<li>多进程</li>
<li>进程间通讯</li>
<li>分离地址空间</li>
<li>单任务</li>
</ol>
<p>使用分布式的原因</p>
<ul>
<li>地理分离</li>
<li>加速</li>
<li>远端资源共享</li>
<li>容错</li>
</ul>
<p>一般的问题</p>
<ol>
<li>leader 选举</li>
<li>互斥</li>
<li>时钟同步</li>
<li>全局状态</li>
<li>组播</li>
<li>副本管理</li>
</ol>
<h2 id="ch-2-interprocess-communication">Ch 2 interprocess communication</h2>
<h3 id="naming">naming</h3>
<p>位置无关，方便定位实体。一般是文本形式，树状结构</p>
<h3 id="rpc-remote-procedure-call">rpc remote procedure call</h3>
<ul>
<li>机器差异（大小端，指针和地址）</li>
<li>阻塞/非阻塞</li>
<li>丢包：at-least-once/at-most-once,exactly once</li>
</ul>
<table>
<thead>
<tr>
<th>Client Stub</th>
<th>Server Stub</th>
</tr>
</thead>
<tbody>
<tr>
<td>Pack parameters into a message，Send message to remote machine</td>
<td>Do no message → skip od ，Unpack the call parameters</td>
</tr>
<tr>
<td>Do no result → skip od*，Receive result and unpack it</td>
<td>Call the server procedure Receive result and unpack it Pack result into a message</td>
</tr>
<tr>
<td>Return to the client program</td>
<td>Send it to the client</td>
</tr>
</tbody>
</table>
<h3 id="cloud-computing">cloud computing</h3>
<ul>
<li>software-as-a-service, SaaS
<ul>
<li>Google doc，云盘等</li>
</ul>
</li>
<li>platform-as-a-service, PaaS
<ul>
<li>小程序 API（？</li>
</ul>
</li>
<li>infrastructure-as-a-service, IaaS
<ul>
<li>elastic computing cloud， EC2 云服务器</li>
</ul>
</li>
</ul>
<h4 id="mapreduce">MapReduce</h4>
<p>Map: 〈<em>key, value</em>〉→ list of 〈<em>key, value</em>〉</p>
<p>{This is the intermediate 〈key, value〉 pair}</p>
<p>Reduce: 〈<em>key, list of values</em>〉 → list of 〈<em>key, value</em>〉</p>
<h2 id="ch-3-models-for-communication">ch 3 Models for Communication</h2>
<blockquote>
<p>本书的可靠信道公理 channel</p>
<ol>
<li>所有发出消息都被接收方收到，所有收到消息都有发送者
<ul>
<li>对数据链路/传输层不适用，需要恢复</li>
</ul>
</li>
<li>每条信息都有一条任意，有限长，非零延迟
<ul>
<li>为了放宽对不同延迟的支持</li>
</ul>
</li>
<li>信道呈现 FIFO 特性
<ul>
<li>电报 datagram 网络乱序</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="shared-variable-共享变量">shared variable 共享变量</h3>
<blockquote>
<p>DSM</p>
<p>distribted shared memory，方便使用共享变量有关的编程工具</p>
</blockquote>
<ol>
<li>state reading/locally shared variable 读取自身和邻居状态，只能修改自己状态</li>
<li>link register 链路自带单读者单写者寄存器</li>
</ol>
<h4 id="linda">linda</h4>
<p>共享的 tuple space</p>
<table>
<thead>
<tr>
<th>原语</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>IN，INP</td>
<td>取出 tuple，分阻塞、非阻塞版本</td>
</tr>
<tr>
<td>OUT</td>
<td>放入 tuple</td>
</tr>
<tr>
<td>RD，RDP</td>
<td>读 tuple，类比 in 不删除。分阻塞、非阻塞版本</td>
</tr>
<tr>
<td>EVAL</td>
<td>创建新进程</td>
</tr>
</tbody>
</table>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/** main program**/</span>
</span></span><span class="line"><span class="cl"><span class="n">real_main</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span><span class="n">argv</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">argc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[];</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">nslave</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">hello</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">nslave</span> <span class="o">=</span> <span class="n">atoi</span> <span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nslave</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    	<span class="n">EVAL</span> <span class="p">(</span><span class="s">&#34;slave&#34;</span><span class="p">,</span> <span class="n">hello</span><span class="p">(</span><span class="n">j</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nslave</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    	<span class="n">IN</span><span class="p">(</span><span class="s">&#34;done&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Task completed.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cm">/** subroutine hello **/</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">hello</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Task from number %d.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">OUT</span><span class="p">(</span><span class="s">&#34;done&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="mobile-agent">mobile agent</h4>
<p>移动执行的代码</p>
<p>(I, P, B)</p>
<ul>
<li>I 标识符</li>
<li>P 对应代码</li>
<li>B 代码的变量</li>
</ul>
<h3 id="模型强弱">模型强弱</h3>
<p>强模型限制多，操作多；强模型模拟弱模型容易，反之可能困难</p>
<h4 id="resequencing-protocol-非-fifo-模拟-fifo">resequencing protocol, 非 FIFO 模拟 FIFO</h4>
<p>缓存再发送。可以优化为环形缓存编号</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain"><span class="line"><span class="cl">{Sender process P}
</span></span><span class="line"><span class="cl">var i : integer {initially 0}
</span></span><span class="line"><span class="cl">repeat
</span></span><span class="line"><span class="cl">    send m[i],i to Q;
</span></span><span class="line"><span class="cl">    i := i+1;
</span></span><span class="line"><span class="cl">forever
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{Receiver process Q}
</span></span><span class="line"><span class="cl">var k : integer {initially 0}
</span></span><span class="line"><span class="cl">buffer : buffer [0..∞] of message
</span></span><span class="line"><span class="cl">{initially for all k:buffer[k] = null}
</span></span><span class="line"><span class="cl">repeat{store}
</span></span><span class="line"><span class="cl">	receive m[i],i from P;
</span></span><span class="line"><span class="cl">    store m[i] into buffer[i];
</span></span><span class="line"><span class="cl">    {deliver}
</span></span><span class="line"><span class="cl">    while buffer[k] ≠ null do
</span></span><span class="line"><span class="cl">    begin
</span></span><span class="line"><span class="cl">        deliver the content of buffer [k];
</span></span><span class="line"><span class="cl">        buffer [k] := null; k := k+1;
</span></span><span class="line"><span class="cl">    end
</span></span><span class="line"><span class="cl">forever
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="共享变量模拟信息传递">共享变量模拟信息传递</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain"><span class="line"><span class="cl">shared var p, q: integer {initially p = q}
</span></span><span class="line"><span class="cl">buffer: array [0..max-1] of message
</span></span><span class="line"><span class="cl">{Sender process P}
</span></span><span class="line"><span class="cl">var s: array of messages sent by P, i : integer {initially 0}
</span></span><span class="line"><span class="cl">repeat
</span></span><span class="line"><span class="cl">	if p ≠ q − 1 mod max then
</span></span><span class="line"><span class="cl">    begin
</span></span><span class="line"><span class="cl">    	buffer[p] := s[i]; i := i + 1; p := p + 1 mod max
</span></span><span class="line"><span class="cl">    end
</span></span><span class="line"><span class="cl">forever
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{Receiver process Q}
</span></span><span class="line"><span class="cl">var r: array of messages received by Q, j : integer {initially 0}
</span></span><span class="line"><span class="cl">repeat
</span></span><span class="line"><span class="cl">    if q ≠ p mod max then
</span></span><span class="line"><span class="cl">    begin
</span></span><span class="line"><span class="cl">    	r[j] := buffer[q]; j := j + 1; q := q + 1 mod max
</span></span><span class="line"><span class="cl">    end
</span></span><span class="line"><span class="cl">forever
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="信息传递模拟共享变量">信息传递模拟共享变量</h4>
<p>下列实现错误：</p>
<ol>
<li>组播不 atmoic，atmoic 组播有代价</li>
<li>组播不一定遵循更新变量顺序</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain"><span class="line"><span class="cl">{Implementing shared memory by message passing: first attempt}
</span></span><span class="line"><span class="cl">{read X by process i}
</span></span><span class="line"><span class="cl">read x[i] x[i] := v
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{write X := v by process i}
</span></span><span class="line"><span class="cl">x[i] := v
</span></span><span class="line"><span class="cl">Multicast v to every other process j (j ≠ i) in the system;
</span></span><span class="line"><span class="cl">Process j (j ≠ i), after receiving the multicast, sets x[j] to v.
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="信道判空的不可能性">信道判空的不可能性</h4>
<p>如果进程<code>i,j</code>之间信道需要判空</p>
<ul>
<li>已知<code>i,j</code>之间最大时延 T，等待 T</li>
<li>未知最大时延，初始信道可以包含任意信息，无法判空（即使使用一个清零帧）</li>
</ul>
<h3 id="系统分类">系统分类</h3>
<ul>
<li>reactive：反应性，对请求响应</li>
<li>transformational：转移性，存在初态和末态</li>
<li>named：和处理器标识有关</li>
<li>anonymous：和处理器标识无关，即使标识改变可以继续运行，需要如随机数等机制打破对称性</li>
</ul>
<h3 id="复杂度计数">复杂度计数</h3>
<ul>
<li>空间复杂度：按 node 数目的增长要求的空间</li>
<li>时间复杂度
<ul>
<li>总步数</li>
<li>总轮次 round：最远端的执行一次是一轮</li>
</ul>
</li>
</ul>
<h2 id="ch-4-representing-distributed-algorithms">ch 4 Representing Distributed Algorithms</h2>
<blockquote>
<p>guard</p>
<p>断言，条件执行，如果多个断言判正确，由 scheduler 决定执行任意一个代码段，下面假定每个代码段原子执行</p>
</blockquote>
<p>程序终止条件</p>
<ol>
<li>每个进程终止，guard 全判<code>false</code></li>
<li>无消息还在传递</li>
</ol>
<p>类似如下的伪代码和对应的 Rust 实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain"><span class="line"><span class="cl">program uncertain;
</span></span><span class="line"><span class="cl">define x : integer;
</span></span><span class="line"><span class="cl">initially x = 0
</span></span><span class="line"><span class="cl">do
</span></span><span class="line"><span class="cl">  x &lt; 4 → x := x + 1
</span></span><span class="line"><span class="cl">  [] x = 3 → x := 0
</span></span><span class="line"><span class="cl">od
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">rand</span>::<span class="n">Rng</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">sync</span>::<span class="n">atomic</span>::<span class="p">{</span><span class="n">AtomicUsize</span><span class="p">,</span><span class="w"> </span><span class="n">Ordering</span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">static</span><span class="w"> </span><span class="n">CNT</span>: <span class="nc">AtomicUsize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AtomicUsize</span>::<span class="n">new</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="mi">10</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">CNT</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">Ordering</span>::<span class="n">Relaxed</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">the</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">the</span><span class="p">(</span><span class="n">i</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">CNT</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">Ordering</span>::<span class="n">Relaxed</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">(</span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">guess</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rand</span>::<span class="n">thread_rng</span><span class="p">().</span><span class="n">gen_range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">match</span><span class="w"> </span><span class="n">guess</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="mi">0</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">the</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">the</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">(</span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">the</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">(</span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;terminate in {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">CNT</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="公正性">公正性</h3>
<p>由于 guarded action 的选择依赖 scheduler （调度器） 决定，scheduler 需要考虑公平性</p>
<ul>
<li>无条件公平：每个代码段最终会进入调度队列，无论 guard 值</li>
<li>弱公平：只要代码段的 guard 变为并保持 <code>true</code>就最终会进入调度队列</li>
<li>强公平：只要代码段的 guard 能无限次经常变为<code>true</code>就最终会进入调度队列，弱公平能跑出的顺序，强公平一定能跑出，反之不一定</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain"><span class="line"><span class="cl">program test
</span></span><span class="line"><span class="cl">define
</span></span><span class="line"><span class="cl">x: integer {initial value undefined}
</span></span><span class="line"><span class="cl">do
</span></span><span class="line"><span class="cl">  true → x := 0
</span></span><span class="line"><span class="cl">  [] x = 0 → x := 1
</span></span><span class="line"><span class="cl">  [] x = 1 → x := 2
</span></span><span class="line"><span class="cl">od
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>不公平时可能只执行第 1 条</li>
<li>弱公平时只保证执行第 1、2 条（一直执行第 1 条会保证 x=0 从而执行 2，但 x=1 时可以只执行第 1 条而使得第 3 条永不满足）</li>
</ul>
<h3 id="scheduler">scheduler</h3>
<blockquote>
<p>central scheduler</p>
<p>又名 serial scheduler：原子的调度执行 guard 对应的代码段，简单，可以用 token 传递实现，拓展性差，并行度差，是分布式 scheduler 的退化情形</p>
<p>有关的 Theorem：</p>
<ol>
<li>算法在 central scheduler 下正确</li>
<li>已为<code>true</code> 的 guard 不会被其他代码段修改为<code>false</code></li>
</ol>
<p>=&gt;在 distributed scheduler 下正确</p>
</blockquote>
<h2 id="ch-5-program-correctness">ch 5 Program Correctness</h2>
<blockquote>
<p>安全 safety 条件</p>
<p>&ldquo;bad things never happen.&rdquo;</p>
</blockquote>
<p>如：</p>
<ul>
<li>同步互斥：至多一个进程在临界区</li>
<li>有限容量信道：$nC\le nP\le nC+B$</li>
<li>读写锁：$(nW\le 1 \wedge nR=0) \vee (nW=0\wedge nR\ge 0)$</li>
<li>无死锁：$Q\wedge GG$</li>
<li>部分正确性：如果不死锁，必得正确结果 $\neg GG\implies Q$</li>
</ul>
<blockquote>
<p>活跃 liveness 条件</p>
<p>&ldquo;good things eventually happen.&rdquo;</p>
</blockquote>
<p>如：</p>
<ul>
<li>进行：对于同步互斥问题，不死锁，不活锁（声明了临界区，最终总能获得机会）</li>
<li>公平性：有限时间后 schduler 总会调度</li>
<li>可达性：是否可以从初始状态 $S_0$ 到达状态 $S_k$</li>
<li>终止：部分正确+终止状态可达</li>
</ul>
<h3 id="断言推理-assertional-reasoning">断言推理 assertional reasoning</h3>
<p>用于证明安全性。构造不变式 $I$ 代表安全性条件（类似数学归纳法）</p>
<ol>
<li>初态不变式 $I$满足</li>
<li>假定前状态不变式 $I$满足，任何执行后不变式 $I$ 仍然满足</li>
</ol>
<h3 id="良基集-well-founeded-set">良基集 well-founeded set</h3>
<p>用于证明活跃性。一个映射（测量函数/变化函数 measured/variant function）从系统全局状态到一个 well-founed set $f:S\to WF$</p>
<blockquote>
<p>well-founded set</p>
<p>对于 $WF=\{w_1,w_2,&hellip;\}$ ，上面有个全序关系$\gg$</p>
<ol>
<li>不存在无穷比较链 $w_1\gg w_2 \gg &hellip;$</li>
<li>系统状态从 $s_1$ 到 $s_2$ ，有 $w_1=f(s_1),w_2=f(s_2) \implies w_1 \gg w_2$</li>
</ol>
</blockquote>
<p>一般 well-founed set 会选择非负整数集，0 就是终止状态，全序关系就是大于；也有选择 set 是一组元素，全序关系是字典顺序。</p>
<h3 id="时间逻辑-temporal-logic">时间逻辑 temporal logic</h3>
<ul>
<li>$\Box P$ 意思是 $P$ 永真</li>
<li>$\lozenge P$ 意思是 $P$ 最终会变为真</li>
</ul>
<p>有</p>
<ol>
<li>$\lozenge P=\neg \Box (\neg P)$：P 假不是一直不真的=P 假最终会不真</li>
<li>$\Box P\wedge \Box Q=\Box (P\wedge Q)$</li>
<li>$\Box P\vee \Box Q=\Box (P\vee Q)$</li>
<li>$\lozenge\Box P\implies \Box \lozenge P$：P 最终会一直真推出 P 会一直经常真（强公平蕴含弱公平）</li>
<li>$\lozenge P\wedge \lozenge Q=\lozenge (P\wedge Q)$</li>
<li>$\lozenge P\vee \lozenge Q=\lozenge (P\vee Q)$</li>
<li>$\lozenge P\vee Q\neq \lozenge (P\vee Q)$: <strong>注意：</strong> 如果 $Q=\neg P$，右边永真，左边可以为假</li>
</ol>
<h2 id="ch-6-time-in-a-distributed-system">ch 6 Time in a Distributed System</h2>
<h3 id="逻辑时钟">逻辑时钟</h3>
<h4 id="弱时钟条件-偏序关系-prec">弱时钟条件 偏序关系 $\prec$</h4>
<ol>
<li>同一进程里，a 在 b 后发生，$a\prec b$</li>
<li>两个进程通讯，i 进程的 a 发送，j 进程 b 接受，$a\prec b$</li>
<li>$(a\prec b)\wedge(b\prec c)\implies (a\prec c)$</li>
</ol>
<h4 id="弱时钟实现的逻辑时钟-logic-clock">弱时钟实现的逻辑时钟 logic clock</h4>
<ol>
<li>每个本地事件发生，$LC$ 递增 1</li>
<li>发送消息时附上当前 $LC$ 作为时间戳</li>
<li>接受到消息时 $LC=1+\max(local; LC, message; LC)$</li>
</ol>
<p>此时可以保证，但是反之不成立。逻辑时钟不能完全和因果关系互推，需要<a href="#%E5%90%91%E9%87%8F%E6%97%B6%E9%92%9F-vector-clock">向量时钟</a>。</p>
<p>$a\prec b\implies LC(a)&lt;LC(b)$</p>
<h4 id="强时钟关系-全序关系-ll">强时钟关系 全序关系 $\ll$</h4>
<p>$a\ll b$ 成立条件</p>
<ul>
<li>要么$LC(a)&lt;LC(b)$</li>
<li>要么不同进程，事件 a、b 对应进程 i、j，有 $LC(a)=LC(b),i&lt;j$</li>
</ul>
<h3 id="向量时钟-vector-clock">向量时钟 vector clock</h3>
<p>从事件集到进程数大小(假定为 n)的非负整数向量的函数 $VC:V\to A$。事件 a、b 的向量时钟之间大小关系$VC(a)&lt;VC(b)$的充要条件为</p>
<ol>
<li>$\forall i:i\in [0,n-1]:VC_i(a)\le VC_i(b)$</li>
<li>$\exists j\in[0,n-1]:VC_j(a)&lt;VC_j(b)$</li>
</ol>
<p>如果两个事件之间向量时钟既不大于也不小于，认为事件同时，记作$a\parallel b$。向量时钟保证了因果检测，即 $a\prec b \iff VC(a)&lt;VC(b)$ 。实现要求：</p>
<ol>
<li>进程 i 本地事件发生时候 $VC_i[i]+=1$</li>
<li>发送信息时附带整个向量时钟</li>
<li>进程 j 收到消息附带时间戳 $T$ 时，先更新本地 $VC_j[j]+=1$ ，再更新全局 $\forall k \in [0,n-1]:VC_k[j]=\max(T_k,VC_k[j])$</li>
</ol>
<h3 id="物理时钟同步">物理时钟同步</h3>
<ol>
<li>外部时钟同步：和 UTC/原子钟/GPS 同步时间。可以借助 NTP（network time protocol）协议</li>
<li>内部时钟同步：在即使内部少数错误时钟下仍然同步时间，只需要内部相互同步即可，注意一般通过调快/调慢实现以防止突变</li>
<li>相同步</li>
<li>有界时钟：只能通过加位数保证可预见未来不溢出</li>
</ol>
<ul>
<li>偏移率 drift rate：内部时钟和理想时钟走时速度不完全相等：$(1-\rho)\le \frac{\rm{d}C}{\rm{d}t}\le(1+\rho)$</li>
<li>时钟偏差 clock skew：时钟之间最大允许读数偏差 $\delta$</li>
<li>重同步间隔 resynchronization interval ：$R$</li>
</ul>
<h4 id="berkeley-算法-内部同步">Berkeley 算法 内部同步</h4>
<p>选择一个 leader 收集计算各个内部时钟的平均值，并按此调整</p>
<h4 id="lamport-and-melliarsmith-算法-内部同步">Lamport and Melliar–Smith 算法 内部同步</h4>
<p>去中心化的算法。可以应对 two-faced clock 问题。$c_k[i]$ 表示时钟 i 读取时钟 k 得到的值。</p>
<blockquote>
<p>two-faced clock</p>
<p>2 个非错时钟向 two-faced 时钟读数结果不一致</p>
</blockquote>
<ol>
<li>读系统中每个时钟的值</li>
<li>将离群值丢弃,用本地值代替： $|c_i[i]-c_j[i]|&gt;\delta \implies c_j[i]\gets c_i[i]$</li>
<li>使用处理后的平均值覆盖本地时钟值</li>
</ol>
<p>对于 n 个时钟，只要 two-faced clock 数目 t 有 $n&gt;3t$ 就能保证同步。</p>
<p>考虑 3 个时钟，i、j 好，k 为 two-faced clock。有如下配置</p>
<ul>
<li>$c_i[i]=c$</li>
<li>$c_j[j]=c-\delta$</li>
<li>$c_k[i]=c+\delta$</li>
<li>$c_k[j]=c-2\delta$</li>
</ul>
<p>这时候 i、j 平均值差为 $\frac{3t\delta}{n}$。如果 $n&gt;3t$ 就有$\frac{3t\delta}{n}&lt;\delta$。同步间隔 $R\le(\delta -\frac{3t\delta}{n})/\rho$</p>
<h4 id="cristian-算法-外部同步">Cristian 算法 外部同步</h4>
<p>每个 client 向有精确时钟的 time server 定时通信来同步时钟： $R&lt;\frac{\delta}{2\rho}$。</p>
<blockquote>
<p>round-trip time</p>
<p>每次同步通过发起 RPC，用来度量信号延迟：$RTT=T_2-T_1$</p>
</blockquote>
<p>每次时钟修正为 $T_s+\frac{RTT}{2}=T_s+\frac{T_2-T_1}{2}$。但实际网络波动，返回时间是一个区间，记最短用时 $min$，对应同步精度 $\pm(\frac{T_2-T_1}{2}-min)$</p>
<h4 id="ntp-network-time-protocol-实现">NTP network time protocol 实现</h4>
<p>按层级 stratum 组织各计算机，stratum 0 对应直连高精度时钟，stratum $i$ 作为 $i+1$ 的 time server，精度随着层级增加递减。</p>
<ul>
<li>组播：使用 UDP 协议定期发送</li>
<li>RPC：使用 <a href="#cristian-%E7%AE%97%E6%B3%95-%E5%A4%96%E9%83%A8%E5%90%8C%E6%AD%A5">Cristian 算法</a></li>
<li>P2P 通信：同层级的 time server 互相同步保持精度。设 Q 在 P 之前$\delta$，互相发报：$T_2=T_1+T_{PQ}+\delta,T_4=t_3+T_{QP}-\delta$，则有 $\delta=\frac{T_2-T_4-T_1+T_3}{2}-\frac{T_{PQ}-T_{QP}}{2},RTT=T_{PQ}+T_{QP}=T_2+T_4-T_1-T_3$， 这时候两个时钟误差$\delta$就可以控制在 $\frac{T_2-T_4-T_1+T_3}{2}\pm\frac{RTT}{2}$ 里面（注意到 $T_{PQ},T_{QP}&gt;0$，相减的值可以由 RTT 控制）</li>
</ul>
<h2 id="ch-7-mutual-exclusion">ch 7 Mutual Exclusion</h2>
<p>3 个基本要求</p>
<ol>
<li>同步互斥 Mutual exclusion：至多一个进程在临界区，这是安全性性质</li>
<li>不死锁 Freedom from deadlock：至少一个进程可以运行和进入临界区，也是安全性性质</li>
<li>进展 Progress：每个尝试进入临界区的进程最终总能进入，这是活跃性性质</li>
</ol>
<blockquote>
<p>livelock/starvation</p>
<p>违反性质 3。进程一直被阻止进入临界区</p>
</blockquote>
<blockquote>
<p>FIFO fairness，FIFO 公平</p>
<p>进入临界区的顺序按照申请的顺序，类似 FIFO 队列。注意是申请的时间而不是申请到达 central coordinator（如果采用中心化的算法）的时间，所以一般世俗机构的办事先到先得不是 FIFO fairness</p>
</blockquote>
<h3 id="消息传递模型的方案">消息传递模型的方案</h3>
<p>下面算法一般要求发送消息时间戳。注意到如果只考虑同步互斥问题，时间戳最大差 $(n-1)$，因此可以选择 $\mathrm{mod}(2n-1)$ 的时间戳，有效规避无界时钟问题（详见 <a href="#%E7%89%A9%E7%90%86%E6%97%B6%E9%92%9F%E5%90%8C%E6%AD%A5">物理时钟章节</a> ）。</p>
<h4 id="lamport-方案">Lamport 方案</h4>
<ul>
<li>全连接网络</li>
<li>信道 FIFO，不丢信息</li>
<li>每个进程维护一个队列 Q</li>
<li>3 特性+FIFO 公平，一轮需要 $3(n-1)$ 次消息传递</li>
</ul>
<ol>
<li>期望进入临界区的进程广播带时间戳<code>request</code></li>
<li>接受到<code>request</code>的进程
<ol>
<li>不在临界区：回复 <code>ack</code></li>
<li>在临界区：直到退出临界区再回复<code>ack</code></li>
</ol>
</li>
<li>进入临界区条件：
<ol>
<li>检查本地队列 Q 自己的请求最早</li>
<li>其他进程都回复了<code>ack</code></li>
</ol>
</li>
<li>退出临界区时：
<ol>
<li>删除本地队列 Q 中自己的请求</li>
<li>广播带时间戳<code>release</code></li>
</ol>
</li>
<li>收到<code>release</code>后进程删除对应的请求</li>
</ol>
<h4 id="ricartagrawala-方案">Ricart–Agrawala 方案</h4>
<ul>
<li>不需要维护本地队列</li>
<li>只是更多的缓存请求.对时间戳晚于自己的请求，当时不在临界区时：
<ul>
<li>Lamport 方案回复</li>
<li>Ricart–Agrawala 方案缓存</li>
</ul>
</li>
<li>3 特性+FIFO 公平，一轮需要 $2(n-1)$ 次消息传递</li>
</ul>
<ol>
<li>期望进入临界区的进程广播带时间戳<code>request</code></li>
<li>接受到<code>request</code>的进程回复 <code>ack</code> 条件，反之缓存请求
<ul>
<li>该进程不准备进入临界区</li>
<li>该进程期望进入的时间戳晚于对应的<code>request</code></li>
</ul>
</li>
<li>进入临界区条件其他进程都回复了<code>ack</code></li>
<li>退出临界区执行其他操作前，对等待的请求回复<code>ack</code></li>
</ol>
<h4 id="maekawa-方案">Maekawa 方案</h4>
<p>每个进程 i 属于单独的通信组 $S_i$。组内互相监督满足临界区，只要组的覆盖足够好，就可以减少通信支出。大概为 $3\sqrt{n}=O(\sqrt{n})$</p>
<ol>
<li>$\forall i,j\in [0,n-1],S_i\cap S_j\neq \varnothing$：保证全局覆盖</li>
<li>$i\in S_i$：自身也被监督</li>
<li>最好的，每个进程属于通信组的次数相同（有对称性）</li>
</ol>
<blockquote>
<p>global FIFO</p>
<p>每个进程严格按照发送时间戳接受消息：极难实现</p>
</blockquote>
<ul>
<li>global FIFO 成立时
<ol>
<li>期望进入临界区的进程对 $S_i$ 广播带时间戳<code>request</code></li>
<li>对时间戳最早的请求回复<code>ack</code>，锁住，其他请求排在队列中；如果进程在临界区里，退出时再进行</li>
<li>进入临界区条件：收到 $S_i$ 中每个进程的 <code>ack</code></li>
<li>退出临界区时对 $S_i$ 广播<code>release</code></li>
<li>接收到<code>release</code>后从队列剔除对应请求，解锁，重复<code>步骤2</code></li>
</ol>
</li>
<li>没有 global FIFO，可能会因为循环等 <code>ack</code> 导致死锁，需要添加放弃机制
<ol>
<li>期望进入临界区的进程对 $S_i$ 广播带时间戳<code>request</code></li>
<li>不在临界区时接受到请求：</li>
<li>未锁：对时间戳最早的请求回复<code>ack</code>，锁定</li>
<li>已锁，新请求的时间戳更晚：回复<code>failed</code></li>
<li>已锁，新请求的时间戳更早：排队请求，对之前锁定请求的发送方发<code>inquire</code>，可能会重排顺序</li>
<li>进入临界区条件：收到 $S_i$ 中每个进程的 <code>ack</code>
<ul>
<li>如果收到 <code>inquire</code> 还接受到了<code>failed</code>，对 $S_i$ 广播 <code>relinquish</code> 放弃排期自己的请求</li>
<li>如果只收到 <code>inquire</code> 可以忽略</li>
</ul>
</li>
<li>退出临界区时对 $S_i$ 广播<code>release</code></li>
<li>接收到<code>release</code>后从队列剔除对应请求，解锁，重复<code>步骤2</code></li>
<li>已锁，接受到<code>relinquish</code>，重排队列，对时间戳最早的发<code>ack</code></li>
</ol>
</li>
</ul>
<h3 id="token-passing-的方案">token-passing 的方案</h3>
<h4 id="suzukikasami-方案">Suzuki–Kasami 方案</h4>
<p>全连接网络。初始有个进程拥有 token。期望进入临界区的进程 $i$ 广播带序列号的消息 $(i,num)$。拿到 token 即允许进入临界区。每个进程有本地队列 Q 和本地向量</p>
<ul>
<li>$req[0,&hellip;,n-1]$ 记录对应进程最近请求序列号</li>
<li>$last[0,&hellip;,n-1]$ 记录对应进程进入临界区次数</li>
</ul>
<p>进程 $i$ 拿到 token 后</p>
<ol>
<li>$last[i]\gets num$</li>
<li>将满足 $1+last[k]=req[k]$ 的每个进程 k 加入本地队列 Q</li>
<li>执行临界区</li>
<li>取出 Q 第一项传递 token</li>
</ol>
<p>对应消息总数 $(n-1)+1$（发出 $n-1$，接收 1 条 token）</p>
<h4 id="raymond-方案">Raymond 方案</h4>
<p>关系组织成树。每个进程有一个本地队列。一般的，树之间节点距离就是通信开销 $O(\log{n})$</p>
<ol>
<li>节点拥有 token 时候为树的根，并可以进去临界区，反之将自己的请求加入自己本地队列</li>
<li>节点没有 token，本地队列非空时给父节点发送请求，除非已经发送并在等待</li>
<li>根节点结束临界区，收到请求时，给本地队列第一项的邻居传递 token，并改为指向该邻居，该邻居变成根节点</li>
<li>接受到 token 时候，向本地队列第一项的邻居继续传递，并删除对应的请求，改为指向该邻居，如果队列中还有请求，向新的父节点发送请求</li>
</ol>
<h3 id="共享存储的方案">共享存储的方案</h3>
<p>一般依靠原子指令：</p>
<ul>
<li>compare-and-swap (CAS)：比较预期值和内存变量，相等时候改为新传入的值，反之不修改，返回执行之后的内存变量值</li>
<li>fetch-and-add(FA)：原子加</li>
<li>semaphore 信号量：非负整数支持原子操作，可以对应资源个数
<ul>
<li>$P(s)\triangleq\{waituntil; s&gt;0\implies s-=1\}$：申请资源，取得后可用资源-1</li>
<li>$V(s)\triangleq\{s+=1\}$：释放资源，可用资源+1</li>
</ul>
</li>
</ul>
<h4 id="peterson-方案-不使用原子指令">Peterson 方案 不使用原子指令</h4>
<p>2 个进程版本</p>
<pre tabindex="0"><code>program peterson;
define flag[0], flag[1] shared Boolean;
turn: shared integer
initially flag[0] = false, flag[1] = false, turn = 0 or 1
{program for process 0}
do true→
    flag[0] := true;
    turn := 0;

    do (flag[1] ∧ turn = 0) → skip od//不需要原子语句，turn要么0要么1，不会死锁；如果是flag引起进入临界区，process 1已经执行完临界区了；如果是turn引起，process 1 会等待：保证互斥

    critical section;
    flag[0] := false;
    non-critical section codes
od
{program for process 1}
do  true →
    flag[1] := true;
    turn := 1;

    do (flag[0] ∧ turn = 1) → skip od;//不需要原子语句

    critical section;
    flag[1] := false;
    non-critical section codes
od
</code></pre><p>多进程拓展版本。跑 $n-1$ 轮，每轮留下一个（最后一个修改 $turn[j]$ 的），最后选出 1 个执行临界区。最高位执行完后，$flag$ 会置 0，剩下 flag 最高的会结束等待，然后按照 轮数递减执行临界区。</p>
<pre tabindex="0"><code>program Peterson n-process;
define flag, turn: array [0.. n − 1] of shared integer;
initially ∀k:flag[k] = 0, and turn = 0
{program for process i}
do true →
    j:=1;
    do j ≠ n − 1
        flag[i] := j;
        turn[j] := i;

        do ((∃k ≠ i: flag[k] ≥ j) ∧ turn[j] = i) → skip od;// （1：选出的执行完后递减执行）∧（每轮修改turn的留下，flag不动）

        j := j + 1;
    od;

    critical section;

    flag[i] := 0;

    non-critical section codes
od
</code></pre><h4 id="test-and-set-原子指令">test-and-set 原子指令</h4>
<p>特殊的原子指令，取得某<code>bool</code>变量值，然后将其置 <code>True/1</code></p>
<pre tabindex="0"><code>program Test-and-set (for any process);
define
    x: shared integer;
    r: integer (private);
initially
    x = 0, r = 1;
do true →

    do r ≠ 0 → TS(r, x) od;

    critical section;
    x := 0
od
</code></pre><h4 id="load-linked-和-store-conditional-原子指令">load-linked 和 store-conditional 原子指令</h4>
<ul>
<li>load-linked $LL(r,x)$：类似普通 load 功能 $r\gets x$，还会对 x 插装</li>
<li>store-conditional $SC(r,x)$：类似 store $x\gets r$，如果 SC 是在其他进程的 LL 后执行后没修改，r 返回成功，反之 x 的值不改变，r 返回失败。LL 和 SC 配合类似 test-and-set</li>
</ul>
<pre tabindex="0"><code>program mutex (for process i);
define x: shared integer; r: integer (private);
initially x = 0;
do true →
try:
    do r ≠ 0 → LL(r, x) od; //critical section is busy
    r = 1; SC(r, x);

    if r = 0 → goto try fi;// SC did not succeed

    critical section;
    x := 0;
    non-critical section codes;
od
</code></pre><h3 id="组同步互斥">组同步互斥</h3>
<p>进程可以属于不同的独立的 forum，按 forum 为单位占有资源 in session。这是单独同步互斥、读写锁等经典问题的推广化。</p>
<ol>
<li>同步互斥：同一时间最多 1 个 forum 在 in session</li>
<li>无死锁：任何时间最少一个进程可以有效行动</li>
<li>有界等待：有成员的 forum 在有界时间内能 in session</li>
<li>同步进入：只要 forum 在 in session，其他有意愿的进程都能加入</li>
</ol>
<h4 id="中心化方案">中心化方案</h4>
<ul>
<li>每个进程拥有一个 $flag\in\{F_i,\perp\}$，中心协调器按顺序读取 flag 信息，安排进入 forum 和 in session</li>
<li>为了防止一个 forum 一直有进入，指定一个 leader（一般是第一个进入的进程），当 leader 退出时 forum 结束 in session</li>
</ul>
<h4 id="去中心化方案">去中心化方案</h4>
<p>每个进程拥有一个 $flag=(state,op),state\in \{request, in\_cs, in\_forum, passive\},op\in\{F,F&rsquo;,\perp\}$。类似于 <a href="#peterson-%E6%96%B9%E6%A1%88">peterson 的 2 进程方案</a>。为了保证想要进入 forum 的都可以，而不是偶尔检查条件被 skip，可以选择第一个进入的为 leader，leader 保证申请的随后进入 forum</p>
<pre tabindex="0"><code>First attempt with two forums F and F′
define  flag: array[1..n − 1] of (state, op), turn ∈ {F, F′}
        state ∈ {request, in_cs, in_forum, passive}
        op ∈ {F, F′, ⊥}
{Program for process i trying to attend forum F}
do ∃j ≠ i: flag[j] = (in_cs, F′) →

    flag[i] := (request, F); //发送请求

    do turn ≠ F ∧ ¬(∀j ≠ i: flag[j].op ≠ F′) → skip od; // (1 F&#39;之前执行完)∧(2 没有要求进入F&#39;的)

    flag[i] := (in_cs, F);//准备进入 forum 的临界区
od;

attend forum F;

turn := F′;
flag[i] := (passive, ⊥)
</code></pre><h2 id="ch-8-distributed-snapshot">ch 8 Distributed Snapshot</h2>
<p>记录分布式系统的单个分布组分的状态信息，收集分散的状态信息在下一章 <a href="#ch-9-global-state-collection">global state collection</a> 介绍。非常有用：死锁检测、程序终止检测、系统回滚等。</p>
<blockquote>
<p>cut 切分</p>
<p>一组事件，而且每个进程至少有一个事件</p>
</blockquote>
<blockquote>
<p>consistent cut</p>
<p>cut，而且对于里面的事件，其因的事件也在 cut 当中： $(a\in C)\wedge(b\prec a)\implies b\in C$</p>
</blockquote>
<blockquote>
<p>consistent</p>
<p>对于一次运行（computation，run，behavior），$\forall a,b, a\prec b$，a 发生在 b 前，就称为 consistent 的，保证 consistent 下可以有多种可能的实际事件顺序，如，交换并行的两个事件执行顺序不会影响运行的 consistent 特性</p>
</blockquote>
<h3 id="chandy-lamport-算法">Chandy-Lamport 算法</h3>
<p>强连通图，信道 FIFO，有一个启动进程 initiator，发生一个 * 标志消息启动记录，每个进程有两种状态，<code>white</code>和<code>red</code>，初始为<code>white</code></p>
<ol>
<li>启动进程原子执行
<ol>
<li>变<code>red</code></li>
<li>记录本地状态</li>
<li>向所有对外信道广播*标志</li>
</ol>
</li>
<li>所有进程在<strong>第一次</strong>接受到*标志后，先做以下原子操作再执行其他任务
<ol>
<li>变<code>red</code></li>
<li>记录本地状态：发送事件和接收事件分别由发送进程和接收进程记录</li>
<li>向所有对外信道广播*标志</li>
</ol>
</li>
</ol>
<p>算法记录最后一次白色+第一次红色事件。由于<strong>白色事件不可能引发红色消息</strong>，实际记录下来的事件顺序必然保持因果关系。</p>
<ul>
<li>算法记录下来的 snapshot state 都是由初始状态可达的，但不保证每次运行都能跑出这个状态</li>
<li>每个对于初始状态可达的最终状态，对算法记录下的 snapshot state 也是可达的：这保证了回滚的正确性</li>
</ul>
<h3 id="lai-yang-算法">Lai-Yang 算法</h3>
<p>对 Chandy-Lamport 的改进，信道不需要 FIFO，消息也附加两种状态，<code>white</code>和<code>red</code>。是一种懒记录方法，主要期待借用已有的各种消息传递。对于程序终止检测（终止后不会再收发任务消息）等需要额外发控制消息。</p>
<ol>
<li>启动进程记录本地状态，任何外发消息为$(msg,red)$</li>
<li>任何进程第一次接受到$(msg,red)$时，先记录本地状态，再处理接收信息</li>
</ol>
<h3 id="分布式-debug">分布式 debug</h3>
<blockquote>
<p>本地状态 $s(i),s(j)$ 对应 consistent 的全局状态</p>
<p>如果本地状态 $s(i),s(j)$ 是由事件 $e_i,e_j$ 引发，那么逻辑时钟关系 $\forall k,VC_k(e_i)\sim VC_k(e_j)$</p>
</blockquote>
<p>对由初始状态可达的 consistent 的全局状态应用判断 $\phi$。这样的判断时间复杂度巨大，需要注意可拓展性：n 个进程每个 m 个可能行动 $O(m^n)$</p>
<ul>
<li>Possibly $\phi$：至少一个为真</li>
<li>Definetly $\phi$：永真 $definetly;\phi \implies possibly; \phi$</li>
<li>Never $\phi$：永假</li>
</ul>
<h2 id="ch-9-global-state-collection">ch 9 Global State Collection</h2>
<p>本章假定底层任务能表现出预期的性质（如检测终止算法中，底层任务确实能终止）</p>
<h3 id="全局广播">全局广播</h3>
<p>假设本地需要被收集的为 $s(i)$,最后每个进程都能收集到 $\forall i:V(i)={s(k):0\le k\le n-1}$。那 naive 的方法就是每次向邻居通知自己新知道的其他进程的信息，直到大家知道全了。消息复杂度：向每个邻居发，每次多一个：$O(n^2)$，全局 $O(n^3)$</p>
<pre tabindex="0"><code>program broadcast (for process i}
define Vi, Wi: set of values;
initially Vi = {s(i)}, Wi = Ø {and every channel is empty}
do Vi ≠ Wi      →   send Vi\Wi to every outgoing channel;
                    Wi:= Vi
[] ¬empty (k,i) →   receive X from channel (k,i);
                    Vi:= Vi ∪ X
od
</code></pre><ul>
<li>$empty(i,j)\implies W_i\subseteq V_j$：归纳法易证，注意到 $W_i^{r+1}=V_i^{r+1},V^{r+1}/W^r_i\subseteq V_j$</li>
<li>停止时候能保证 $\forall i:V(i)={s(k):0\le k\le n-1}$: 由上一条+停止条件 有 $\forall i,j:V_i\subseteq V_j$，显然</li>
<li>有界步终止：必然递增</li>
</ul>
<h3 id="程序终止检测">程序终止检测</h3>
<p>（不一定需要是全局终止，相同步时候也要检测某相结束以开启下一相）</p>
<h4 id="dijstra-scholten-算法">Dijstra-Scholten 算法</h4>
<blockquote>
<p>diffusing computation</p>
<p>由一个 initiator 开启，通知邻居逐步开始的计算</p>
</blockquote>
<ul>
<li>沿方向的消息为 <code>signal</code> ，反向消息为<code>ack</code></li>
<li>环境 environment 节点：只有向外边</li>
<li>内部 internal 节点：从环境节点可达</li>
<li>环境节点起始发<code>signal</code> 开始算法</li>
<li>任何节点第一次收到<code>signal</code> 的发送方为父节点，然后自己开始向邻居广播<code>signal</code></li>
<li>之后收到<code>signal</code> 立刻回复<code>ack</code>，自己邻居都回复了<code>ack</code>后向父节点回复<code>ack</code>，起始节点收完<code>ack</code>即算法结束</li>
<li>对于某条有向边，沿向<code>signal</code>和反向<code>ack</code>数值差为 deficit</li>
<li>对于某个节点：
<ul>
<li>$C$：入边的 deficit 和</li>
<li>$D$：出边的 deficit 和</li>
</ul>
</li>
</ul>
<p>在这样设定下，有如下 2 不变式：</p>
<ol>
<li>$(C\ge 0)\wedge(D\ge 0)$:deficit 定义可知</li>
<li>$(C&gt;0)\vee(D=0)$:（1 等待邻居子图完成）或者是（2 邻居都完成了，可以回复父节点了）</li>
</ol>
<p>注意上述不变式有 $(C&gt;1)\vee(C=1\wedge D=0)$，整个进程之间关系是一棵树。要求信道 FIFO（保证工作信息和检测信息之间正确顺序，防止虚假终止）。在大家确实停止后，消息复杂度 $O(|E|)$（每个信道来去各一次）</p>
<pre tabindex="0"><code>program detect {for an internal node i}
define  C, D : integer
        m: (signal, ack) {represents the type of message received}
        state: (active, passive)
initially C = 0, D = 0, parent(i) = i
do (m = signal) ∧ (C = 0)   → C := 1; state := active;
                                parent := sender
                                //开始准备向邻居广播
    [] m = ack                  → D := D − 1
    [] (C = 1 ∧ D = 0) ∧ (state = passive) → send ack to parent;
                                            C:= 0; parent(i) = i
                                 //节点可以返回初始状态了
    [](m = signal) ∧ (C = 1)    → send ack to the sender
                                // 对多余的signal直接回复ack
od
</code></pre><h4 id="单向环的-token-passing">单向环的 token passing</h4>
<ol>
<li>每个节点 <code>black,white</code>两个状态，初始<code>white</code></li>
<li>向 token 传递反向高的节点发消息后，变<code>black</code></li>
<li><code>white</code>节点传递 token 时颜色不变，<code>black</code>节点传递时染黑 token</li>
<li>节点传递完 token 后变回<code>white</code></li>
<li>initiator 能收发白色 token 即终止</li>
</ol>
<p>算法要求消息通信瞬时（新的消息要追上 token 速度）</p>
<pre tabindex="0"><code>program term {for process i &gt; 0，假定进程0为启动进程}
define  color, token: (black, white) {colors of process and token}
        state : (active, passive)
do  (token = white) ∧ (state ≠ passive)   → skip
    [](token = white) ∧ (state = passive) →
            if color(i) = black → color(i) := white; send a black token
            [] color(i) = white → send a white token
            fi
    [](token = black)   → send a black token
    []i sends a message to a higher numbered process → color(i) :=black
od
{for process 0}
send a white token;
do
(token ≠ white) → send a white token
od
//收回白token 结束
</code></pre><h4 id="信用点分配算法-credit-recovery-algorithm">信用点分配算法 credit-recovery algorithm</h4>
<ul>
<li>$\sum credit(i)=1$</li>
<li>对于活跃进程：$credit(i)&gt;0$</li>
<li>对于休眠进程：$credit(i)=0$</li>
</ul>
<ol>
<li>活跃进程发消息时，将自身$credit/2$ 随消息发出</li>
<li>休眠进程接到消息，转活跃，并对于自身$+=msg_{credit}$</li>
<li>活跃进程收到消息，可以：发回给启动进程，或者为了减少消息数目 保留加到自己的 $credit$</li>
</ol>
<h3 id="浪潮-wave-算法">浪潮 wave 算法</h3>
<blockquote>
<p>wave</p>
<p>一个启动进程某活动，引发邻居活动，进而邻居的邻居活动，此谓浪潮</p>
<ol>
<li>每个计算有界</li>
<li>每个计算至少包括一个确定性事件 decision event</li>
<li>一个确定性事件 decision event 在每个进程中一些事件的因果前</li>
</ol>
</blockquote>
<blockquote>
<p>PIF</p>
<p>Propagation of Information with Feedback，类似于 <a href="#dijstra-scholten-%E7%AE%97%E6%B3%95">Dijstra Scholten 算法</a>里的广播，但是此时返回是副本不是<code>ack</code></p>
</blockquote>
<pre tabindex="0"><code>program PIF {for the initiator node i}
define  count : integer
        N(i): set of neighbors of process i

send M to each neighbor; count := |N(i)|
do
    count ≠ 0 ∧ M received → count: = count − 1
od
{program for a non-initiator node j≠i}
if
    message M received → parent := sender
                        send M to each neighbor except parent;
                        count := |N(j)|;
    []count &gt; 0 ∧ M received → count: = count − 1
    []count = 0              → send M to parent
fi
</code></pre><h2 id="ch-11-coordination-algorithms">ch 11 Coordination Algorithms</h2>
<h2 id="ch-12-fault-tolerant-systems">ch 12 Fault-Tolerant Systems</h2>
<h2 id="ch-13-distributed-consensus">ch 13 Distributed Consensus</h2>
]]></content:encoded></item></channel></rss>