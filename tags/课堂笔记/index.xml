<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>课堂笔记 on zhh's blog</title><link>https://livypad.github.io/tags/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/</link><description>Recent content in 课堂笔记 on zhh's blog</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Tue, 04 Apr 2023 00:01:00 +0800</lastBuildDate><atom:link href="https://livypad.github.io/tags/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml"/><item><title>高级算法设计-课堂笔记（更新到第8次课）</title><link>https://livypad.github.io/post/2023-02-27-adalg/</link><pubDate>Tue, 04 Apr 2023 00:01:00 +0800</pubDate><guid>https://livypad.github.io/post/2023-02-27-adalg/</guid><description>高级算法设计 快速排序 python 算法代码 测试代码 rust 算法代码 测试代码 随机算法分类 形式化定义 算法的正确率提升 Les-Vegas 和 Monte-Carlo 转化 自动机 图灵机 图灵机线性加速定理 3-CNF 非确</description><content:encoded><![CDATA[<ul>
<li><a href="#%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1">高级算法设计</a>
<ul>
<li><a href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序</a>
<ul>
<li><a href="#python">python</a>
<ul>
<li><a href="#%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81">算法代码</a></li>
<li><a href="#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">测试代码</a></li>
</ul>
</li>
<li><a href="#rust">rust</a>
<ul>
<li><a href="#%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81-1">算法代码</a></li>
<li><a href="#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81-1">测试代码</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB">随机算法分类</a>
<ul>
<li><a href="#%E5%BD%A2%E5%BC%8F%E5%8C%96%E5%AE%9A%E4%B9%89">形式化定义</a></li>
<li><a href="#%E7%AE%97%E6%B3%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E7%8E%87%E6%8F%90%E5%8D%87">算法的正确率提升</a></li>
<li><a href="#les-vegas-%E5%92%8C-monte-carlo-%E8%BD%AC%E5%8C%96">Les-Vegas 和 Monte-Carlo 转化</a></li>
<li><a href="#%E8%87%AA%E5%8A%A8%E6%9C%BA">自动机</a></li>
<li><a href="#%E5%9B%BE%E7%81%B5%E6%9C%BA">图灵机</a>
<ul>
<li><a href="#%E5%9B%BE%E7%81%B5%E6%9C%BA%E7%BA%BF%E6%80%A7%E5%8A%A0%E9%80%9F%E5%AE%9A%E7%90%86">图灵机线性加速定理</a></li>
<li><a href="#3-cnf">3-CNF</a></li>
<li><a href="#%E9%9D%9E%E7%A1%AE%E5%AE%9A%E6%80%A7%E5%9B%BE%E7%81%B5%E6%9C%BA">非确定性图灵机</a></li>
</ul>
</li>
<li><a href="#%E8%A7%84%E7%BA%A6">规约</a>
<ul>
<li><a href="#%E5%9B%BE%E7%81%B5%E5%8F%AF%E8%AE%A1%E7%AE%97%E9%97%AE%E9%A2%98%E8%A7%84%E7%BA%A6%E5%88%B0-bool-%E7%BA%BF%E8%B7%AF">图灵可计算问题规约到 bool 线路</a></li>
<li><a href="#%E6%9E%84%E4%BB%B6%E6%9B%BF%E6%8D%A2%E8%A7%84%E7%BA%A6">构件替换规约</a></li>
</ul>
</li>
<li><a href="#pnp">P，NP</a>
<ul>
<li><a href="#ladner-%E5%AE%9A%E7%90%86">Ladner-定理</a></li>
</ul>
</li>
<li><a href="#p">#P</a>
<ul>
<li><a href="#permanent">Permanent</a></li>
</ul>
</li>
<li><a href="#csp">CSP</a></li>
<li><a href="#holant-csp">Holant-#CSP</a></li>
<li><a href="#%E4%BA%8C%E9%83%A8-holant-%E9%97%AE%E9%A2%98">二部 Holant 问题</a></li>
</ul>
</li>
<li><a href="#%E7%AE%97%E6%B3%95">算法</a>
<ul>
<li><a href="#%E7%9F%A9%E9%98%B5%E6%A3%80%E9%AA%8C">矩阵检验</a></li>
<li><a href="#gcd">GCD</a></li>
<li><a href="#%E7%B4%A0%E6%95%B0%E5%88%A4%E5%AE%9A">素数判定</a>
<ul>
<li><a href="#%E5%8F%8C%E8%BE%B9%E5%87%BA%E9%94%99%E7%AE%97%E6%B3%95">双边出错算法</a></li>
<li><a href="#%E5%8D%95%E8%BE%B9%E5%87%BA%E9%94%99%E7%AE%97%E6%B3%95">单边出错算法</a></li>
<li><a href="#%E5%8E%9F%E6%A0%B9">原根</a></li>
</ul>
</li>
<li><a href="#%E5%9B%BE%E5%AE%8C%E7%BE%8E%E5%8C%B9%E9%85%8D">图完美匹配</a></li>
<li><a href="#max-sat">MAX-SAT</a>
<ul>
<li><a href="#sat">SAT</a></li>
<li><a href="#%E6%AD%A3%E5%88%86-sat">正分-SAT</a></li>
</ul>
</li>
<li><a href="#max-cut">MAX-CUT</a></li>
</ul>
</li>
<li><a href="#birthday-paradox">Birthday Paradox</a>
<ul>
<li><a href="#msqrtn">m~sqrt(n)</a></li>
<li><a href="#mn">m~n</a>
<ul>
<li><a href="#%E4%B8%8A%E7%95%8C">上界</a></li>
<li><a href="#%E4%B8%8B%E7%95%8C">下界</a></li>
</ul>
</li>
<li><a href="#mn-1">m&gt;n</a></li>
</ul>
</li>
<li><a href="#%E5%BC%A0%E9%87%8F%E7%BD%91%E7%BB%9C">张量网络</a>
<ul>
<li><a href="#%E5%AE%9A%E4%B9%89">定义</a></li>
<li><a href="#%E5%BC%95%E5%85%A5%E5%A4%96%E8%BE%B9%E6%88%90%E4%B8%BA%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0">引入外边成为多元函数</a></li>
<li><a href="#st">s+t</a></li>
<li><a href="#%E5%85%A8%E6%81%AF%E8%A7%84%E7%BA%A6">全息规约</a></li>
<li><a href="#%E5%AF%B9%E7%A7%B0%E5%87%BD%E6%95%B0">对称函数</a></li>
<li><a href="#csp-%E4%BA%8C%E5%88%86%E5%AE%9A%E7%90%86">#CSP-二分定理</a>
<ul>
<li><a href="#csp-%E7%AC%AC%E4%B8%80%E6%98%93%E8%A7%A3%E7%B1%BB">#CSP-第一易解类</a>
<ul>
<li><a href="#%E5%81%B6%E6%95%B0%E6%9D%A1%E8%BE%B9%E7%9A%84%E5%AD%90%E5%9B%BE%E6%95%B0%E7%9B%AE%E7%AE%97%E6%B3%95">偶数条边的子图数目算法</a></li>
</ul>
</li>
<li><a href="#csp-%E7%AC%AC%E4%BA%8C%E6%98%93%E8%A7%A3%E7%B1%BB">#CSP-第二易解类</a></li>
</ul>
</li>
<li><a href="#%E5%9B%BE%E5%90%8C%E6%80%81%E6%98%A0%E5%B0%84%E6%95%B0%E7%9B%AE">图同态映射数目</a></li>
<li><a href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E9%97%A8">斐波那契门</a>
<ul>
<li><a href="#%E7%AE%97%E6%B3%95%E4%B8%80">算法一</a></li>
<li><a href="#%E7%AE%97%E6%B3%95%E4%BA%8C">算法二</a></li>
</ul>
</li>
<li><a href="#%E5%A5%87%E5%81%B6%E5%92%8C%E7%9B%B8%E7%AD%89%E5%85%B3%E7%B3%BB%E8%BD%AC%E6%8D%A2">奇偶和相等关系转换</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E7%BA%BF%E6%80%A7%E6%80%A7%E8%B4%A8%E7%BA%BF%E6%80%A7%E6%A3%80%E6%B5%8B">函数线性性质线性检测</a></li>
<li><a href="#%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86">容斥原理</a></li>
</ul>
</li>
<li><a href="#%E9%99%84%E5%BD%95-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">附录-基础知识</a>
<ul>
<li><a href="#markov-inequality">Markov-Inequality</a></li>
<li><a href="#chebyshev-inequality">Chebyshev-Inequality</a>
<ul>
<li><a href="#%E6%8A%BD%E6%A0%B7%E8%B0%83%E6%9F%A5%E5%87%86%E7%A1%AE%E7%8E%87">抽样调查准确率</a></li>
</ul>
</li>
<li><a href="#%E7%BB%84%E5%90%88%E6%95%B0%E4%B8%8D%E7%AD%89%E5%BC%8F">组合数不等式</a></li>
<li><a href="#chernoff-bound">Chernoff-Bound</a>
<ul>
<li><a href="#%E6%AD%A3%E5%90%91%E7%9A%84%E8%AF%81%E6%98%8E">正向的证明</a></li>
<li><a href="#%E8%B4%9F%E5%90%91%E7%9A%84%E8%AF%81%E6%98%8E">负向的证明</a></li>
</ul>
</li>
<li><a href="#fermat-little-theorem">Fermat-Little-Theorem</a>
<ul>
<li><a href="#carmichael-number">Carmichael-Number</a></li>
<li><a href="#%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86">中国剩余定理</a></li>
</ul>
</li>
<li><a href="#schwartz-zippel-lemma">Schwartz-Zippel-Lemma</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="高级算法设计">高级算法设计</h1>
<h2 id="快速排序">快速排序</h2>
<h3 id="python">python</h3>
<h4 id="算法代码">算法代码</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">random</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">swap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">quicksort</span><span class="p">(</span><span class="n">A</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">q</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">quicksort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">quicksort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">partition</span><span class="p">(</span><span class="n">A</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">pivot</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randrange</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span><span class="p">[</span><span class="n">pivot</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">swap</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">pivot</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">hi</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">hi</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">            <span class="n">A</span><span class="p">[</span><span class="n">hi</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">swap</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">hi</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span><span class="p">[</span><span class="n">hi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">swap</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">hi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">hi</span> <span class="o">+</span> <span class="mi">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="测试代码">测试代码</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">random</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">a</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">),</span> <span class="n">k</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">quicksort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="rust">rust</h3>
<p>注意一下，</p>
<ul>
<li><code>rand</code>库需要声明依赖</li>
<li>&lt;=这样的比较需要 <code>PartialOrd</code> 的 trait</li>
<li><code>sort()</code>需要实现 <code>Ord</code> 的 trait，只有整型有；浮点类型只能使用<code>sort_by()</code>去自定义比较函数</li>
<li><code>sort()</code>是原位排序，更加推荐更快的 <code>sort_unstable()</code></li>
</ul>
<h4 id="算法代码-1">算法代码</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">rand</span>::<span class="n">Rng</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">quicksort</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">PartialOrd</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arr</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="n">T</span><span class="p">],</span><span class="w"> </span><span class="n">p</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">r</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">partition</span>::<span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">quicksort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">quicksort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">partition</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">PartialOrd</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arr</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="n">T</span><span class="p">],</span><span class="w"> </span><span class="n">p</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">r</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">arr</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">rand</span>::<span class="n">thread_rng</span><span class="p">().</span><span class="n">gen_range</span><span class="p">(</span><span class="n">p</span><span class="o">..</span><span class="n">r</span><span class="p">),</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">hi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">p</span><span class="o">..</span><span class="n">r</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">r</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">arr</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">hi</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">arr</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">hi</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="测试代码-1">测试代码</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-toml" data-lang="toml"><span class="line"><span class="cl"><span class="p">[</span><span class="nx">dependencies</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">rand</span><span class="p">=</span><span class="s2">&#34;0.8.0&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">rand</span>::<span class="n">seq</span>::<span class="n">SliceRandom</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">mod</span> <span class="nn">quicksort</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">const</span><span class="w"> </span><span class="n">UP</span>: <span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="mi">200000</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">arr</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">UP</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">arr</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">rand</span>::<span class="n">thread_rng</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">new_arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">quicksort</span>::<span class="n">quicksort</span><span class="p">(</span><span class="n">new_arr</span><span class="p">.</span><span class="n">as_mut_slice</span><span class="p">(),</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">.</span><span class="n">len</span><span class="p">(</span><span class="w">                                                        </span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">arr</span><span class="p">.</span><span class="n">sort</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">new_arr</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">arr</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">f32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">UP</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">f32</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">arr</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">rand</span>::<span class="n">thread_rng</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">new_arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">quicksort</span>::<span class="n">quicksort</span><span class="p">(</span><span class="n">new_arr</span><span class="p">.</span><span class="n">as_mut_slice</span><span class="p">(),</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">.</span><span class="n">len</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">arr</span><span class="p">.</span><span class="n">sort_unstable_by</span><span class="p">(</span><span class="o">|</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="o">|</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">partial_cmp</span><span class="p">(</span><span class="n">b</span><span class="p">).</span><span class="n">unwrap</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">new_arr</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="随机算法分类">随机算法分类</h2>
<blockquote>
<p>Las Vegas 算法</p>
<p>随机数对结果正误没有影响，但是对于运行时间有影响（允许最坏情况下不终止）。eg，<a href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快排</a></p>
</blockquote>
<blockquote>
<p>Monte Carlo 算法</p>
<p>随机数选择会影响是否出错。eg，<a href="#%E7%9F%A9%E9%98%B5%E6%A3%80%E9%AA%8C">检验矩阵乘法正确性</a></p>
</blockquote>
<p>上述的定义不关心是否是多项式时间复杂度。考虑现实一般都会加上。</p>
<h3 id="形式化定义">形式化定义</h3>
<ul>
<li>Zero-error,Probabilistic,Poly(ZPP)，时间的期望为多项式
<ul>
<li>$$
\begin{aligned}
l\in \mathcal{ZPP} \iff&amp;\exists deterministic\ alg\ A\in \mathcal{P},random\ input\ r,\\
&amp;\{x\in l \iff A(x,r)=1\}
\end{aligned}
$$</li>
</ul>
</li>
<li>Randomized Poly 单边出错，假阳性，时间被多项式限制
<ul>
<li>$$
\begin{aligned}
l\in \mathcal{RP} \iff&amp;\exists deterministic\ alg\ A\in \mathcal{P},random\ input\ r,\\
&amp;\{x\in l \rightarrow Pr(A(x,r)=1)\ge\frac{1}{2},\\
&amp;x\notin l \rightarrow Pr(A(x,r)=0)=1 \}
\end{aligned}
$$</li>
</ul>
</li>
<li>Co-RP 单边出错，假阴性
<ul>
<li>$$
\begin{aligned}
l\in \mathcal{Co-RP} \iff&amp;\exists deterministic\ alg\ A\in \mathcal{P},random\ input\ r,\\
&amp;\{x\in l \rightarrow A(x,r)=1\ge\frac{1}{2},\\
&amp;x\notin l \rightarrow Pr(A(x,r)=0)\ge\frac{1}{2} \}
\end{aligned}
$$</li>
<li>$$
\{\bar{l}|l\in\mathcal{RP}\}
$$</li>
</ul>
</li>
<li>Bounded Probabilistic Poly(BPP) 双边出错
<ul>
<li>$$
\begin{aligned}
l\in \mathcal{BBP} \iff&amp;\exists deterministic\ alg\ A\in \mathcal{P},random\ input\ r,\\
&amp;\{x\in l \rightarrow Pr(A(x,r)=1)\ge\frac{2}{3},\\
&amp;x\notin l \rightarrow Pr(A(x,r)=0)\ge\frac{2}{3} \}
\end{aligned}
$$</li>
</ul>
</li>
</ul>
<h3 id="算法的正确率提升">算法的正确率提升</h3>
<p>事实上，上述定义中的概率常量不影响（对于$\mathcal{RP}\mathcal{Co-RP}$常数无关，对于$\mathcal{BPP}$错误率小于$\frac{1}{2}$，集合之间等同。独立随机的输入运行多次，然后选择结果。</p>
<p>eg，$\mathcal{RP}_\frac{1}{2}$ 提升到 $\mathcal{RP}_\frac{1}{4}$ ，运行 2 次，至少一次 1 即输出 1，全 0 输出 0。</p>
<p>eg， $\mathcal{BBP}_\frac{1}{3}$ 提升（错误率不能超过 $\frac{1}{2}$）。取独立随机输入$r_1,&hellip;r_{2t+1}$ 对应随机变量$Y_1,&hellip;Y_{2t+1}$，如果和$Y=\sum Y_i\ge t+1$，输出 1，反之输出 0</p>
<p>$$
\begin{aligned}
&amp;Pr(\sum Y_i\le t)\\
&amp;=Pr(Y-E(Y)\le t-E(Y))\\
&amp;\le Pr(Y-E(Y)\le t-(2t+1)\frac{2}{3})\\
&amp;\le Pr(|Y-E(Y)| \ge t/3+2/3)\\
&amp;\le \frac{Var(Y)}{(t/3+2/3)^2}\\
&amp;\le \frac{(2t+1)Var(Y_i)}{(t/3+2/3)^2}\\
&amp;\le \frac{(2t+1)/4}{(t/3+2/3)^2}\\
\end{aligned}
$$</p>
<p>t 足够大时，正确的概率即可足够大</p>
<h3 id="les-vegas-和-monte-carlo-转化">Les-Vegas 和 Monte-Carlo 转化</h3>
<p>$$\mathcal{RP}\cap\mathcal{Co-RP}=\mathcal{ZPP} $$</p>
<ol>
<li>$\mathcal{ZPP}\subseteq\mathcal{RP}$：超时直接输出一个结果，按照$\mathcal{RP}$的要求，给 0（超时概率被 <a href="#markov-inequality">markov 不等式限制</a>，给出 1 一定正确，给 0 可能会出错 ）</li>
<li>$\mathcal{ZPP}\subseteq\mathcal{Co-RP}$，类似的</li>
<li>$\mathcal{RP}\cap\mathcal{RP}\subseteq\mathcal{ZPP}$：联立$A_1\in\mathcal{RP} ,A_2\in\mathcal{Co-RP}$,(1,1)输出 1，(0,0)输出 0，(0,1)再来一次。时间期望被正确率控制（(1,0)自相矛盾，不可能发生）</li>
</ol>
<p>这些算法集合关系如下。注意，$\mathcal{NP}$和$\mathcal{BPP}$之间实际上关系未知，有待进一步证明。目前大概认为不等</p>
<p><img loading="lazy" src="/assets/img/p-npvenn.png" alt="p,np,zpp,rp,bpp"  />
</p>
<h3 id="自动机">自动机</h3>
<blockquote>
<p>自动机</p>
<p>每次读取下一个字符（有限集$\Sigma$），根据状态转移函数改变状态（有限集$Q$）</p>
<p>$\delta:Q\times \Sigma\to Q$</p>
</blockquote>
<blockquote>
<p>语言</p>
<p>字符串的集合 $L\subseteq\Sigma^*$</p>
<p>等价定义指示函数 $L:\Sigma^*\to {0,1}$</p>
</blockquote>
<blockquote>
<p>正则语言</p>
<p>能被自动机接收的语言</p>
</blockquote>
<blockquote>
<p>有限差异</p>
<p>集合${\sigma|L_1(\sigma)\neq L_2(\sigma)}$有限大小</p>
</blockquote>
<p>有限语言都是正则语言。正则语言对于交、并、补运算封闭。</p>
<p>对于两个有限差异的问题$L_1,L_2$，对于$L_1$有复杂度$T(n)$为算法。那么对于$L_2$，总可以把差异部分打表，相同部分调用$L_1$的算法，形成一个$T(n)+n+c$的算法。</p>
<ul>
<li>判定问题 $F:\Sigma^*\to {0,1}$</li>
<li>优化问题 $F:\Sigma^*\to \Sigma^*$</li>
<li>计数问题 $F:\Sigma^*\to \mathbb{N}$</li>
</ul>
<h3 id="图灵机">图灵机</h3>
<blockquote>
<p>图灵机</p>
<p>根据状态和读入的字符，可以写字符，变状态，左右移动</p>
<p>$F:Q\times \Gamma\to Q\times \Gamma\times\{\leftarrow,\rightarrow\}$</p>
</blockquote>
<blockquote>
<p>（图灵）可计算问题</p>
<p>起始状态时，带子作为输入字符串。停机之后，带子上字符串作为输出</p>
<p>$F:\Sigma^*\to \Sigma^*$</p>
</blockquote>
<p>图灵机是所有编程语言的计算能力。</p>
<h4 id="图灵机线性加速定理">图灵机线性加速定理</h4>
<p>对于一个可计算问题，存在一个图灵机有复杂度$T(n)$算法。那么存在一个图灵机可以实现$\frac{1}{d}T(n)+n+c$的算法。</p>
<p>主要靠扩充状态和字符集，将原先的状态和字符压缩表示。</p>
<h4 id="3-cnf">3-CNF</h4>
<p>$$\psi=C_1\wedge C_2&hellip;$$</p>
<p>当中子句是 3 元或函数，当中文字为变量的形式$x_i,\neg x_i$：$C_i=l_{i,1}\vee l_{i,2}\vee l_{i,3}$</p>
<ul>
<li>非门: $x=\neg y \iff (x\vee y)\wedge(\neg x\vee \neg y)$</li>
<li>或门: $x=(y\vee z)\iff (\neg x\vee y\vee z)\wedge(x\vee \neg y)\wedge(x\vee \neg z)$</li>
</ul>
<p><a href="#sat">作为 3SAT 的基础</a>。而且，对于 4SAT 问题，定义一个新变量$z_i$来表示一个子句$l_{i,1}\vee l_{i,2}\vee l_{i,3}\vee l_{i,4}$，写成$l_{i,1}\vee l_{i,2}\vee z_i,\neg z_i\vee l_{i,3}\vee l_{i,4}$。</p>
<h4 id="非确定性图灵机">非确定性图灵机</h4>
<p>non-deterministic Turing machine</p>
<blockquote>
<p>非确定性图灵机</p>
<p>根据状态和读入的字符，接下来随机选择状态转移（可以认为是无限度的并行执行，选择最正确的分支作为结果），可以写字符，变状态，左右移动</p>
<p>$F:Q\times {0,1}\to Q\times \Sigma\times\{\leftarrow,\rightarrow\}$</p>
</blockquote>
<h3 id="规约">规约</h3>
<p>对于规约$\Psi$，有$F(X)=H(\Psi(X))$</p>
<p>如果规约$\Psi$是多项式时间的、$\log$空间、etc；称为多项式时间规约、$\log$空间规约、etc。记为$\le^\text{cost}_{way}$。</p>
<ul>
<li>多项式时间规约：$F\le^\text{poly}_m H\implies p(n)+q(p(n))$，规约时间+H 算法（规约输入）</li>
<li>图灵规约：递归调用$H$，adaptive。需要带 oracle 的图灵机（预言机，指的是规约到更强大的预言机来解决）$F\le^\text{poly}_T H\implies p(n)+p(n)q(p(n))$，规约时间+规约出来的状态数目*H 算法（规约输入）</li>
<li>Truth Table 规约：一次给定多个$H$,non-adaptive</li>
</ul>
<p>如果$\forall F\in\mathcal{NP}$，$F$可以被规约到问题$H$，称$H$为$\mathcal{NP}-C$问题（NP 完全问题）</p>
<h4 id="图灵可计算问题规约到-bool-线路">图灵可计算问题规约到 bool 线路</h4>
<p>对于输入字符串为$n$。图灵机停机用时$T(n)$。那么必然读写头移动范围不超过$T(n)$。可以把图灵机的运行过程用一个$T(n)\times T(n)$的表格表示。每格记为$\Sigma\times (Q\cup{\mathcal{o}})$，表示每格的字符，图灵机状态、读写头是否在本格。即为<strong>计算表格</strong>。</p>
<p>因此，上述每格的有限数目的状态用$c$个 bit 编码。注意到，任意一个时刻某个位置字符是否改变，必然只取决于上一个时刻其左右 3 个字符的情况（$3c$个 bit）。因此最后可以表达为有限个逻辑门组合。</p>
<p>注意，对于$\mathcal{NP}$问题，对于多项式时间判定函数$R()$的计算表格，也可以类似规约。如此规约出来的问题具有 <a href="#3-cnf">3CNF 问题</a>的形式。由此也可以证明<a href="#sat">3SAT 问题</a>是$\mathcal{NP}$完全的。</p>
<h4 id="构件替换规约">构件替换规约</h4>
<p>对于$A\le B$的规约，由于张量网络结合律，使用 B 的构件，发挥 A 中函数作用。如<a href="#3-cnf">4SAT 到 3SAT 的规约</a>。</p>
<h3 id="pnp">P，NP</h3>
<p>判定问题，可以对应一个集合/语言。</p>
<p>$$f:x\to \{0,1\}$$</p>
<p>$$L_f=\left\{x|f(x)=1 \right\}$$</p>
<ul>
<li>$\mathcal{P}$：对于<a href="#%E5%9B%BE%E7%81%B5%E6%9C%BA">图灵机</a>多项式时间可解</li>
<li>$\mathcal{NP}$：对于<a href="#%E9%9D%9E%E7%A1%AE%E5%AE%9A%E6%80%A7%E5%9B%BE%E7%81%B5%E6%9C%BA">非确定性图灵机</a>多项式时间可解；多项式时间可验证一个解的正确性</li>
</ul>
<p>存在多项式时间算法$R$有输入$|y|=|x|^k$，有$F\in\mathcal{NP},F(x)=1\iff \exists y,R(x,y)=1$</p>
<h4 id="ladner-定理">Ladner-定理</h4>
<p>如果$\mathcal{P}\neq\mathcal{NP}$，存在问题不是 P，也不是 NP 难。</p>
<p>构造一个算法，使得增长速度能够介于$\mathcal{P}$与$\mathcal{NP}$之间。大致思路是，在 SAT 之间插入$n^{H(n)}$的 1，当中$H(n)$是关于$n$的多项式时间函数，且$n$趋于无穷时候趋于无穷。记$SAT_H={\psi01^{n^{H(n)}}:\psi\in SAT \wedge n=|\psi|}$。</p>
<h3 id="p">#P</h3>
<p>函数$F$属于$\#P$问题：存在多项式时间算法$R$，使得$F(x)=|{y|R(x,y)=1}|$（多项式时间验证可解的解的计数）</p>
<p>如果任何$\#P$的问题可以规约到问题 B，B 是$\#P$完全（$\#P-complete$）。$\#P-complete$也是$\mathcal{NP}$完全的。#SAT 是$\#P$完全的。 <a href="#Permanent">01Permanent 问题</a>也是$\#P$完全的</p>
<h4 id="permanent">Permanent</h4>
<p>对于 A ：</p>
<ul>
<li>n 个点带权有向图，所有圈的权重和；</li>
<li>二分图的所有完美匹配权重和</li>
<li>这个定义对比行列式的定义，去除了符号项</li>
</ul>
<p>$$Permanent(A)=\sum_{\pi \in S_n}\prod A_{j,\pi(j)}$$</p>
<h3 id="csp">CSP</h3>
<blockquote>
<p>$CSP(\mathcal{F})$ 问题（Constraint Satisfaction Problem）</p>
<p>变量的约束满足形式$\mathcal{F}$，约束是否可以满足的问题</p>
</blockquote>
<p>$\mathcal{F}$如果有形式，$CSP(\mathcal{F})$为 P 问题，否则为 NP 难</p>
<ul>
<li>0-valid</li>
<li>1-valid</li>
<li>Horn SAT</li>
<li>dual Horn SAT</li>
<li>affine（线性函数）</li>
<li>bijunctive（2SAT）</li>
</ul>
<p>3-SAT 作为 CSP 的特例。每个子句相当于 8 种约束中的一种。要求满足所有约束</p>
<h3 id="holant-csp">Holant-#CSP</h3>
<blockquote>
<p>$Holant(\mathcal{F})$问题</p>
<p>对于张量网络$G$,点上的函数属于$\mathcal{F}$，输出 G 的值</p>
</blockquote>
<blockquote>
<p>$\#CSP(\mathcal{H})$ 问题（Constraint Satisfaction Problem 计数）</p>
<p>张量网络形如 $=_n,F_i\in\mathcal{H}$ 的二部图</p>
<p>$\#CSP(\mathcal{H})=Holant(\{=_i&hellip;\}\cup \mathcal{H})$</p>
</blockquote>
<p>对于变量集合$X=\{x_1,x_2,&hellip;x_n\}$，有函数 $R_1(x_{1,1},&hellip;x_{1,r_1}),&hellip;R_m(x_{m,1},&hellip;x_{m,r_m})$，函数有$R_i\in\mathcal{F}$。$\#CSP(\mathcal{F})$就是求解</p>
<p>$$\sum_{\sigma:X\to D}\prod R_j(\sigma(x_{j,1}）,&hellip;,\sigma(x_{j,r_j}))$$</p>
<p>对于#CSP 问题，其中一部分是$\mathcal{P}$问题，见<a href="#csp-%E4%BA%8C%E5%88%86%E5%AE%9A%E7%90%86">#CSP 二分定理</a></p>
<h3 id="二部-holant-问题">二部 Holant 问题</h3>
<p>对于两个函数集合$\mathcal{H},\mathcal{F}$，对于二部图$G(U,V,E)$：$U$上函数来自$\mathcal{H}$；$V$上函数来自$\mathcal{F}$ 定义问题$\#\mathcal{H}|\mathcal{F}$，求解张量网络值。也被称为二部 Holant 问题</p>
<p>注意，任何一条边，可以转化成两条连着二元相等关系顶点$=_2$的边。因此，有如下等价关系</p>
<ol>
<li>$\#\mathcal{F}\equiv\#\{=_2\}|\mathcal{F}$</li>
<li>$\#CSP(\mathcal{F})\equiv\#\{=_i,&hellip;\}|\mathcal{F}$</li>
<li>$\#CSP(\mathcal{F})\equiv\#\{=_i,&hellip;\}\cup\mathcal{F}$
<ol>
<li>在$\mathcal{F}$直接有两边相连，插入$=_2$</li>
<li>$=_i$关系相连，转换为一个更大的相等关系</li>
</ol>
</li>
</ol>
<p>问题的集合和实例的集合不是一回事：</p>
<ul>
<li>从问题角度，#CSP 问题类是 Holant 问题类的子集,$\#CSP(\mathcal{F})=\#\mathcal{F}\cup\{=_i,&hellip;\}\subseteq\#\mathcal{F}$</li>
<li>对于一个确定的函数集合$\mathcal{F}$，$\#\mathcal{F}$的实例对应的实例$\#CSP(\mathcal{F})\supseteq\#\mathcal{F}\cup\{=_2\}$，前者可规约到后者</li>
</ul>
<h2 id="算法">算法</h2>
<h3 id="矩阵检验">矩阵检验</h3>
<p>在$O(n^2)$，概率判断两矩阵乘是否相等另一矩阵。重复选择向量$x$。对于 0，1 的 2-bit 矩阵，错误率（在不等情况下）为$\frac{1}{2}$。</p>
<p>$$A(Bx)==Cx$$</p>
<h3 id="gcd">GCD</h3>
<p>不分解质因数，使用辗转相除法计算最大公因数 GCD。至多 2 次减半，时间复杂度度$O(\ln n*\ln^2 n)$。</p>
<p>辗转相除法的过程中，还可以同时构造得到 Bezout 系数$x,y\in \mathbb{Z}$使得 $GCD(a,b)=x\times a+y\times b$。一个可能的实现如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">num</span>::<span class="n">Integer</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">cmp</span>::<span class="p">{</span><span class="n">max</span><span class="p">,</span><span class="w"> </span><span class="n">min</span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ops</span>::<span class="p">{</span><span class="n">Div</span><span class="p">,</span><span class="w"> </span><span class="n">Neg</span><span class="p">,</span><span class="w"> </span><span class="n">Rem</span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">gcd</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Integer</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Neg</span><span class="o">&lt;</span><span class="n">Output</span><span class="o">=</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Copy</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span>: <span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">b</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">r_rep</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[(</span><span class="n">T</span>::<span class="n">zero</span><span class="p">(),</span><span class="w"> </span><span class="n">T</span>::<span class="n">one</span><span class="p">())];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">v2</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max_min</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">div_rem</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">is_zero</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r_rep</span><span class="p">.</span><span class="n">pop</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">it</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">it</span><span class="p">.</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">it</span><span class="p">.</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">it</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(((</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">)))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_last2_items</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r_rep</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">r_rep</span><span class="p">.</span><span class="n">push</span><span class="p">((</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">d</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">r_rep</span><span class="p">.</span><span class="n">push</span><span class="p">((</span><span class="n">T</span>::<span class="n">one</span><span class="p">(),</span><span class="w"> </span><span class="o">-</span><span class="n">q</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v2</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">get_last2_items</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Copy</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v</span>: <span class="kp">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">len</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nb">Some</span><span class="p">((</span><span class="n">v</span><span class="p">[</span><span class="n">l</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="n">l</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">]))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nb">None</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">div_rem</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Div</span><span class="o">&lt;</span><span class="n">Output</span><span class="o">=</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Rem</span><span class="o">&lt;</span><span class="n">Output</span><span class="o">=</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Copy</span><span class="o">&gt;</span><span class="p">(</span><span class="n">dividend</span>: <span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">divisor</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">(</span><span class="n">dividend</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">divisor</span><span class="p">,</span><span class="w"> </span><span class="n">dividend</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">divisor</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">max_min</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Ord</span> <span class="o">+</span><span class="w"> </span><span class="nb">PartialOrd</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Copy</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v1</span>: <span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">),</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="素数判定">素数判定</h3>
<p>对于一个大小为 n 的数，注意到表示这个数需要的复杂度是$O(\ln n)$。所以合理的多项式时间算法，应该是针对$\sim \ln n$的多项式。</p>
<h4 id="双边出错算法">双边出错算法</h4>
<p>给定一个$\mathcal{BPP}$算法</p>
<ol>
<li>n 不是不为 2 的偶数</li>
<li>$n=r^s\qquad r,s&gt;1$
<ol>
<li>$r$遍历过$2&hellip;\log_2{n}$</li>
<li>二分查找$r^s&lt;n$，判断是否成立，时间复杂度$O(\ln^3 n)$，遍历+二分查找+翻倍乘法（FFT）作为基</li>
</ol>
</li>
<li>独立随机的取$a_1,a_2,..a_{10}\in[2,n-1]$
<ol>
<li>$GCD(\prod a_i,n)\neq 1$，结束，<a href="#gcd">时间复杂度</a> $O(\ln^3 n)$</li>
<li><a href="#fermat-little-theorem">费马小定理检测</a>$a_i^{n-1}\neq 1\pmod n$，结束</li>
<li>$a_i^{\frac{n-1}{2}}\neq \pm1\pmod n$，结束</li>
<li>$\exists i,a_i^{\frac{n-1}{2}}\equiv -1\pmod n$，是素数，结束</li>
<li>全是+1，合数</li>
</ol>
</li>
</ol>
<p>对于素数$p$，有$(a^{\frac{p-1}{2}}-1)(a^{\frac{p-1}{2}}+1)=a^{p-1}-1\equiv0\pmod p$。p 至少整除$a^{\frac{p-1}{2}}-1,a^{\frac{p-1}{2}}+1$其中一个。因此必有$a^{\frac{p-1}{2}}\equiv \pm1\pmod p$。对于素数，只有最后两个步骤可能出问题。mod 为+1 的概率为$\frac{1}{2}$，<a href="#%E5%8E%9F%E6%A0%B9">因为原根</a>。</p>
<p>对于合数。</p>
<p>$$
\begin{aligned}
\epsilon=Pr(\exists i,&amp;a_i^{\frac{n-1}{2}}\equiv -1\pmod n\\
\forall i,&amp;a_i^{\frac{n-1}{2}}\equiv \pm1\pmod n,\
&amp;a_i^{n-1}\equiv 1\pmod n )
\end{aligned}
$$</p>
<p>找一个坏的$y$使得$y^{\frac{n-1}{2}}\neq \pm1\pmod n$。然后 y 和其他的 mod 余数为$\pm1$的乘，即可生成等大小的集合，<a href="#%E5%8E%9F%E6%A0%B9">类似原根里的构造集合</a> 。使得能正确筛出概率$\ge \frac{1}{2}$。坏的$y$在 mod -1 元素存在时（$a^{\frac{n-1}{2}}\equiv -1\pmod n=-1\pmod{PQ}$）必然存在。</p>
<p>分解有$n=p^\alpha Q=P\times Q\implies GCD(P,Q)=1$（分解的存在性由通过第 2 大步保证，Q 是剩下素因子乘积）。使用 <a href="#%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86">中国剩余定理</a>保证下列要求有解。</p>
<p>$$
\left\{
\begin{aligned}
&amp;y\equiv 1\pmod{P}\\
&amp;y\equiv a\pmod{Q},\qquad a\neq \pm 1
\end{aligned}
\right.
$$</p>
<p>而且容易知道，解$y\star$不能是 naive 的 1，-1，否则下列等式总有一行不成立。且等式和在一起必与$y^{\frac{n-1}{2}}\equiv \pm1\pmod n$矛盾（对 n mod $\pm1$，对于 PQ 必然都 mod $\pm 1$两个结果一样，因为$(y\mp 1)\mod n=(y\mp 1)\mod P=(y\mp 1)\mod Q=0$）</p>
<p>$$
\left\{
\begin{aligned}
&amp;y\star^{\frac{n-1}{2}}=1^\frac{n-1}{2}=1\equiv 1\pmod{P}\\
&amp;y\star^{\frac{n-1}{2}}=a^{\frac{n-1}{2}}\equiv -1\pmod{Q}
\end{aligned}
\right.
$$</p>
<h4 id="单边出错算法">单边出错算法</h4>
<p>关于素数$\mathcal{Co-RP}$，关于合数的$\mathcal{RP}$算法。前大部分得出合数都是可靠的。</p>
<ol>
<li>n 不是不为 2 的偶数</li>
<li>$n=r^s\qquad r,s&gt;1$
<ol>
<li>$r$遍历过$2&hellip;\log_2{n}$</li>
<li>二分查找$r^s&lt;n$，判断是否成立，时间复杂度$O(\ln^3 n)$，遍历+二分查找+翻倍乘法（FFT）作为基</li>
</ol>
</li>
<li>随机选取$a\in[2,n-1]$
<ol>
<li>$GCD(a,n)\neq 1$，合数</li>
<li>$a^{n-1}\neq 1\pmod{n}$，合数</li>
<li>$a^{\frac{n-1}{2}}\neq \pm1\pmod{n}$，合数</li>
<li>$n-1=2^rs$遍历，$a^{2^{r-1}s},&hellip;a^s$，mod n，检测结果序列
<ol>
<li>出现$\neq \pm1$，合数</li>
<li>出现$1,-1$形式，素数，可能错误选出合数</li>
<li>全是 1，素数，可能错误选出合数</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>注意，$s$ 是奇数，必然的$-1^s\equiv -1\pmod{n}$。和<a href="#%E5%8F%8C%E8%BE%B9%E5%87%BA%E9%94%99%E7%AE%97%E6%B3%95">之前合数部分类似的</a>，可以拓展出坏根。出现$\neq \pm1$的概率$\ge \frac{1}{2}$</p>
<h4 id="原根">原根</h4>
<p>原根有$a\star ^{\frac{p+1}{2}}\equiv-1\pmod p$。素数必有原根。且原根能满足下列集合在 mod p 意义上的相等</p>
<p>$$p,a\star\implies \{a\star ^1,a\star^2 &hellip; a\star ^{p-1}\}\pmod p=\{1,2,3&hellip;p-1\}\pmod p$$</p>
<p>假定一个数已知有原根。那 mod 之后，等于 1，-1 的集合等大小（原根乘 mod 余 1 的集合每个元素，构造出来两个集合等大小）。</p>
<h3 id="图完美匹配">图完美匹配</h3>
<p>对于二部图$G(U,V,E)$，对于其邻接矩阵表示$M$，不存在完美匹配的充分条件为$\det(M)=0$</p>
<p>$$\det(M)=\sum_{\pi\in S_n}(-1)^{sign(\pi)}\prod^n_{j=1}m_{j,z(j)}$$</p>
<p>不是必要条件，因为比如完全的二部图的邻接矩阵，每行每列全为 1，会导致抵消而等于 0。引入$O(n^2)$个变量，保证$\det(M)$行列之间不相消</p>
<p>$$
m_{ij}=\left\{
\begin{aligned}
&amp;x_{ij}\qquad (u_i,v_j)\in E\\
&amp;0     \qquad (u_i,v_j)\notin E
\end{aligned}
\right.
$$</p>
<p>此时不存在完美匹配的充要条件即为$\det(M)=M(x_{ij})\equiv0$</p>
<p><a href="#schwartz-zippel-lemma">使用 Schwartz Zippel Lemma</a>，取素数$n^2\le p\le 2n^2$，独立随机取$r_1,&hellip;r_n\in \mathbb{F}_p=[1..p]\subseteq\mathbb{Z}$，在模 p 意义下计算行列式（eg，高斯消元法数值计算，时间复杂度$O(n^3)$）。该算法对于有匹配的图可能给出无匹配的错误结果，单边出错。</p>
<p>$$
\begin{aligned}
\epsilon&amp;=Pr(\det(M)=0)=Pr(M(x_{ij})=0)\\
&amp;\le \frac{\deg(M)}{p}\\
&amp;=\frac{n}{n^2}=\frac{1}{n}
\end{aligned}
$$</p>
<h3 id="max-sat">MAX-SAT</h3>
<h4 id="sat">SAT</h4>
<p>对于 bool 变量$x_1,&hellip;x_n$，有逻辑表达式$\varphi=(x_i\vee&hellip;)\wedge&hellip;$，是否存在一组取值使得$\varphi$可被满足为真。<a href="#%E5%9B%BE%E7%81%B5%E5%8F%AF%E8%AE%A1%E7%AE%97%E9%97%AE%E9%A2%98%E8%A7%84%E7%BA%A6%E5%88%B0-bool-%E7%BA%BF%E8%B7%AF">3-SAT 为$\mathcal{NP}$问题</a>。</p>
<h4 id="正分-sat">正分-SAT</h4>
<p>逻辑表达式$\varphi=(x_i\vee&hellip;)\wedge&hellip;$，每个子句满足有正分，反之 0 分。MAX-2SAT 是$\mathcal{NP}$问题。</p>
<p>$$\varphi=(x_1\vee \bar{x}_2)\wedge(\bar{x}_1\vee x_3\vee\bar{x}_4)&hellip;$$</p>
<p>考虑变量$y_1,&hellip;y_m\in\{0,1\}$，当中$y_i$表示第 i 个 clause 是否被满足。优化目标即为$W=w_1y_1+&hellip;w_my_m$。把逻辑表达式转化为约束条件有</p>
<p>$$
\left\{
\begin{aligned}
&amp;y_1\le x_1+(1-x_2)\\
&amp;y_2\le (1-x_1)+x_3+(1-x_4)\\
&amp;&hellip;\\
&amp;x_i\in\{0,1\}\\
&amp;y_i\in\{0,1\}\\
\end{aligned}
\right.
$$</p>
<p>问题为 Integer Linear Programming（ILP），为$\mathcal{NP}$。可以把整数约束松弛求近似解（线性规划是$\mathcal{P}问题$），$0\le x_i\le1,0\le y_i\le 1$。由于范围更大，有$opt(\tilde{P})\ge opt(P)$（可以证明$opt(\tilde{P})$必然是一个分数解）。令随机变量$Pr(X_i=1)=x_i^{\star}$，把$opt(\tilde{P})$的结果作为概率去做舍入（可以保持均值/期望不变）</p>
<p>此时，有 clause 的满足也成为随机变量$Y_i$，$R=w_1Y_1+&hellip;w_mY_m$</p>
<p>$$
\begin{aligned}
\mathbb{E}(R)&amp;=\sum w_iE(Y_i)\\
&amp;=\sum w_iPr(Y_i=1)\\
&amp;=\sum w_i(1-Pr(Y_i=0))\\
&amp;=\sum w_i(1-\prod(Pr(X_i=1/0)))\\
&amp;\ge \sum w_i(1-[\frac{\sum x^{\star}/(1-x^{\star})}{s_i}]^{s_i})\qquad\text{$X_i=1/0$对应概率}\\
&amp;=\sum w_i(1-[\frac{s_i -\sum (1-x^{\star})/x^{\star}}{s_i}]^{s_i})\qquad\text{平均值不等式}\\
&amp;=\sum w_i(1-(1-\frac{y_i^{\star}}{s_i})^{s_i})\qquad \text{注意逻辑表达式}
\end{aligned}
$$</p>
<p>对于$k\ge2,z\in[0,1]$，有上凸函数$f(z),f(0)=0,f(1)=1-(1-\frac{1}{k})^k \le1-\frac{1}{e}$</p>
<p>$$
\begin{aligned}
f(z)&amp;=1-(1-\frac{z}{k})^k&gt;0\\
f^\prime(z)&amp;=(1-\frac{z}{k})^{k-1}&gt;0\\
f^{\prime\prime}(z)&amp;=-\frac{k-1}{k}(1-\frac{z}{k})^{k-2}&lt;0
\end{aligned}
$$</p>
<p>上凸函数有函数值大于直线，有$f(z)=1-(1-\frac{z}{k})^k&gt;(1-\frac{1}{e})z$。则$\mathbb{E}(R)\ge \sum w_i(1-\frac{1}{e})y_i^{\star}$。又由于松弛条件$opt(P)\le opt(\tilde{P})=\sum w_iy_i^{\star}$。可以得出估计的偏差可被有效控制住</p>
<p>$$
\frac{\mathbb{E}(R)}{opt(P)}\ge 1-\frac{1}{e}
$$</p>
<h3 id="max-cut">MAX-CUT</h3>
<p>对于图$G=U\cup W,U\cap W=\emptyset$，m 条边，使得$|E(U,W)|$最大。这是$\mathcal{NP}$问题。</p>
<p>对于每个顶点取$\frac{1}{2}$分给 U、W，对于每个边，有$\frac{1}{2}$概率(uu,uw,wu,ww)在 cut 中。因此，由于期望的线性性，有</p>
<p>$$
\mathbb{E}(|E(X_u,X_w)|)=\frac{m}{2}
$$</p>
<p>而且因为$opt\le m$，因此这是一个$\frac{1}{2}$的估计。</p>
<p>注意到，$\frac{m}{2}=E(Y)=\frac{1}{2}E(Y|X_1=0)+\frac{1}{2}E(Y|X_1=1)$。由于平均数的特性，必然有一个$E(Y|X_1=0),E(Y|X_1=0)$是比原先的期望$E(Y)$更大。可以持续按照$X_1,X_2&hellip;$固定，取更大的期望，递降下去，<strong>去随机化</strong>。这样可以得到 cut 的取值。</p>
<p>具体来说，由于期望线性性，可以把给定$X_1,..X_{i-1}$取值，准备给定$X_i$的某个 0/1 取值时候的 cut 大小的期望表示为：$X_1,..X_{i}$内部的边的期望，$X_1,..X_{i}$与其他未确定点边界处的边的期望，和未确定点内部的边的期望。</p>
<p>$$
\mathbb{E}(Y|X_1,&hellip;X_i)=\mathbb{E}(X_1,&hellip;X_i)+\mathbb{E}(|X_j,unkonwn|)+\mathbb{E}(unkonwn)
$$</p>
<p>容易知道:</p>
<ol>
<li>无论$X_i$的具体取值，$\mathbb{E}(unkonwn)$都是相同的。</li>
<li>已知点和未确定点之间边界边的期望有$\mathbb{E}(|X_j,unkonwn|)=\mathbb{E}(|\{X_1,&hellip;X_{i-1}\},unknown|)+\mathbb{E}(|X_i,unkonwn|)$。
<ol>
<li>$\mathbb{E}(|\{X_1,&hellip;X_{i-1}\},unknown|)$被之前确定的点所固定，与$X_i$取值无关</li>
<li>而$\mathbb{E}(|X_i,unkonwn|)$关于$X_i$取 0/1 是对称的，因此也和$X_i$取值无关。</li>
</ol>
</li>
</ol>
<p>因此，事实上该去随机化算法，每次新加入的点，取值使得已确定的点之间能构成最大的 cut 即可。可以考虑下列一些简单的例子。</p>
<table>
<thead>
<tr>
<th>三角形</th>
<th>u</th>
<th>w</th>
<th>$\mathbb{E}$</th>
</tr>
</thead>
<tbody>
<tr>
<td>u,w</td>
<td>2</td>
<td>2</td>
<td>$\frac{2+2}{2}=2$</td>
</tr>
<tr>
<td>u,u</td>
<td>0</td>
<td>2</td>
<td>$\frac{0+2}{2}=1$</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>四边形取邻边</th>
<th>u,u</th>
<th>u,w</th>
<th>w,u</th>
<th>w,w</th>
<th>$\mathbb{E}$</th>
</tr>
</thead>
<tbody>
<tr>
<td>u,w</td>
<td>2</td>
<td>2</td>
<td>4</td>
<td>2</td>
<td>$\frac{2+2+4+2}{4}=5/2$</td>
</tr>
<tr>
<td>u,u</td>
<td>0</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>$\frac{0+2+2+2}{2}=3/2$</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>正四面体取邻边</th>
<th>u,u</th>
<th>u,w</th>
<th>w,u</th>
<th>w,w</th>
<th>$\mathbb{E}$</th>
</tr>
</thead>
<tbody>
<tr>
<td>u,w</td>
<td>3</td>
<td>4</td>
<td>4</td>
<td>3</td>
<td>$\frac{3+4+4+3}{4}=7/2$</td>
</tr>
<tr>
<td>u,u</td>
<td>0</td>
<td>3</td>
<td>3</td>
<td>4</td>
<td>$\frac{0+3+3+4}{2}=5/2$</td>
</tr>
</tbody>
</table>
<p>注意，这个提升算法因为没有回退，因此可能陷入局部最优解。考虑如下一个简单例子。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain"><span class="line"><span class="cl">  u    最优： u    次优：u
</span></span><span class="line"><span class="cl">/ | \      / | \     / | \
</span></span><span class="line"><span class="cl">1-2-3      v-u-v     u-v-u
</span></span></code></pre></td></tr></table>
</div>
</div><p>局部来看，1，2，3 这三个位置填 w，局部都是最优的多 1 条 cut 边。但是，全局最优要求 w 填在 1 或者 3 的位置（最优解里 cut 大小为 4，否则最后 cut 大小为 3）。</p>
<h2 id="birthday-paradox">Birthday Paradox</h2>
<p>$m$个球，独立随机投入到$n$个盒子。作为生日悖论的推广。还包括如 md5 的 hash 碰撞，服务器负载均衡请求等。$X_i$表示 i 个盒子中球的数目，之间同分布但不独立（和为$m$）。注意有
$x\in(0,1)\implies e^{-x}&gt;1-x$</p>
<h3 id="msqrtn">m~sqrt(n)</h3>
<p>$$
\begin{aligned}
Pr(\max X_i\ge 2)&amp;=1-Pr(\forall i,X_i\le 1)\\
&amp;=1-(1-\frac{1}{n})(1-\frac{2}{n})&hellip;(1-\frac{m-1}{n})\\
&amp;\ge 1-e^{-\frac{1}{n}}&hellip;e^{-\frac{m-1}{n}}\\
&amp;=1-e^{-\frac{m(m-1)}{2n}}\\
&amp;\ge 1-e^{-(\frac{m}{\sqrt{2n}})^2}
\end{aligned}
$$</p>
<p>因此，$m=\Theta(\sqrt{n})\approx\sqrt{2n}$时候，大概率 2 球碰撞（$Pr=1-e^{-1}$）</p>
<h3 id="mn">m~n</h3>
<p>$$m=n\implies \max X_i \sim \frac{\ln n }{\ln \ln n}$$</p>
<p>有高概率实现（with high prop，whp，概率量级为$1-o(1)$）。证明有上界下界。如果尝试次数大于 1 次，可以改善到$\Theta(\ln \ln n)$（证明未被提及）</p>
<h4 id="上界">上界</h4>
<p>$$
Pr(\max X_i\le 3\frac{\ln n }{\ln \ln n})\ge 1-o(1)
$$</p>
<p>$$
\begin{aligned}
&amp;Pr(X_1\ge 3s)\\
&amp;=Pr(\exists i_1,&hellip;i_{3s}\in [1,n],Ball_{i_j} \in X_1 )\\
&amp;=Pr(\bigcup Ball_{i_j} \in X_1 )\\
&amp;\le \sum Pr(Ball_{i_j} \in X_1)\\
&amp;=\binom{m}{3s}\left(\frac{1}{n}\right)^{3s}\\
&amp;\sim \binom{n}{3s}\left(\frac{1}{n}\right)^{3s}\\
&amp;\le \left(\frac{ne}{3s}\right)^{3s}\left(\frac{1}{n}\right)^{3s}\\
&amp;=(\frac{e}{3s})^{3s}\\
&amp;&lt;s^{-3s}\\
&amp;=(\frac{\ln  \ln n }{\ln n})^{3s}\\
&amp;&lt; (\frac{\sqrt {\ln n}}{\ln n})^{3s}\\
&amp;=e^{-\ln \ln n \cdot (\frac{3}{2}\frac{\ln n }{\ln \ln n})}\\
&amp;=n^{-3/2}
\end{aligned}
$$</p>
<p>$$
\begin{aligned}
Pr(\max X_i\ge 3\frac{\ln n }{\ln \ln n})&amp;=Pr(\exists i,X_i\ge 3\frac{\ln n }{\ln \ln n})\\
&amp;=Pr(\bigcup X_i\ge 3\frac{\ln n }{\ln \ln n})\\
&amp;\le nPr(X_1\ge 3s)\\
&amp;\le n^{\frac{1}{2}}
\end{aligned}
$$</p>
<h4 id="下界">下界</h4>
<p>$$
Pr(\max X_i\ge \frac{1}{3}\frac{\ln n }{\ln \ln n})\ge 1-o(1)
$$</p>
<p>定义同分布但不独立的随机变量$Y_1,&hellip;Y_n$ 有</p>
<p>$$
Y_i=\left\{
\begin{aligned}
&amp;1\qquad X_i\ge \frac{s}{3}\\
&amp;0\qquad otherwise
\end{aligned}
\right.
$$</p>
<p>$$
\begin{aligned}
Pr(Y_i=1)&amp;=Pr(X_i\ge \frac{s}{3})\\
&amp;\ge Pr(X_i=\frac{s}{3})\\
&amp;=\binom{m}{\frac{s}{3}}(\frac{1}{n})^{\frac{s}{3}}\cdot (1-\frac{1}{n})^{m-\frac{s}{3}}\\
&amp;\sim\binom{n}{\frac{s}{3}}(\frac{1}{n})^{\frac{s}{3}}\cdot (1-\frac{1}{n})^{n-\frac{s}{3}}\\
&amp;\ge (\frac{n}{\frac{s}{3}})^{\frac{s}{3}}(\frac{1}{n})^{\frac{s}{3}}e^{-1}\\
&amp;=(\frac{3}{s})^{\frac{s}{3}}e^{-1}\\
&amp;=(\frac{(3\ln \ln n)}{\ln n})^{\frac{s}{3}}e^{-1}\\
&amp;\ge (\ln n )^{-\frac{s}{3}}e^{-1}\qquad n&gt;4\implies 3\ln \ln n&gt;1\\
&amp;=e^{\ln \ln n\cdot \frac{\ln n}{3\ln \ln n}}e^{-1}\\
&amp;=n^{-1/3}e^{-1}
\end{aligned}
$$</p>
<p>因此有期望估计为 $E(Y_i)\ge n^{-1/3}e^{-1}$，期望和估计为$E(Y)\ge n^{2/3}e^{-1}$</p>
<p>$$
\begin{aligned}
&amp;Pr(\max X_i\ge \frac{1}{3}\frac{\ln n }{\ln \ln n})\\
&amp;=Pr(\exists Y_i=1)\\
&amp;=Pr(\sum Y_i \ge 1)\\
&amp;=1-Pr(\sum Y_i \le 0)\\
\end{aligned}
$$</p>
<p>$$
\begin{aligned}
Pr(\sum Y_i \le 0)&amp;=Pr(Y\le 0)\\
&amp;\le Pr(|Y-E(Y)|\ge E(Y))\qquad \text{注意到}E(Y)\ge 0\\
&amp;\le \frac{Var(Y)}{(n^{2/3}e^{-1})^2}\\
&amp;\le \frac{nVar(Y_i)}{(n^{2/3}e^{-1})^2}\\
&amp;\le \frac{e^2}{4}n^{-\frac{1}{3}}
\end{aligned}
$$</p>
<p>注意，这时候虽然$Y_i$之间不独立，但是其负相关（显然），协方差小于 0。和的方差等于方差的和加上负的协方差。因此还是可以使用<a href="#chebyshev-inequality">chebyshev 不等式进行放缩</a>。</p>
<h3 id="mn-1">m&gt;n</h3>
<p>期望里每个盒子的球数目为$\frac{m}{n}$。而在$m\sim n\ln n$量级上，可以保证高概率每个盒子均符合期望。</p>
<p>考虑独立随机变量$Y_1,&hellip;Y_m$，$Y_i$表示第 i 个球是否进入 1 号盒子。$E(Y_i)=\frac{1}{n},E(Y)=\frac{m}{n}$。取$m=24 n\ln n$。使用 <a href="#chernoff-bound">chernoff-bound 进行放缩</a></p>
<p>$$
\begin{aligned}
&amp;Pr(\forall X_i\in [(1-\frac{1}{2})\frac{m}{n},(1+\frac{1}{2})\frac{m}{n}])\\
&amp;=1-Pr(\exists X_i\notin [(1-\frac{1}{2})\frac{m}{n},(1+\frac{1}{2})\frac{m}{n}] )\\
&amp;\ge 1-nPr(X_1 \notin [(1-\frac{1}{2})\frac{m}{n},(1+\frac{1}{2})\frac{m}{n}])\\
&amp;=1-(Pr(X_1 \le(1-\frac{1}{2})\frac{m}{n})+Pr(X_1\ge (1+\frac{1}{2})\frac{m}{n}))\\
&amp;\ge 1- 2ne^{-\frac{(\frac{1}{2})^2}{3}\cdot\frac{m}{n}}\\
&amp;=1-2ne^{-2\ln n}\\
&amp;=1-2/n=1-o(1)
\end{aligned}
$$</p>
<h2 id="张量网络">张量网络</h2>
<h3 id="定义">定义</h3>
<p>使用$[d]$表示大小为$d$的有限集合。$\mathbb{R}^d$的向量可以视为对每一维上的离散函数$F(i):[d]\to\mathbb{R}$。$k$维张量即可以视为$F(i_1,&hellip;i_k)$</p>
<blockquote>
<p>张量网络</p>
<p>张量/离散函数作为点、自变量作为边的图。如果函数不对称，需要指定边的次序</p>
<p>图$G(V,E)$中每个点$v$赋予一个$d_v$元函数$F_v$</p>
<p>张量网络的值：$\sum_{e\in [d]} \prod_v F_v(e_{v,1},&hellip;e_{v,d_v})$，对所有边取一种赋值之后的结果求和</p>
</blockquote>
<p>eg，对于 SAT 问题，$\exists {x_1,&hellip;x_n}\to {0,1},\bigwedge c()=1 \iff \sum\prod c()\ge 1$（可以引入一些辅助节点，保证出现次数大于 2 次的边，转化成很多条连到辅助节点的边，辅助节点的函数要求所有边取值相同）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain"><span class="line"><span class="cl">F1-e-F2
</span></span></code></pre></td></tr></table>
</div>
</div><p>$e\in\{0,1\},F_1(0)=1,F_1(0)=3,F_2(0)=2,F_2(1)=5$，网络值是 $1\times 2+3\times 5=17$</p>
<p>eg，3-regular 图（顶点度数均为 3）的 3 染色问题，可以用张量网络和转变为计数问题</p>
<h3 id="引入外边成为多元函数">引入外边成为多元函数</h3>
<p>定义输入$X=\{x_1,&hellip;x_n\}\in D^n$，有</p>
<p>$$F_G(x_1,&hellip;x_n)=\sum_e\prod_v F_v(e_{v,1},&hellip;e_{v,d_v},x_i)$$</p>
<p>eg，$AB_{x_1x_2}=\sum A_{x_1e}B_{ex_2}$</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain"><span class="line"><span class="cl">x1-A-e-B-x2
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>矩阵的迹(对角线元素求和)
<ul>
<li>$trace(A)=\sum A_{ee}$(自环),$trace(ABC)=\sum A_{e_1e_2}B_{e_2e_3}C_{e_3e_1}$</li>
</ul>
</li>
<li>张量积，(克罗内克积)对于矩阵$M_{dd},N_{dd}$，结果为$d^2\times d^2$的矩阵，$M\otimes N=(m_{ij}N)$
<ul>
<li>$(M\otimes N)_{x_1x_2,x_3x_4}=M_{x_1x_3}N_{x_2x_4}$ 。结果中行标$x_1x_2$可以视为把$M$的行标$x_1$和$N$的行标$x_2$字符串组合在一起</li>
<li>可以表示为<code>x1-M-x3, x2-N-x4</code>的张量网络（没有内部边，无需求和，顶点函数就是矩阵的 index）</li>
</ul>
</li>
<li>张量网络值满足<strong>结合律</strong></li>
<li>有限域上的线性方程组解集大小，等于对应张量网络值
<ul>
<li>$\#P$问题，存在多项式时间算法</li>
<li>相同的变量用一个多元相等关系约束</li>
<li>每个方程对应一个 $\mod{}$ 顶点</li>
</ul>
</li>
<li>图的顶点覆盖数目（选定一组顶点，使得顶点的邻边包括所有的边）
<ul>
<li>$\#P-complete$问题</li>
</ul>
</li>
</ul>
<h3 id="st">s+t</h3>
<p>$s+t$的 bool 函数$F$，输入为$x_1,&hellip;x_s,y_1,&hellip;y_t$。向左边视为行标，向右边视为列标。对于$2^s\times2^t$矩阵$M_{x_1,&hellip;x_s,y_1,&hellip;y_t}=F(x_1,&hellip;x_s,y_1,&hellip;y_t)$。注意如果$s=0$（$t=0$），降级为行（列）向量。此时的张量网络函数可以视为矩阵乘法。</p>
<h3 id="全息规约">全息规约</h3>
<p>$$
AB=AEB=AMM^{-1}B=(AM)\cdot(M^{-1}B)
$$</p>
<p>一个$f,h$二分的张量网络，可以先把$f,h$之间插入一个$=_2=[1,0,1]$，然后把$=_2=MM^{-1}$，把$f,h$换一个基：$fM^{\otimes i},(M^{-1})^{\otimes j}h$</p>
<p>对于一个$F，H$二分，而且$F、H$之间每条边上都有顶点$M$的张量网络。有问题间的等价关系$\#\{FM^{\otimes i}\}|\{H\}\equiv\#\{F\}|\{M^{\otimes j}H\}$</p>
<h3 id="对称函数">对称函数</h3>
<p>对于置换$\pi$,对于自变量$\forall x_i$，有</p>
<p>$$
F(x_1,&hellip;x_n)=F(x_{\pi(1)},&hellip;x_{\pi(n)})
$$</p>
<p>如果是 bool 为自变量的对称函数，可以用$f_i$表示$i$个 1 时候$F$的值。那么$F$可以完全被$f_0,f_1,&hellip;f_{n}$来确定。对于 n 元相等关系(全相等时候取 1，否则取 0)，记$F=[1,0,&hellip;0,1]$为$=_n$</p>
<h3 id="csp-二分定理">#CSP-二分定理</h3>
<p>bool 定义域的#CSP 问题，其他形式是#P 难的问题</p>
<ul>
<li>01 值域：
<ul>
<li>仿射关系</li>
</ul>
</li>
<li>非负实数值域
<ul>
<li>pure affine</li>
<li>product type</li>
</ul>
</li>
<li>复数值域
<ul>
<li>第一易解类$\mathcal{A}$</li>
<li>第二易解类$\mathcal{P}$，作为 product 形式的推广</li>
</ul>
</li>
</ul>
<h4 id="csp-第一易解类">#CSP-第一易解类</h4>
<p>对于 bool 定义域，值域$\mathbb{C}$的函数$F$。有一个第一易解类$\mathcal{A}$，对于<a href="#holant-csp">$\#CSP(\mathcal{A})$</a>存在多项式时间算法。定义仿射关系，$\mathcal{X}_{(AX=C)}$，为$D$上$n$维的指示函数。</p>
<p>可以定义一类特殊条件的多项式$P()$：</p>
<ul>
<li>整系数多项式$P(x_1,&hellip;x_n)$，整数加法乘法运算</li>
<li>$P()$最高次数为 2，交错二次项的系数为偶数</li>
</ul>
<p>那么，$F\in \mathcal{A}$当且仅当$F$具有形式$\mathcal{X}_{(AX=C)}\cdot i^{P(x_1,&hellip;x_n)}$</p>
<p>考虑$AX=C$的自由变量有$x_1,&hellip;x_r$，其他的变量可以表示为$X^\prime=(x_1,&hellip;x_r,1)$的线性组合，$x_j=L_j(X^\prime)\mod 2$。注意到</p>
<ol>
<li>$\forall a\in\mathcal{Z},a=0,1\mod2\iff a^2=0,1\mod 4$
<ol>
<li>显然有$a\pmod2=0\iff a^2\pmod4=0$</li>
<li>$a^2 \pmod4 =1$可知$a^2,a$为奇数</li>
<li>$a=2k+1\implies a^2=(2k+1)^2=4(k^2+k)+1$,$\mod 1$的情况得证</li>
</ol>
</li>
<li>注意到对$i=\sqrt{-1}$的指数，可以在$\mod 4$的意义下计算</li>
</ol>
<p>因此我们可以把$P()$中的不自由的$x_j$（$j\in[r+1,n]$）进行<strong>合法的替换</strong></p>
<ol>
<li>一次项$x_j$替换为$L_j(X^\prime)^2$，因为在$\mod 4$下不改变</li>
<li>平方项和交错二次项正常换成$L_j(X^\prime)^2$和$2L_j(X^\prime)L_{k}(X^\prime)$</li>
</ol>
<p>此时$P(x_1,..x_r,x_{r+1},&hellip;x_n)=P(x_1,&hellip;x_r,L_{r+1}(X^\prime),&hellip;L_{n}(X^\prime))=Q(x_1,&hellip;x_r)$，容易验证新的多项式$Q()$仍然满足上述$P()$的条件。因此有</p>
<p>$$
\sum \mathcal{X}_{(AX=C)}\cdot i^{P(x_1,&hellip;x_n)}=\sum i^{Q(x_1,&hellip;x_r)}
$$</p>
<p>接下来进行逐步消除自变量。考虑$x_1$。注意到，$x_i$都是 bool 变量，因此必然有$x_i^2\equiv x_i$，我们可以把关于$x_1$的二次项$\alpha_1x_1^2$（如果存在的话）改写成$\alpha_1x_1$融合进关于$x_1$的一次项当中。</p>
<p>对$x_1$的一次项系数进行分类讨论。假设其是偶数，那么可以把$Q()$分解为$Q(x_1,&hellip;x_r)=2x_1R(x_2,&hellip;x_r)+S(x_2,&hellip;x_r)$。容易知道，当中$S()$仍然满足之前$P()$的要求，而$R(x_2,&hellip;x_r)$是一个次数为 1 的多项式</p>
<p>$$
\begin{aligned}
\sum i^{Q(x_1,&hellip;x_r)}&amp;=\sum i^{2x_1R+S}\\
&amp;=\sum_{x_2,&hellip;x_r}i^S\sum_{x_1\in{0,1}}i^{2x_1R}\\
&amp;=(1+(-1)^{R})\sum_{x_2,&hellip;x_r}i^S
\end{aligned}
$$</p>
<p>类似的，如果$x_1$的一次项系数是奇数，分解$Q(x_1,&hellip;x_r)=2x_1R(x_2,&hellip;x_r)+S(x_2,&hellip;x_r)+x_1$（注意所有的交错二次项的系数均是偶数，因此只有可能留下$x_1$单独的一次项）。此时有</p>
<p>$$
\sum i^{Q(x_1,&hellip;x_r)}=(1+(-1)^R\cdot i)\sum_{x_2,&hellip;x_r}i^S
$$</p>
<p>考虑表达式之前的常数项，（不失一般性的）有</p>
<ul>
<li>$1+(-1)^R\cdot 1$
<ul>
<li>$R=0\implies 2,R=1\implies 0$</li>
<li>可以用示性函数来表示，$2\mathcal{X}_{R=0}$</li>
</ul>
</li>
<li>$1+(-1)^R\cdot (-1)$
<ul>
<li>$R=0\implies 0,R=1\implies 2$</li>
<li>可以用示性函数来表示，$2\mathcal{X}_{R=1}$</li>
</ul>
</li>
<li>$1+(-1)^R\cdot i$
<ul>
<li>$R=0\implies (1+i),R=1\implies (1-i)$</li>
<li>注意到可以表示为$(1+i)\cdot (-i)^R$</li>
</ul>
</li>
<li>$1+(-1)^R\cdot (-i)$
<ul>
<li>$R=0\implies (1-i),R=1\implies (1+i)$</li>
<li>注意到可以表示为$(1-i)\cdot (i)^R$</li>
</ul>
</li>
</ul>
<p>由于之前的分解$R(x_2,&hellip;x_r)$是一个次数为 1 的多项式</p>
<ol>
<li>对于示性函数$\mathcal{X}_{R=0},\mathcal{X}_{R=1}$ ，可以在选出一个不自由的自变量 $x_i$ 由其他 $x_j$ 来表示，这样再次可以类似开始的消除不自由变量的递降</li>
<li>由于$S()$满足$P()$的条件，$R()$次数为 1，和二次项无关，因此$T(x_2,&hellip;x_r)=S()\pm R()$仍然满足$P()$的条件。此时$F$具有类似$\sum i^{T(x_2,&hellip;x_r)}$的形式，可以类似之前提出$x_1$的方法继续提出其他自变量</li>
</ol>
<p>显然的这个过程（高斯消元解矩阵，多项式提取公共项等）可以在多项式时间内实现，$\mathcal{A}$确为一个易解类。</p>
<blockquote>
<p>这一小结参考论文<a href="https://www.sciencedirect.com/science/article/pii/S0022000013001414">The complexity of complex weighted Boolean #CSP</a></p>
</blockquote>
<h5 id="偶数条边的子图数目算法">偶数条边的子图数目算法</h5>
<p>有函数形式</p>
<p>$$
F=\left(\begin{matrix}1&amp;1 \\ 1&amp;-1\end{matrix}\right)
$$</p>
<p>也可以认为是对于$x,y$，为$F(x,y)=i^{2xy}$。</p>
<p>对于图，点为$x_1,&hellip;x_n$，对每个边应用$F$。考虑取 1 的点构成的子图。子图有偶数条边，$-1$的偶数次幂为$+1$；奇数条边子图结果即为$-1$</p>
<p>因此问题结果为：偶数边子图数目-奇数边子图数目。已知 所有子图数目$2^{|V|}$=偶数边子图数目+奇数边子图数目。因此偶数边子图、奇数边子图数目计算为 $\mathcal{P}$ 问题</p>
<h4 id="csp-第二易解类">#CSP-第二易解类</h4>
<p>集合$\mathcal{E}$有，$F\in\mathcal{E} \iff \exists \alpha\in \{0,1\}^n,\forall X\notin \{ \alpha,\bar{\alpha} \},F(X)=0$。这个集合可以认为是 n 元相等关系的推广。</p>
<p>注意到 $\{\alpha,\bar{\alpha}\}$是一个一维仿射子空间。一个自由变量相当于约束了其他非自由变量（对于求张量网络和来说）。</p>
<p>第二易解类$\mathcal{P}$，当函数为$\mathcal{E}$的乘积。注意到，连通的$\mathcal{E}$类型的函数，还是$\mathcal{E}$类型的函数。连通分支内部取值固定，连通分支之间取乘积即可（有结合律，易知）。</p>
<p>定义二元不等关系$\neq_2$为$[0,1,0]$。可以认为集合$\mathcal{E}$是由一个推广 n 元相等$[a,0..,0,b]$，取一些边接上二元不等关系$\neq_2$生成。这也是一种 <a href="#%E6%9E%84%E4%BB%B6%E6%9B%BF%E6%8D%A2%E8%A7%84%E7%BA%A6">构件替换规约</a>。</p>
<h3 id="图同态映射数目">图同态映射数目</h3>
<p>图的同态映射，$\psi:V_G\to V_H$，有$\forall e=(a,b)\in E_G,(\psi(a),\psi(b))\in E_H$。给定一个图，求同态映射数目，相当于求一个二元函数$H$定义的$\#CSP$问题。</p>
<p>3 染色问题，可以认为是$H=\left(\begin{aligned}0,1,1\\1,0,1\\1,1,0\end{aligned}\right)$的$\#CSP(H)$问题</p>
<p>如果二元函数$H$对应的矩阵的秩小于等于 1，那么该问题为 $\mathcal{P}$问题。把分解二元函数$H=ab^{\prime}$。原来的图的每个顶点都相当于一个 n 元相等关系，只有两个赋值能满足，这样显然是易解的。</p>
<p>另一个易解类出现在如果图是二部图，有邻接矩阵$\begin{pmatrix}
0,A\\B,0
\end{pmatrix}$ ，当中的矩阵 A、B 秩都是 1。那么，如果另一图不是二部图，显然不存在同态映射；如果是二部图，考虑一部的顶点集合到另一个部的顶点集合，这时候化归到二元函数$H$对应的矩阵的秩小于等于 1 的情况。</p>
<h3 id="斐波那契门">斐波那契门</h3>
<p>对于张量网络中的对称函数，如果$f_{i+2}=f_{i+1}+f_i$,那么$[f_0,f_1,f_2,&hellip;,f_k]$被称为斐波那契门。</p>
<p>斐波那契门的张量网络求值问题$\#\{Fib\}|\{=_2\}$，有多项式时间解法</p>
<h4 id="算法一">算法一</h4>
<p>对于$\#\{Fib\}|\{=_2\}$这样的张量网络，以下两种运算封闭</p>
<ol>
<li>把两个斐波那契门函数用一条公共边/$=_2$关系连在一起，形成一个新的斐波拉契门</li>
<li>把一个斐波那契门函数的两条自由边成环在一起，新的函数还是新的斐波拉契门
<ul>
<li>容易证明$[f_0+f_2,f_1+f_3,&hellip;f_{k-2}+f_k]$这样的形式也是斐波那契门</li>
</ul>
</li>
</ol>
<p>因此上述网络重复上述两种操作，最后可以得到一个超大的斐波那契门。表示，计算斐波那契门的输入输出都是多项式时间的。因此是$\mathcal{P}$问题。</p>
<h4 id="算法二">算法二</h4>
<p>考虑$x^2=x+1$，根为$a,b$，有韦达定理$ab=-1$。注意到$a^{i+2}=a^{i+1}+a^i$。那么$[1,a,a^2,&hellip;a^n]$满足$f_{i+2}=f_{i+1}+f_i$这样的递推关系。举个简单例子</p>
<p>$$
\begin{aligned}
&amp;(1,a)^{\otimes 3}\\
&amp;=(1,a)\otimes (1,a,a,a^2)\\
&amp;=(1,a,a,a^2,a,a^2,a^2,a^3)\\
&amp;(000,001,010,011,100,101,110,111)
\end{aligned}
$$</p>
<p>因此，$(1,a)^{\otimes n},(1,b)^{\otimes n},s(1,a)^{\otimes n}+t(1,b)^{\otimes n}$都是斐波那契门。</p>
<p>反之，所有斐波那契门都能表示成$s(1,a)^{\otimes n}+t(1,b)^{\otimes n}$的形式。注意到</p>
<p>$$
\begin{pmatrix}
f_{i+1}\\f_{i+2}
\end{pmatrix}=\left(\Sigma\begin{pmatrix}
a,0\\0,b
\end{pmatrix}\Sigma^{-1}\right)^i\begin{pmatrix}
f_{i}\\f_{i+1}
\end{pmatrix}=\Sigma\begin{pmatrix}
a,0\\0,b
\end{pmatrix}^i\Sigma^{-1}\begin{pmatrix}
f_{i}\\f_{i+1}
\end{pmatrix}=T \begin{pmatrix}
a^i\\b^i
\end{pmatrix}
$$</p>
<p>而且，定义$M=\begin{pmatrix}
1,a\\1,b
\end{pmatrix}$，注意到</p>
<p>$$
\begin{aligned}
&amp;s(1,a)^{\otimes n}+t(1,b)^{\otimes n}\\
&amp;=(s,0,&hellip;0,t)\begin{pmatrix}
1,a\\1,b
\end{pmatrix}^{\otimes n}\\
&amp;=[s,0,&hellip;0,t]\begin{pmatrix}
1,a\\1,b
\end{pmatrix}^{\otimes n}=[s,0,&hellip;0,t]M^{\otimes n}
\end{aligned}
$$</p>
<p><a href="#%E5%85%A8%E6%81%AF%E8%A7%84%E7%BA%A6">使用全息规约</a>，把斐波那契门的$M^{\otimes n}$项转移到二元相等关系上去。有</p>
<p>$$
\begin{aligned}
&amp;M^{\otimes 2}\begin{pmatrix}
1\\0\\0\\1
\end{pmatrix}\\
&amp;=\begin{pmatrix}
1,a,a,a^2\\1,b,a,ab\\1,a,b,ab\\1,b,b,b^2
\end{pmatrix}\begin{pmatrix}
1\\0\\0\\1
\end{pmatrix}\\
&amp;=\begin{pmatrix}
1+a^2\\0\\0\\1+b^2
\end{pmatrix}
\end{aligned}
$$</p>
<p>注意到，$[s,0,&hellip;0,t]$和$(1+a^2,0,0,1+b^2)$都属于集合$\mathcal{E}$。这时候可以调用 <a href="#csp-%E7%AC%AC%E4%BA%8C%E6%98%93%E8%A7%A3%E7%B1%BB">#CSP 第二易解类，product 形式</a>的算法。因此可以多项式时间完成。</p>
<h3 id="奇偶和相等关系转换">奇偶和相等关系转换</h3>
<p>对于$H=\begin{pmatrix}
1,1\\1,-1
\end{pmatrix}$，有如下</p>
<p>$$
\begin{aligned}
&amp;[1,0,0,1]H^{\otimes 3}\\
&amp;=((1,0)^{\otimes 3}+(0,1)^{\otimes 3})H^{\otimes 3}\\
&amp;=(1,1)^{\otimes 3}+(1,-1)^{\otimes 3}\\
&amp;=[1,1,1,1]+[1,-1,1,-1]\\
&amp;=[2,0,2,0]=2[1,0,1,0]
\end{aligned}
$$</p>
<p>又有</p>
<p>$$
\begin{aligned}
&amp;[2,0,2,0]H^{\otimes 3}\\
&amp;=((1,1)^{\otimes 3}+(1,-1)^{\otimes 3})H^{\otimes 3}\\
&amp;=(2,0)^{\otimes 3}+(0,2)^{\otimes 3}\\
&amp;=[2,0,0,0]+[0,0,0,2]\\
&amp;=[2,0,0,2]=2[1,0,0,1]
\end{aligned}
$$</p>
<h3 id="函数线性性质线性检测">函数线性性质线性检测</h3>
<p>对于$X,Y\in{0,1}^n$，对于一个线性函数$G:{0,1}^n\to{0,1}$.有$G(X+Y)\equiv G(X)+G(Y) \mod 2$。当中有形式$G=\sum a_ix_i,a_i\in{0,1}$</p>
<p>现在给出函数$G$，需要判断是否线性。则需要判断$G(X+Y)+G(X)+G(Y) \equiv0\mod 2$。如果不满足则不是线性函数。考虑变换$Z=X+Y$, 原有的判断条件可以改写为$(-1)^{G(X)}(-1)^{G(Y)}(-1)^{G(Z)}=1$。这时候，可以把 $(\text{通过概率}(1-p)-\text{拒绝概率}(p))$用张量网络求值表达出来。进行全息变换。$\oplus_3$替换为$=_3$ ,$(-1)^G$替换为$\hat{G}$</p>
<p>$$
\begin{aligned}
1-2p&amp;=\sum\left((-1)^{G(X)}(-1)^{G(Y)}(-1)^{G(Z)}\prod \oplus_3(X_i,Y_i,Z_i)\right)\\
&amp;=\sum \hat{G}(S)\hat{G}(U)\hat{G}(V)\prod =_3(S,U,V)\\
&amp;=\sum \hat{G}^3(S) \\
&amp;\le\sum (\max \hat{G}(S))\hat{G}^2(S)=\max \hat{G}(S)
\end{aligned}
$$</p>
<p>$\hat{G}$可以认为是$G$函数和对应选择的线性函数$\chi_s$的值相同的概率$1-\rho$减去值不同的概率$\rho$</p>
<p>注意到，bool 函数$G$和$\pm1$函数 $F:{1,-1}^n\to{1,-1}$之间是等价的，当中$F(X)=\prod_{j\in s}x_j$（注意这里把原先的$G$的 0 替换为$F$的 1，$G$的 1 替换为$F$的-1，$G$的奇数次的 1 有结果 1 对应$F$奇数次的-1 有结果-1）</p>
<p>考虑 Hadmard 的满秩矩阵，$H=\begin{pmatrix}
1,1\\  1,-1
\end{pmatrix}$，$H^{\otimes n}$对应着关于不同的$x_j,j\in s$的$s$选取的真值表的基$\boldsymbol{\chi}_s,s\subseteq [n]$。以$n=2$为例</p>
<p>$$
\begin{aligned}
H^{\otimes 2}=\begin{pmatrix}
1,1,1,1\\1,-1,1,-1\\1,1,-1,-1\\1,-1,-1,1
\end{pmatrix}\qquad\begin{matrix}
00\\01\\10\\11
\end{matrix}
\end{aligned}
$$</p>
<p>右边表示是否选取$x_0,x_1$。例如，$10$代表选择$x_0$，此时的线性函数为$\chi_{10}=x_0$。真值对应如下面的树状关系</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-plaintext" data-lang="plaintext"><span class="line"><span class="cl">  x0=1        x0=-1
</span></span><span class="line"><span class="cl">x1=1 x1=-1  x1=1 x1=-1
</span></span><span class="line"><span class="cl"> 1     1     -1    -1
</span></span></code></pre></td></tr></table>
</div>
</div><p>考虑一个 bool 函数按照上述转化而来的 $\pm 1$函数$F$的结果向量和某个$\chi_s$的内积$&lt;F,\chi_s&gt;$。由内积的定义，如果某位其相同，乘积为 1，反之为-1。那么内积的结果就是$F$和$\chi_s$之间相同点-不同点的数目。</p>
<p>这时候就可以定义相对距离$\rho$，不同的点数除以总点数。而值相同的概率减去值不同的概率一样表示为$1-2\rho$。因此，这是一个单边出错算法，拒绝概率$p\ge \rho$</p>
<h3 id="容斥原理">容斥原理</h3>
<p>$$
|\bigcap \bar{A}_i|=|S-\bigcup A_i|=|S|-\sum|A_i|+\sum|A_i\cap A_j|&hellip;+(-1)^n|A_1\cap&hellip;A_n|
$$</p>
<p>定义$A_i(0)=\bar{A}_i,A_i(1)=A_i$，自变量$X\in{0,1}^n$，定义</p>
<p>$$
F(X)\triangleq |\bigcap A_i(x_i)|
$$</p>
<p>定义 $A_i^*(0)=S,A_i^*(1)=A_i$ ，自变量 $X\in{0,1}^n$，定义</p>
<p>$$
H(X)\triangleq |\bigcap A_i^*(x_i)|
$$</p>
<p>$$
\begin{aligned}
H(01&hellip;1)= &amp; |S\cap\bigcap_2 A_i^*(x_i)| \\
&amp;=|A_1 \cap\bigcap_{2} A^{*}_{i}(x_i) |+|\bar{A}_1\cap\bigcap_2 A_i^{*}(x_i)| \\
&amp;=F(01&hellip;1)+F(11&hellip;1) \\
&amp;=(0,&hellip;0,1,0,&hellip;,0,1)\cdot\begin{pmatrix}
F(0&hellip;0)\\
&hellip;\\
F(1&hellip;1)
\end{pmatrix}\\
&amp;=&lt;(1,1)\otimes (0,1)^{\otimes n-1},\mathbf{F}&gt;
\end{aligned}
$$</p>
<p>所以可以有（slide 上实际没有证明）</p>
<p>$$
\mathbf{H}=\begin{pmatrix}
1,1\\0,1
\end{pmatrix}^{\otimes n} \mathbf{F},\begin{pmatrix}
1,-1\\0,1
\end{pmatrix}^{\otimes n}\mathbf{H}=\mathbf{F}
$$</p>
<p>那么就有，$F(0&hellip;0)=(1,-1)^{\otimes n}\mathbf{H}$。展开就能得到容斥原理的表达式。</p>
<h2 id="附录-基础知识">附录-基础知识</h2>
<h3 id="markov-inequality">Markov-Inequality</h3>
<p>$$
\begin{aligned}
&amp;X\ge0,\forall c\ge0\\
&amp;\implies Pr(X\ge c)\le\frac{E(X)}{c}
\end{aligned}
$$</p>
<p>证明是显然的</p>
<h3 id="chebyshev-inequality">Chebyshev-Inequality</h3>
<p>$$
\begin{aligned}
&amp;X,\forall c\ge 0\\
&amp;\implies Pr(|X-E(x)|\ge c)\le\frac{Var(X)}{c^2}
\end{aligned}
$$</p>
<p>注意到$Pr(|X-E(x)|\ge c)=Pr((X-E(x))^2\ge c^2)$，然后化归到 <a href="#markov-inequality">Markov 不等式</a>Chebyshev 不等式适用以下场景：</p>
<ol>
<li>变量之间独立，方差等于各自方差和</li>
<li>变量之间负相关，可以放缩方差和</li>
<li>变量之间两两独立，但不独立（eg，2 个独立 01 变量，再一个为前两个的异或），协方差均为 0，方差等于各自方差和</li>
</ol>
<h4 id="抽样调查准确率">抽样调查准确率</h4>
<p>作为 <a href="#chebyshev-inequality">Chebyshev 不等式</a>的应用。 抽样 n 个，调查出来的概率$\hat{p}=\frac{X_1+&hellip;X_n}{n}=\frac{X}{n}$。对其和真实概率$p=\frac{|T|}{|U|}$的偏移有要求：</p>
<p>$$Pr(|\hat{p}-p|\le \Delta)\ge 1-\epsilon \implies Pr(|\hat{p}-p|\ge \Delta)\le \epsilon $$</p>
<p>$$
\begin{aligned}
&amp;Pr(|\hat{p}-p|\ge \Delta)\\
&amp;=Pr(|\frac{X}{n}-p|\ge \Delta)\\
&amp;=Pr(|X-np|\ge n\Delta)\\
&amp;\le\frac{Var(X)}{(n\Delta)^2}\\
&amp;\le\frac{1}{4n\Delta^2}
\end{aligned}
$$</p>
<p>要求的抽样$n$的取值只和要求的$\Delta,\epsilon$有关（$n\ge\frac{1}{4\epsilon\Delta^2}$），和真实概率$p$本身分布无关。但是，如果知道真实分布，可以改善$n$的取值。</p>
<p>如果使用 <a href="#chernoff-bound">chernoff bound 去估计</a>，可以指定相对误差$\delta\in(0,1)$。如果有如下的要求</p>
<p>$$Pr(\hat{p}\in[(1-\delta)p,(1+\delta)p])\ge 1-\epsilon$$</p>
<p>则有</p>
<p>$$
\begin{aligned}
&amp;Pr(|\hat{p}-p|\ge\delta )\\
&amp;=Pr(|\frac{X_1+&hellip;X_n}{n}-p|\ge\delta)\\
&amp;\le 2e^{-\frac{\delta^2}{3}n\mu}
\end{aligned}
$$</p>
<p>推出要求数目为$n\ge \frac{3(\ln 2-\ln\epsilon)}{\delta^2 p}$。改进为对错误率的对数形式。但是此时对$n$的要求和原始分布$p$有关。</p>
<h3 id="组合数不等式">组合数不等式</h3>
<p>$$
(\frac{n}{m})^m\le\binom{n}{m}\le(\frac{ne}{m})^m
$$</p>
<p>第一个小于等于证明：</p>
<p>$$
\begin{aligned}
\binom{n}{m}&amp;=\frac{n!}{m!(n-m)!}\\
&amp;=\frac{(n)..(n-m+1)}{(m)&hellip;(1)}\\
&amp;=\frac{n}{m}\frac{n-1}{m-1}&hellip;\frac{n-m+1}{1}\\
&amp;\ge (\frac{n}{m})^m
\end{aligned}
$$</p>
<p>注意到$\frac{(\frac{n+2}{n+1})^n}{n+1}(n+2)=(1+\frac{1}{n+1})^{n+1}\le e$。进行数学归纳法，有$\frac{(n+1)^n}{n!}\le e^n$。第二个小于等于证明：</p>
<p>$$
\begin{aligned}
\binom{n}{m}&amp;=\frac{n!}{m!(n-m)!}\\
&amp;=\frac{(n)&hellip;(n-m+1)}{m!}\\
&amp;\le e^m\frac{(n)&hellip;(n-m+1)}{(m+1)^m}\\
&amp;\le (\frac{ne}{m})^m
\end{aligned}
$$</p>
<h3 id="chernoff-bound">Chernoff-Bound</h3>
<p>$X_1,X_2,&hellip;X_n$为 n 个 <strong>01</strong>（如果不是，需要正规化 normalize ） 的<strong>独立</strong>随机变量，$Pr(X_i=1)=p_i$，考虑随机变量和$X=\sum X_i$，均值$E(X)=\mu=\sum p_i$。对于一个偏离$\forall \delta\in (0,1)$（正向偏差时候大于 1 也可以，主要是负向概率不能为负。而最后的 exp 形式放缩需要$\delta\in(0,1)$）。</p>
<p>$$
Pr(X\ge \mu(1+\delta))\le [\frac{e^\delta}{(1+\delta)^{1+\delta}}]^\mu\le e^{-\frac{\delta^2}{3}\mu}
$$</p>
<p>$$
Pr(X\le \mu(1-\delta))\le [\frac{e^{-\delta}}{(1-\delta)^{1-\delta}}]^\mu\le e^{-\frac{\delta^2}{2}\mu}
$$</p>
<p>放缩成双向的</p>
<p>$$
Pr(|X-\mu|\ge \delta\mu)\le 2e^{-\frac{\delta^2}{3}\mu}
$$</p>
<p>eg：抛硬币 1000 次，800+次正面，$e^{-\frac{(3/5)^2}{3}\cdot \frac{n}{2}}$，指数小的概率，对比 <a href="#chebyshev-inequality">Chebyshev 里面只能 1/n 级别</a></p>
<h4 id="正向的证明">正向的证明</h4>
<p>$$
\begin{aligned}
&amp;Pr(X\ge(1+\delta)\mu)\\
&amp;=Pr(e^{\lambda X}\ge e^{\lambda(1+\delta)\mu})\qquad \lambda&gt;0\\
&amp;\le \frac{E(e^{\lambda X})}{e^{\lambda(1+\delta)\mu}}\\
&amp;=\frac{\prod E(e^{\lambda X_i})}{e^{\lambda(1+\delta)\mu}}\\
&amp;=\frac{\prod ((1-p_i)+p_ie^{\lambda})}{e^{\lambda(1+\delta)\mu}}\\
&amp;=\frac{\prod (1+p_i(e^{\lambda}-1))}{e^{\lambda(1+\delta)\mu}}\\
&amp;\le \frac{\prod e^{p_i(e^{\lambda}-1)}}{e^{\lambda(1+\delta)\mu}}\\
&amp;=\frac{e^{(e^{\lambda}-1)\mu}}{e^{\lambda(1+\delta)\mu}}\\
&amp;=e^{(e^\lambda-1-\lambda(1+\delta))\mu}\qquad \lambda=\ln(1+\delta)&gt;0\\
&amp;=e^{(1+\delta-1-(1+\delta)\ln (1+\delta))\mu}\\
&amp;=[\frac{e^\delta}{(1+\delta)^{1+\delta}}]^\mu
\end{aligned}
$$</p>
<p>在 $\delta\in(0,1)$时候，可以改写$e^{(1+\delta-1-(1+\delta)\ln (1+\delta))\mu}$，得出上界估计$e^{-\frac{\delta^2}{3}\mu}$</p>
<p>$$
\begin{aligned}
&amp;\delta -(1+\delta)\ln (1+\delta)\\
&amp;=\delta-(1+\delta)(\delta-\frac{\delta^2}{2}+\frac{\delta^3}{3}&hellip;)\\
&amp;=(\frac{\delta^2}{2}-\frac{\delta^3}{3}&hellip;)-(\delta^2-\frac{\delta^3}{2}+\frac{\delta^3}{3}&hellip;)\\
&amp;=-\frac{\delta^2}{2}+\frac{\delta^3}{6}&hellip;\\
&amp;\le -\frac{\delta^2}{2}+\frac{\delta^2}{6}=-\frac{\delta^2}{3}
\end{aligned}
$$</p>
<h4 id="负向的证明">负向的证明</h4>
<p>类似的，</p>
<p>$$
\begin{aligned}
&amp;Pr(X\le(1-\delta)\mu)\\
&amp;=Pr(e^{\lambda X}\ge e^{\lambda(1-\delta)\mu})\qquad \lambda&lt;0\\
&amp;\le \frac{E(e^{\lambda X})}{e^{\lambda(1-\delta)\mu}}\\
&amp;=\frac{\prod E(e^{\lambda X_i})}{e^{\lambda(1-\delta)\mu}}\\
&amp;=\frac{\prod ((1-p_i)+p_ie^{\lambda})}{e^{\lambda(1-\delta)\mu}}\\
&amp;=\frac{\prod (1+p_i(e^{\lambda}-1))}{e^{\lambda(1-\delta)\mu}}\\
&amp;\le \frac{\prod e^{p_i(e^{\lambda}-1)}}{e^{\lambda(1-\delta)\mu}}\\
&amp;=\frac{e^{(e^{\lambda}-1)\mu}}{e^{\lambda(1-\delta)\mu}}\\
&amp;=e^{(e^\lambda-1-\lambda(1-\delta))\mu}\qquad \lambda=\ln(1-\delta)&lt;0\\
&amp;=e^{(1-\delta-1-(1-\delta)\ln (1-\delta))\mu}\\
&amp;=[\frac{e^{-\delta}}{(1-\delta)^{1-\delta}}]^\mu\\
\end{aligned}
$$</p>
<p>在 $\delta\in(0,1)$时候，可以改写$e^{(1-\delta-1-(1-\delta)\ln (1-\delta))\mu}$，得出上界估计$e^{-\frac{\delta^2}{2}\mu}$</p>
<p>$$
\begin{aligned}
&amp;-\delta -(1-\delta)\ln (1-\delta)\\
&amp;=-\delta+(1-\delta)(\delta+\frac{\delta^2}{2}+\frac{\delta^3}{3}&hellip;)\\
&amp;=(\frac{\delta^2}{2}+\frac{\delta^3}{3}&hellip;)-(\delta^2+\frac{\delta^3}{2}+\frac{\delta^4}{3}&hellip;)\\
&amp;\le -\frac{\delta^2}{2}
\end{aligned}
$$</p>
<h3 id="fermat-little-theorem">Fermat-Little-Theorem</h3>
<p>$$p\in prime\implies \forall a,a^p\equiv a\pmod p$$</p>
<p>$$(a,p)=1\implies a^{p-1}\equiv 1\pmod{p}$$</p>
<p>注意集合${1,2,&hellip;(p-1)}$和集合 ${1\times a,2\times a ,&hellip;(p-1)\times a}$在$\mod p$意义上相等。因此有</p>
<p>$(p-1)!\equiv a^{p-1}(p-1)!\pmod p\implies a^{p-1}\equiv 1\pmod{p}$</p>
<h4 id="carmichael-number">Carmichael-Number</h4>
<p>是合数，但是能够保证通过 <a href="#fermat-little-theorem">费马小定理的检测</a>。</p>
<p>$N=561=3\times 11 \times 17,\forall a,(a,N)=1\implies a^{560}\equiv 1\pmod{561}$</p>
<p>可以使用 <a href="#%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86">中国剩余定理</a>证明 561 满足性质要求。</p>
<p>$$
\left\{
\begin{aligned}
&amp;a^{560}=(a^{2})^{280}=1^{280}\equiv 1\pmod{3}\\
&amp;a^{560}=(a^{10})^{56}=1^{56}\equiv 1\pmod{11}\\
&amp;a^{560}=(a^{16})^{35}=1^{35}\equiv 1\pmod{17}
\end{aligned}
\right.
$$</p>
<p>有无数个 Carmichael Number，而且对于足够大的一个 m，$(m,2m)$之间一定有一个 Carmichael Number（论文证明）。</p>
<h4 id="中国剩余定理">中国剩余定理</h4>
<blockquote>
<p>今有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二，问物几何？</p>
</blockquote>
<p>$$
\left\{
\begin{aligned}
&amp;x=2\pmod 3\\
&amp;x=3\pmod 5\\
&amp;x=2\pmod 7
\end{aligned}
\right.
$$</p>
<p>$$
\begin{aligned}
x=2\times &amp;70+3\times &amp;21+2\times &amp;15\\
(1,&amp;0,0) &amp;(0,1,0) (0,&amp;0,1)
\end{aligned}
$$</p>
<p>可以认为是用不同的余数的基底组合而成。可以推广为以下同余方程组，保证有解</p>
<p>$$
\left\{
\begin{aligned}
&amp;x=n_1\pmod {m_1}\\
&amp;x=n_2\pmod {m_2}\\
&amp;&hellip;\\
&amp;x=n_k\pmod {m_k}
\end{aligned}
\right.
$$</p>
<p>解为</p>
<p>$$x\equiv \sum n_i\times M_i\pmod{\prod m_i}$$</p>
<p>当中</p>
<p>$$
\left\{
\begin{aligned}
&amp;M_i\equiv 0\pmod{\frac{\prod m_k}{m_i}}\\
&amp;M_i\equiv 1\pmod{m_i}
\end{aligned}
\right.
$$</p>
<p>有 Bezout 定理，$GCD(x,y)=1\iff \exists r,s,rx+sy=1$。因此可以表达为$M_i=r(\frac{\prod m_k}{m_i})=1-sm_i$。$r,s$通过<a href="#gcd">辗转相除法的中间系数计算</a></p>
<h3 id="schwartz-zippel-lemma">Schwartz-Zippel-Lemma</h3>
<p>对于数域$\mathbb{F}$，多项式$0\not\equiv P(y_1,&hellip;y_n)\in\mathbb{F}[y1,&hellip;y_n]$。独立随机在有限集$S$中取$r_1,&hellip;r_n\in S\subseteq \mathbb{F}$，有</p>
<p>$$
Pr(P(r1,&hellip;r_n)=0)\le\frac{\deg(p)}{|S|}
$$</p>
<p>注意，对于多元多项式，每项的次数等于元的次数和，整个多项式的$\deg$为每项中的最大值。</p>
<p>数学归纳法证明，$n=1$时候，由代数基本定理容易知道,最多$\deg(P)$个根，不一定根全在$S$当中。假设$n=k$成立，对于$n=k+1$时候，分离出一个变元，如$y_1$，把$y_1$次数最高的项（设大小为 d）提出，</p>
<p>$$P(y1,&hellip;y_{k+1})=y_1^d\cdot Q(y_2,&hellip;y_{k+1})+R(y_1,&hellip;y_{k+1})$$</p>
<p>此时有$\deg(Q)\le \deg(P)-d,\deg(R)\le \deg(P)$</p>
<p>$$
\begin{aligned}
&amp;Pr(P(r_1,&hellip;r_{k+1})=0)\\
&amp;=Pr(P=0,Q(r_1,&hellip;r_{k+1})=0)+Pr(P=0,Q\neq0)\\
&amp;\le Pr(Q=0)+P(P=0,Q\neq 0)\\
&amp;\le \frac{\deg(Q)}{|S|}+P(P=0,Q\neq 0)\\
&amp;\le \frac{\deg(P)-d}{|S|}+P(P=0,Q\neq 0)\\
&amp;\le \frac{\deg(P)-d}{|S|}+\frac{d}{|S|}\qquad\text{关于$y_1$的d次多项式的情况}\\
&amp;=\frac{\deg(P)}{|S|}
\end{aligned}
$$</p>
]]></content:encoded></item></channel></rss>