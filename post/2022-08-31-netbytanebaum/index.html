<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>笔记：Computer Network by Tanenbaum(大概第6章) | zhh's blog</title><meta name=keywords content="教程,读书笔记"><meta name=description content="Computer Network by Tanenbaum ch1 term 分层 ch2 物理层 信道容量 介质 调制 ch3 数据链路层 frame 检错纠错 hamming protocol 乌托邦式的单工协议 简单的 停-等 协议，无错信道 简单的 停-等 协议，信道可能出错"><meta name=author content="livypad"><link rel=canonical href=https://livypad.github.io/post/2022-08-31-netbytanebaum/><link crossorigin=anonymous href=/assets/css/stylesheet.min.7ca4c3dd9394a71fbe69a066b9fbc3dcfe7fb50ce978b051497ffe24c8e1c49a.css integrity="sha256-fKTD3ZOUpx++aaBmufvD3P5/tQzpeLBRSX/+JMjhxJo=" rel="preload stylesheet" as=style><link rel=icon href=https://livypad.github.io/assets/icon/favicon.ico><link rel=apple-touch-icon href=https://livypad.github.io/assets/icon/apple-touch-icon.png><link rel=manifest href=https://livypad.github.io/assets/icon/site.webmanifest><meta name=twitter:title content="笔记：Computer Network by Tanenbaum(大概第6章) | zhh's blog"><meta name=twitter:description content="Computer Network by Tanenbaum ch1 term 分层 ch2 物理层 信道容量 介质 调制 ch3 数据链路层 frame 检错纠错 hamming protocol 乌托邦式的单工协议 简单的 停-等 协议，无错信道 简单的 停-等 协议，信道可能出错"><meta name=twitter:site content="@novoreorx"><meta name=twitter:creator content="@novoreorx"><meta property="og:title" content><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary-bg:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript></head><body id=top><script data-no-instant>function switchTheme(e){switch(e){case"light":document.body.classList.remove("dark");break;case"dark":document.body.classList.add("dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")}}function isDarkTheme(){return document.body.className.includes("dark")}function getPrefTheme(){return localStorage.getItem("pref-theme")}function setPrefTheme(e){switchTheme(e),localStorage.setItem("pref-theme",e)}const toggleThemeCallbacks={};toggleThemeCallbacks.main=e=>{setPrefTheme(e?"light":"dark")},window.addEventListener("toggle-theme",function(){const e=isDarkTheme();for(const t in toggleThemeCallbacks)toggleThemeCallbacks[t](e)});function toggleThemeListener(){window.dispatchEvent(new CustomEvent("toggle-theme"))}</script><script>(function(){const t="auto",e=getPrefTheme(),n=e||t;switchTheme(n)})()</script><header class=header><nav class=nav><div class=logo><a href=https://livypad.github.io accesskey=h title="zhh's blog (Alt + H)">zhh's blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://livypad.github.io/about/ title=About>About</a></li><li><a href=https://livypad.github.io/tags/ title=Tags>Tags</a></li><li><a href=https://livypad.github.io/archives/ title=Archive>Archive</a></li><li><a href=https://livypad.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/ title=Note>Note</a></li></ul></nav></header><main class="main post"><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://livypad.github.io>Home</a>&nbsp;»&nbsp;<a href=https://livypad.github.io/post/>Posts</a></div><h1 class=post-title>笔记：Computer Network by Tanenbaum(大概第6章)</h1><div class=post-meta><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>2022-08-31</span></span><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<a href=https://livypad.github.io/tags/%E6%95%99%E7%A8%8B/>教程 </a><a href=https://livypad.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/>读书笔记</a>
</span><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select:text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z" style="user-select:text"/><polyline points="14 2 14 8 20 8" style="user-select:text"/><line x1="16" y1="13" x2="8" y2="13" style="user-select:text"/><line x1="16" y1="17" x2="8" y2="17" style="user-select:text"/><polyline points="10 9 9 9 8 9" style="user-select:text"/></svg><span>9624 words</span></span><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>20 min</span></span></div></header><div class="toc side left"><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#computer-network-by-tanenbaum aria-label="Computer Network by Tanenbaum">Computer Network by Tanenbaum</a><ul><li><a href=#ch1 aria-label=ch1>ch1</a><ul><li><a href=#term aria-label=term>term</a></li><li><a href=#%e5%88%86%e5%b1%82 aria-label=分层>分层</a></li></ul></li><li><a href=#ch2-%e7%89%a9%e7%90%86%e5%b1%82 aria-label="ch2 物理层">ch2 物理层</a><ul><li><a href=#%e4%bf%a1%e9%81%93%e5%ae%b9%e9%87%8f aria-label=信道容量>信道容量</a></li><li><a href=#%e4%bb%8b%e8%b4%a8 aria-label=介质>介质</a></li><li><a href=#%e8%b0%83%e5%88%b6 aria-label=调制>调制</a></li></ul></li><li><a href=#ch3-%e6%95%b0%e6%8d%ae%e9%93%be%e8%b7%af%e5%b1%82 aria-label="ch3 数据链路层">ch3 数据链路层</a><ul><li><a href=#frame aria-label=frame>frame</a></li><li><a href=#%e6%a3%80%e9%94%99%e7%ba%a0%e9%94%99 aria-label=检错纠错>检错纠错</a><ul><li><a href=#hamming aria-label=hamming>hamming</a></li></ul></li><li><a href=#protocol aria-label=protocol>protocol</a><ul><li><a href=#%e4%b9%8c%e6%89%98%e9%82%a6%e5%bc%8f%e7%9a%84%e5%8d%95%e5%b7%a5%e5%8d%8f%e8%ae%ae aria-label=乌托邦式的单工协议>乌托邦式的单工协议</a></li><li><a href=#%e7%ae%80%e5%8d%95%e7%9a%84-%e5%81%9c-%e7%ad%89-%e5%8d%8f%e8%ae%ae%e6%97%a0%e9%94%99%e4%bf%a1%e9%81%93 aria-label="简单的 停-等 协议，无错信道">简单的 停-等 协议，无错信道</a></li><li><a href=#%e7%ae%80%e5%8d%95%e7%9a%84-%e5%81%9c-%e7%ad%89-%e5%8d%8f%e8%ae%ae%e4%bf%a1%e9%81%93%e5%8f%af%e8%83%bd%e5%87%ba%e9%94%99 aria-label="简单的 停-等 协议，信道可能出错">简单的 停-等 协议，信道可能出错</a></li><li><a href=#%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3%e5%8d%8f%e8%ae%ae aria-label=滑动窗口协议>滑动窗口协议</a><ul><li><a href=#1-%e4%bd%8d-%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3 aria-label="1 位 滑动窗口">1 位 滑动窗口</a></li><li><a href=#%e5%a4%9a%e4%bd%8d%e7%aa%97%e5%8f%a3 aria-label=多位窗口>多位窗口</a></li><li><a href=#go-back-n-%e5%9b%9e%e9%80%80-n-%e5%8d%8f%e8%ae%ae aria-label="Go-Back-N 回退 N 协议">Go-Back-N 回退 N 协议</a></li><li><a href=#selective-repeat-%e9%80%89%e6%8b%a9%e9%87%8d%e4%bc%a0 aria-label="selective repeat 选择重传">selective repeat 选择重传</a></li></ul></li></ul></li></ul></li><li><a href=#ch4-%e4%bb%8b%e8%b4%a8%e8%ae%bf%e9%97%ae%e6%8e%a7%e5%88%b6%e5%ad%90%e5%b1%82 aria-label="ch4 介质访问控制子层">ch4 介质访问控制子层</a><ul><li><a href=#%e5%a4%9a%e8%b7%af%e8%ae%bf%e9%97%ae%e5%8d%8f%e8%ae%ae aria-label=多路访问协议>多路访问协议</a><ul><li><a href=#aloha aria-label=ALOHA>ALOHA</a></li><li><a href=#%e5%88%86%e6%a7%bd-aloha aria-label="分槽 ALOHA">分槽 ALOHA</a></li><li><a href=#csma aria-label=CSMA>CSMA</a><ul><li><a href=#persistent%e7%ad%89%e5%88%b0%e5%8d%a0%e7%94%a8%e7%bb%93%e6%9d%9f%e7%9b%b4%e6%8e%a5%e5%bc%80%e5%a7%8b%e5%8f%91 aria-label=Persistent：等到占用结束直接开始发>Persistent：等到占用结束直接开始发</a></li><li><a href=#nonpersistent aria-label=Nonpersistent>Nonpersistent</a></li><li><a href=#p-persistent aria-label=p-persistent>p-persistent</a></li></ul></li><li><a href=#csmacd-collision-detection aria-label="CSMA/CD collision detection">CSMA/CD collision detection</a></li><li><a href=#csmaca-collision-avoidance aria-label="CSMA/CA collision avoidance">CSMA/CA collision avoidance</a></li><li><a href=#bit-map-%e4%bd%8d%e5%9b%be%e5%8d%8f%e8%ae%ae-%e6%97%a0%e5%86%b2%e7%aa%81 aria-label="Bit-Map 位图协议 无冲突">Bit-Map 位图协议 无冲突</a></li><li><a href=#token-ring-%e4%bb%a4%e7%89%8c%e7%8e%af-%e6%97%a0%e5%86%b2%e7%aa%81 aria-label="token ring 令牌环 无冲突">token ring 令牌环 无冲突</a></li><li><a href=#binary-countdown-%e4%ba%8c%e8%bf%9b%e5%88%b6%e8%ae%a1%e6%95%b0-%e6%97%a0%e5%86%b2%e7%aa%81 aria-label="binary countdown 二进制计数 无冲突">binary countdown 二进制计数 无冲突</a></li><li><a href=#the-adaptive-tree-walk-protocol-%e8%87%aa%e9%80%82%e5%ba%94%e6%a0%91%e9%81%8d%e5%8e%86%e5%8d%8f%e8%ae%ae aria-label="The Adaptive Tree Walk Protocol 自适应树遍历协议">The Adaptive Tree Walk Protocol 自适应树遍历协议</a></li></ul></li><li><a href=#%e4%bb%a5%e5%a4%aa%e7%bd%91 aria-label=以太网>以太网</a><ul><li><a href=#%e8%ae%be%e6%96%bd aria-label=设施>设施</a></li></ul></li></ul></li><li><a href=#ch5-%e7%bd%91%e7%bb%9c%e5%b1%82 aria-label="ch5 网络层">ch5 网络层</a><ul><li><a href=#%e8%b7%af%e7%94%b1%e7%ae%97%e6%b3%95 aria-label=路由算法>路由算法</a><ul><li><a href=#dijstra-%e6%9c%80%e7%9f%ad%e8%b7%af%e5%be%84 aria-label="Dijstra 最短路径">Dijstra 最短路径</a></li><li><a href=#flooding-%e6%b3%9b%e6%b4%aa aria-label="flooding 泛洪">flooding 泛洪</a></li><li><a href=#distance-vector-routing-%e8%b7%9d%e7%a6%bb%e5%90%91%e9%87%8f%e8%b7%af%e7%94%b1 aria-label="distance vector routing 距离向量路由">distance vector routing 距离向量路由</a></li><li><a href=#link-state-routing-%e9%93%be%e8%b7%af%e7%8a%b6%e6%80%81%e8%b7%af%e7%94%b1 aria-label="link state routing 链路状态路由">link state routing 链路状态路由</a></li><li><a href=#%e5%b1%82%e6%ac%a1%e8%b7%af%e7%94%b1 aria-label=层次路由>层次路由</a></li><li><a href=#%e5%b9%bf%e6%92%ad%e8%b7%af%e7%94%b1 aria-label=广播路由>广播路由</a></li></ul></li><li><a href=#%e7%bb%84%e6%92%ad%e8%b7%af%e7%94%b1 aria-label=组播路由>组播路由</a><ul><li><a href=#anycast-routing-%e9%80%89%e6%92%ad%e8%b7%af%e7%94%b1 aria-label="anycast routing 选播路由">anycast routing 选播路由</a></li></ul></li><li><a href=#%e6%8b%a5%e5%a1%9e%e6%8e%a7%e5%88%b6%e7%ae%97%e6%b3%95 aria-label=拥塞控制算法>拥塞控制算法</a><ul><li><a href=#traffic-aware-routing aria-label="Traffic-Aware Routing">Traffic-Aware Routing</a></li><li><a href=#admission-control aria-label="admission control">admission control</a></li><li><a href=#load-shedding aria-label="load shedding">load shedding</a></li><li><a href=#traffic-shaping aria-label="traffic shaping">traffic shaping</a></li><li><a href=#active-queue-management-%e4%b8%bb%e5%8a%a8%e9%98%9f%e5%88%97%e7%ae%a1%e7%90%86 aria-label="active queue management 主动队列管理">active queue management 主动队列管理</a></li><li><a href=#random-early-detection-%e9%9a%8f%e6%9c%ba%e6%97%a9%e6%9c%9f%e6%a3%80%e6%b5%8b aria-label="Random Early Detection 随机早期检测">Random Early Detection 随机早期检测</a></li><li><a href=#choke-packets aria-label="choke packets">choke packets</a></li><li><a href=#explicit-congestion-notification-%e6%98%be%e5%bc%8f%e6%8b%a5%e5%a1%9e%e9%80%9a%e7%9f%a5 aria-label="Explicit Congestion Notification 显式拥塞通知">Explicit Congestion Notification 显式拥塞通知</a></li><li><a href=#hop-by-hop-backpressure aria-label="Hop-by-Hop Backpressure">Hop-by-Hop Backpressure</a></li></ul></li></ul></li><li><a href=#ch6-%e4%bc%a0%e8%be%93%e5%b1%82 aria-label="ch6 传输层">ch6 传输层</a><ul><li><a href=#socket aria-label=Socket>Socket</a><ul><li><a href=#%e5%8e%9f%e8%af%ad aria-label=原语>原语</a></li><li><a href=#%e6%96%87%e4%bb%b6%e4%bc%a0%e8%be%93%e7%a8%8b%e5%ba%8f aria-label=文件传输程序>文件传输程序</a><ul><li><a href=#%e5%ae%a2%e6%88%b7%e7%ab%af aria-label=客户端>客户端</a></li><li><a href=#%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%ab%af aria-label=服务器端>服务器端</a></li></ul></li></ul></li></ul></li></ul></li></ul></div></details></div><div class=post-content><ul><li><a href=#computer-network-by-tanenbaum>Computer Network by Tanenbaum</a><ul><li><a href=#ch1>ch1</a><ul><li><a href=#term>term</a></li><li><a href=#%E5%88%86%E5%B1%82>分层</a></li></ul></li><li><a href=#ch2-%E7%89%A9%E7%90%86%E5%B1%82>ch2 物理层</a><ul><li><a href=#%E4%BF%A1%E9%81%93%E5%AE%B9%E9%87%8F>信道容量</a></li><li><a href=#%E4%BB%8B%E8%B4%A8>介质</a></li><li><a href=#%E8%B0%83%E5%88%B6>调制</a></li></ul></li><li><a href=#ch3-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82>ch3 数据链路层</a><ul><li><a href=#frame>frame</a></li><li><a href=#%E6%A3%80%E9%94%99%E7%BA%A0%E9%94%99>检错纠错</a><ul><li><a href=#hamming>hamming</a></li></ul></li><li><a href=#protocol>protocol</a><ul><li><a href=#%E4%B9%8C%E6%89%98%E9%82%A6%E5%BC%8F%E7%9A%84%E5%8D%95%E5%B7%A5%E5%8D%8F%E8%AE%AE>乌托邦式的单工协议</a></li><li><a href=#%E7%AE%80%E5%8D%95%E7%9A%84-%E5%81%9C-%E7%AD%89-%E5%8D%8F%E8%AE%AE%E6%97%A0%E9%94%99%E4%BF%A1%E9%81%93>简单的 停-等 协议，无错信道</a></li><li><a href=#%E7%AE%80%E5%8D%95%E7%9A%84-%E5%81%9C-%E7%AD%89-%E5%8D%8F%E8%AE%AE%E4%BF%A1%E9%81%93%E5%8F%AF%E8%83%BD%E5%87%BA%E9%94%99>简单的 停-等 协议，信道可能出错</a></li><li><a href=#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8D%8F%E8%AE%AE>滑动窗口协议</a><ul><li><a href=#1-%E4%BD%8D-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3>1 位 滑动窗口</a></li><li><a href=#%E5%A4%9A%E4%BD%8D%E7%AA%97%E5%8F%A3>多位窗口</a></li><li><a href=#go-back-n-%E5%9B%9E%E9%80%80-n-%E5%8D%8F%E8%AE%AE>Go-Back-N 回退 N 协议</a></li><li><a href=#selective-repeat-%E9%80%89%E6%8B%A9%E9%87%8D%E4%BC%A0>selective repeat 选择重传</a></li></ul></li></ul></li></ul></li><li><a href=#ch4-%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82>ch4 介质访问控制子层</a><ul><li><a href=#%E5%A4%9A%E8%B7%AF%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE>多路访问协议</a><ul><li><a href=#aloha>ALOHA</a></li><li><a href=#%E5%88%86%E6%A7%BD-aloha>分槽 ALOHA</a></li><li><a href=#csma>CSMA</a><ul><li><a href=#persistent%E7%AD%89%E5%88%B0%E5%8D%A0%E7%94%A8%E7%BB%93%E6%9D%9F%E7%9B%B4%E6%8E%A5%E5%BC%80%E5%A7%8B%E5%8F%91>Persistent：等到占用结束直接开始发</a></li><li><a href=#nonpersistent>Nonpersistent</a></li><li><a href=#p-persistent>p-persistent</a></li></ul></li><li><a href=#csmacd-collision-detection>CSMA/CD collision detection</a></li><li><a href=#csmaca-collision-avoidance>CSMA/CA collision avoidance</a></li><li><a href=#bit-map-%E4%BD%8D%E5%9B%BE%E5%8D%8F%E8%AE%AE-%E6%97%A0%E5%86%B2%E7%AA%81>Bit-Map 位图协议 无冲突</a></li><li><a href=#token-ring-%E4%BB%A4%E7%89%8C%E7%8E%AF-%E6%97%A0%E5%86%B2%E7%AA%81>token ring 令牌环 无冲突</a></li><li><a href=#binary-countdown-%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%AE%A1%E6%95%B0-%E6%97%A0%E5%86%B2%E7%AA%81>binary countdown 二进制计数 无冲突</a></li><li><a href=#the-adaptive-tree-walk-protocol-%E8%87%AA%E9%80%82%E5%BA%94%E6%A0%91%E9%81%8D%E5%8E%86%E5%8D%8F%E8%AE%AE>The Adaptive Tree Walk Protocol 自适应树遍历协议</a></li></ul></li><li><a href=#%E4%BB%A5%E5%A4%AA%E7%BD%91>以太网</a><ul><li><a href=#%E8%AE%BE%E6%96%BD>设施</a></li></ul></li></ul></li><li><a href=#ch5-%E7%BD%91%E7%BB%9C%E5%B1%82>ch5 网络层</a><ul><li><a href=#%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95>路由算法</a><ul><li><a href=#dijstra-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84>Dijstra 最短路径</a></li><li><a href=#flooding-%E6%B3%9B%E6%B4%AA>flooding 泛洪</a></li><li><a href=#distance-vector-routing-%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F%E8%B7%AF%E7%94%B1>distance vector routing 距离向量路由</a></li><li><a href=#link-state-routing-%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E8%B7%AF%E7%94%B1>link state routing 链路状态路由</a></li><li><a href=#%E5%B1%82%E6%AC%A1%E8%B7%AF%E7%94%B1>层次路由</a></li><li><a href=#%E5%B9%BF%E6%92%AD%E8%B7%AF%E7%94%B1>广播路由</a></li></ul></li><li><a href=#%E7%BB%84%E6%92%AD%E8%B7%AF%E7%94%B1>组播路由</a><ul><li><a href=#anycast-routing-%E9%80%89%E6%92%AD%E8%B7%AF%E7%94%B1>anycast routing 选播路由</a></li></ul></li><li><a href=#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95>拥塞控制算法</a><ul><li><a href=#traffic-aware-routing>Traffic-Aware Routing</a></li><li><a href=#admission-control>admission control</a></li><li><a href=#load-shedding>load shedding</a></li><li><a href=#traffic-shaping>traffic shaping</a></li><li><a href=#active-queue-management-%E4%B8%BB%E5%8A%A8%E9%98%9F%E5%88%97%E7%AE%A1%E7%90%86>active queue management 主动队列管理</a></li><li><a href=#random-early-detection-%E9%9A%8F%E6%9C%BA%E6%97%A9%E6%9C%9F%E6%A3%80%E6%B5%8B>Random Early Detection 随机早期检测</a></li><li><a href=#choke-packets>choke packets</a></li><li><a href=#explicit-congestion-notification-%E6%98%BE%E5%BC%8F%E6%8B%A5%E5%A1%9E%E9%80%9A%E7%9F%A5>Explicit Congestion Notification 显式拥塞通知</a></li><li><a href=#hop-by-hop-backpressure>Hop-by-Hop Backpressure</a></li></ul></li></ul></li><li><a href=#ch6-%E4%BC%A0%E8%BE%93%E5%B1%82>ch6 传输层</a><ul><li><a href=#socket>Socket</a><ul><li><a href=#%E5%8E%9F%E8%AF%AD>原语</a></li><li><a href=#%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E7%A8%8B%E5%BA%8F>文件传输程序</a><ul><li><a href=#%E5%AE%A2%E6%88%B7%E7%AB%AF>客户端</a></li><li><a href=#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF>服务器端</a></li></ul></li></ul></li></ul></li></ul></li></ul><h1 id=computer-network-by-tanenbaum>Computer Network by Tanenbaum<a hidden class=anchor aria-hidden=true href=#computer-network-by-tanenbaum>¶</a></h1><h2 id=ch1>ch1<a hidden class=anchor aria-hidden=true href=#ch1>¶</a></h2><h3 id=term>term<a hidden class=anchor aria-hidden=true href=#term>¶</a></h3><blockquote><p>broadcast</p><p>广播</p></blockquote><blockquote><p>point-to-point link</p><p>单播</p></blockquote><blockquote><p>multicasting</p><p>组播：只对一部分用户发送</p></blockquote><h3 id=分层>分层<a hidden class=anchor aria-hidden=true href=#分层>¶</a></h3><ul><li>physical layer<ul><li>物理层。传输 raw bit</li></ul></li><li>data link layer<ul><li>数据链路层。传输数据帧</li><li>为了控制通路，有时需要 介质控制子层 medium access control layer</li></ul></li><li>network layer<ul><li>网络层。路由，包收发</li></ul></li><li>transport layer<ul><li>传输层。主要负责向两个主机中进程之间的通信提供服务。TCP 协议</li></ul></li><li>application layer<ul><li>应用层。HTTP，DNS</li></ul></li></ul><h2 id=ch2-物理层>ch2 物理层<a hidden class=anchor aria-hidden=true href=#ch2-物理层>¶</a></h2><blockquote><p>SNR</p><p>Signal-to-Noise Ratio，信噪比，dB（分贝）单位（$10\log_{10}S/N$）</p></blockquote><h3 id=信道容量>信道容量<a hidden class=anchor aria-hidden=true href=#信道容量>¶</a></h3><p>$$\text{maximum data rate} = 2B \log_2 V \rm{bits/sec}$$</p><p>$$\text{maximum number of bits/sec} = B \log_2(1 + S/N)$$</p><h3 id=介质>介质<a hidden class=anchor aria-hidden=true href=#介质>¶</a></h3><ol><li>双绞线，几公里级，电话线，cat567</li><li>同轴电缆，Cu 制</li><li>光纤，带宽高，损失少</li><li>无线通信<ol><li>一般使用单一窄频段( $\Delta f/f\ll 1$ )</li><li>跳频 frequency hopping spread spectrum</li><li>CDMA 码分多址，Code Division Multiple Access</li><li>FDM 频分复用，Frequency Division Multiplexing ^67f4ec</li><li>TDM 时分复用，Time Division Multiplexing</li><li>UWB 超宽频谱，Ultra-WideBand</li><li>RF<ul><li>低频高 path loss， $1/r^2$ 损失，地波 VLF，LF，MF</li><li>高频直线，损失少，电离层反射 HF，VHF</li></ul></li></ol></li></ol><p><img loading=lazy src=/assets/img/note/net/freq.png alt=freq></p><p><img loading=lazy src=/assets/img/note/net/tech.png alt=tech></p><h3 id=调制>调制<a hidden class=anchor aria-hidden=true href=#调制>¶</a></h3><p><img loading=lazy src=/assets/img/note/net/modulation.png alt=modulation></p><h2 id=ch3-数据链路层>ch3 数据链路层<a hidden class=anchor aria-hidden=true href=#ch3-数据链路层>¶</a></h2><ol><li>为网络层提供接口</li><li>检错纠错</li><li>调节数据流量，防止堵塞</li></ol><p>在 数据链路层 完成检错、确认等比起在网络层，更快速，更加底层。</p><h3 id=frame>frame<a hidden class=anchor aria-hidden=true href=#frame>¶</a></h3><p>从原始 bit 区分 frame。一般使用字符计数法和一种其它方法的组合</p><ol><li>bit 计数，若出错，对帧的影响较大</li><li>flag byte，填充 byte</li><li>flag bit，填充 bit</li><li>直接违反物理层编码，只适用于物理层编码有冗余的网络</li></ol><h3 id=检错纠错>检错纠错<a hidden class=anchor aria-hidden=true href=#检错纠错>¶</a></h3><p>$(n,m)$ 码，当中 $n=m+r$</p><ol><li>hamming</li><li>二进制卷积</li><li>solmen Reed</li><li>低密度奇偶校验</li></ol><ul><li>奇偶</li><li>校验和</li><li>CRC</li></ul><h4 id=hamming>hamming<a hidden class=anchor aria-hidden=true href=#hamming>¶</a></h4><blockquote><p>Hamming distance</p><p>海明距离，两个码字之间不同的对应比特位数目</p></blockquote><p>为了检查出 $d$ 个 bit 错，可以使用海明距离为 $d+1$ 的编码；为了纠正 $d$ 个错，可以使用海明距离为 $2d+1$ 的编码</p><p>对 $2^m$ 个有效信息(信息位数为 $m$ )中任何一个，有 $n=m+r$ 个与其距离为 1 的无效码字（n 位每位都可能出错），因此，每个 $2^m$ 中的合法消息需要 $n+1$ 个位模式来标识它们。有 $(n+1)2^m\le2^n$ ，或者是</p><p>$$(m+r+1)\le2^r$$</p><p>给定 $m$ ，利用该式可以得出校正单比特误码的校验位数目的下界。可采用 k 个码字组成 $k\times n$ 矩阵，按列发送，接收方恢复成 $k\times n$ 矩阵。$kr$个校验位， $km$ 个数据位，可纠正最多为 k 个的突发性连续比特错</p><h3 id=protocol>protocol<a hidden class=anchor aria-hidden=true href=#protocol>¶</a></h3><ul><li>传输层协议 TCP 也提供可靠传输服务</li><li>链路层的可靠传输服务通常用于高误码率的连路上，如无线链路</li><li>对于误码率低的链路，链路层协议可以不实现可靠传输功能</li></ul><p><img loading=lazy src=/assets/img/note/net/layer.png alt=layer></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define MAX_PKT 1024 </span><span class=cm>/* determines packet size in bytes */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>enum</span> <span class=p>{</span><span class=nb>false</span><span class=p>,</span> <span class=nb>true</span><span class=p>}</span> <span class=n>boolean</span><span class=p>;</span><span class=cm>/* boolean type */</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>seq_nr</span><span class=p>;</span><span class=cm>/* sequence or ack numbers */</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span><span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>data</span><span class=p>[</span><span class=n>MAX_PKT</span><span class=p>];}</span> <span class=n>packet</span><span class=p>;</span><span class=cm>/* packet definition */</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>enum</span> <span class=p>{</span><span class=n>data</span><span class=p>,</span> <span class=n>ack</span><span class=p>,</span> <span class=n>nak</span><span class=p>}</span> <span class=n>frame_kind</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cm>/* frame kind definition */</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* frames are transported in this layer */</span>
</span></span><span class=line><span class=cl>    <span class=n>frame_kind</span> <span class=n>kind</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* what kind of frame is it? */</span>
</span></span><span class=line><span class=cl>    <span class=n>seq_nr</span> <span class=n>seq</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* sequence number */</span>
</span></span><span class=line><span class=cl>    <span class=n>seq_nr</span> <span class=n>ack</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* acknowledgement number */</span>
</span></span><span class=line><span class=cl>    <span class=n>packet</span> <span class=n>info</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* the network layer packet */</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>frame</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Wait for an event to happen; return its type in event. */</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>wait_for_event</span><span class=p>(</span><span class=n>event_type</span> <span class=o>*</span><span class=n>event</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/* Fetch a packet from the network layer for transmission on the channel. */</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>from_network_layer</span><span class=p>(</span><span class=n>packet</span> <span class=o>*</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/* Deliver information from an inbound frame to the network layer. */</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>to_network_layer</span><span class=p>(</span><span class=n>packet</span> <span class=o>*</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/* Go get an inbound frame from the physical layer and copy it to r. */</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>from_physical_layer</span><span class=p>(</span><span class=n>frame</span> <span class=o>*</span><span class=n>r</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/* Pass the frame to the physical layer for transmission. */</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>to_physical_layer</span><span class=p>(</span><span class=n>frame</span> <span class=o>*</span><span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/* Start the clock running and enable the timeout event. */</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>start_timer</span><span class=p>(</span><span class=n>seq_nr</span> <span class=n>k</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/* Stop the clock and disable the timeout event. */</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>stop_timer</span><span class=p>(</span><span class=n>seq_nr</span> <span class=n>k</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/* Start an auxiliary timer and enable the ack_timeout event. */</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>start_ack_timer</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/* Stop the auxiliary timer and disable the ack_timeout event. */</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>stop_ack_timer</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/* Allow the network layer to cause a network layer ready event. */</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>enable_network_layer</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/* Forbid the network layer from causing a network layer ready event. */</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>disable_network_layer</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/* Macro inc is expanded in-line: increment k circularly. */</span>
</span></span><span class=line><span class=cl><span class=cp>#define inc(k) if (k &lt; MAX_SEQ) k = k + 1; else k = 0
</span></span></span></code></pre></td></tr></table></div></div><p>1 帧包含 4 个字段：</p><ol><li>kind：种类：控制信息帧还是数据帧</li><li>seq：帧序号</li><li>ack：回应</li><li>info：数据</li></ol><h4 id=乌托邦式的单工协议>乌托邦式的单工协议<a hidden class=anchor aria-hidden=true href=#乌托邦式的单工协议>¶</a></h4><p>单边发送，单边接收。发送方和接收方的网络层总是处于准备就绪状态。数据处理的时间忽略不计。可用的缓存空间无穷大。最强的一个条件是数据链路层之间的通信信道永远不会损坏帧或者丢失帧。</p><ul><li>不进行流量控制</li><li>不检错纠错</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/* Protocol 1 (Utopia) provides for data transmission in one direction only, from
</span></span></span><span class=line><span class=cl><span class=cm>sender to receiver. The communication channel is assumed to be error free
</span></span></span><span class=line><span class=cl><span class=cm>and the receiver is assumed to be able to process all the input infinitely quickly.
</span></span></span><span class=line><span class=cl><span class=cm>Consequently, the sender just sits in a loop pumping data out onto the line as
</span></span></span><span class=line><span class=cl><span class=cm>fast as it can. */</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>enum</span> <span class=p>{</span><span class=n>frame_arrival</span><span class=p>}</span> <span class=n>event_type</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;protocol.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>sender1</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>frame</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* buffer for an outbound frame */</span>
</span></span><span class=line><span class=cl>    <span class=n>packet</span> <span class=n>buffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* buffer for an outbound packet */</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=nb>true</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>from_network_layer</span><span class=p>(</span><span class=o>&amp;</span><span class=n>buffer</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* go get something to send */</span>
</span></span><span class=line><span class=cl>        <span class=n>s</span><span class=p>.</span><span class=n>info</span> <span class=o>=</span> <span class=n>buffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* copy it into s for transmission */</span>
</span></span><span class=line><span class=cl>        <span class=n>to_physical_layer</span><span class=p>(</span><span class=o>&amp;</span><span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* send it on its way */</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Tomorrow, and tomorrow, and tomorrow,
</span></span></span><span class=line><span class=cl><span class=cm>    Creeps in this petty pace from day to day
</span></span></span><span class=line><span class=cl><span class=cm>    To the last syllable of recorded time.
</span></span></span><span class=line><span class=cl><span class=cm>    – Macbeth, V, v */</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>receiver1</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>frame</span> <span class=n>r</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>event_type</span> <span class=n>event</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* filled in by wait, but not used here */</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=nb>true</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>wait_for_event</span><span class=p>(</span><span class=o>&amp;</span><span class=n>event</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* only possibility is frame_arrival */</span>
</span></span><span class=line><span class=cl>        <span class=n>from_physical_layer</span><span class=p>(</span><span class=o>&amp;</span><span class=n>r</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* go get the inbound frame */</span>
</span></span><span class=line><span class=cl>        <span class=n>to_network_layer</span><span class=p>(</span><span class=o>&amp;</span><span class=n>r</span><span class=p>.</span><span class=n>info</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* pass the data to the network layer */</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=简单的-停-等-协议无错信道>简单的 停-等 协议，无错信道<a hidden class=anchor aria-hidden=true href=#简单的-停-等-协议无错信道>¶</a></h4><blockquote><p>stop-and-wait</p><p>发送方在接收方确认接受前，都等待的协议，用于流量控制</p></blockquote><p>双方交替发 frame，每个 frame 中含有上个 frame 的确认信息</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/* Protocol 2 (Stop-and-wait) also provides for a one-directional flow of data from
</span></span></span><span class=line><span class=cl><span class=cm>sender to receiver. The communication channel is once again assumed to be error
</span></span></span><span class=line><span class=cl><span class=cm>free, as in protocol 1. However, this time the receiver has only a finite buffer
</span></span></span><span class=line><span class=cl><span class=cm>capacity and a finite processing speed, so the protocol must explicitly prevent
</span></span></span><span class=line><span class=cl><span class=cm>the sender from flooding the receiver with data faster than it can be handled. */</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>enum</span> <span class=p>{</span><span class=n>frame_arrival</span><span class=p>}</span> <span class=n>event_type</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;protocol.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>void</span> <span class=nf>sender2</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>frame</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* buffer for an outbound frame */</span>
</span></span><span class=line><span class=cl>    <span class=n>packet</span> <span class=n>buffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* buffer for an outbound packet */</span>
</span></span><span class=line><span class=cl>    <span class=n>event_type</span> <span class=n>event</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* frame_arrival is the only possibility */</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=nb>true</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>from_network_layer</span><span class=p>(</span><span class=o>&amp;</span><span class=n>buffer</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* go get something to send */</span>
</span></span><span class=line><span class=cl>        <span class=n>s</span><span class=p>.</span><span class=n>info</span> <span class=o>=</span> <span class=n>buffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* copy it into s for transmission */</span>
</span></span><span class=line><span class=cl>        <span class=n>to_physical_layer</span><span class=p>(</span><span class=o>&amp;</span><span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* bye-bye little frame */</span>
</span></span><span class=line><span class=cl>        <span class=n>wait_for_event</span><span class=p>(</span><span class=o>&amp;</span><span class=n>event</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* do not proceed until given the go ahead */</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>receiver2</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>frame</span> <span class=n>r</span><span class=p>,</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* buffers for frames */</span>
</span></span><span class=line><span class=cl>    <span class=n>event_type</span> <span class=n>event</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* frame_arrival is the only possibility */</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=nb>true</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>wait_for_event</span><span class=p>(</span><span class=o>&amp;</span><span class=n>event</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* only possibility is frame_arrival */</span>
</span></span><span class=line><span class=cl>        <span class=n>from_physical_layer</span><span class=p>(</span><span class=o>&amp;</span><span class=n>r</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* go get the inbound frame */</span>
</span></span><span class=line><span class=cl>        <span class=n>to_network_layer</span><span class=p>(</span><span class=o>&amp;</span><span class=n>r</span><span class=p>.</span><span class=n>info</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* pass the data to the network layer */</span>
</span></span><span class=line><span class=cl>        <span class=n>to_physical_layer</span><span class=p>(</span><span class=o>&amp;</span><span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* send a dummy frame to awaken sender */</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=简单的-停-等-协议信道可能出错>简单的 停-等 协议，信道可能出错<a hidden class=anchor aria-hidden=true href=#简单的-停-等-协议信道可能出错>¶</a></h4><ul><li>需要加入计时器，防止 frame 丢失</li><li>需要标记帧号码，防止重复接收</li></ul><p>考虑 $m$ 帧和 $m+1$ 帧。如果 $m$ 帧没有发送成功，接收方不会确认；如果发送成功，接收方就会发确认消息。所以下一次发送方要么重发 $m$ 帧，要么接收到正确的确认消息，发 $m+1$ 帧。所以每次只需要区分 2 帧，帧号码只需要 1 位（单 bit）</p><blockquote><p>PAR (Positive</p><p>Positive Acknowledgement with Retransmission,带有重传的肯定确认</p></blockquote><blockquote><p>ARQ</p><p>Automatic Repeat reQuest,自动重复请求</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/* Protocol 3 (PAR) allows unidirectional data flow over an unreliable channel. */</span>
</span></span><span class=line><span class=cl><span class=cp>#define MAX_SEQ 1
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/* must be 1 for protocol 3 */</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>enum</span> <span class=p>{</span><span class=n>frame_arrival</span><span class=p>,</span> <span class=n>cksum_err</span><span class=p>,</span> <span class=n>timeout</span><span class=p>}</span> <span class=n>event_type</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;protocol.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>void</span> <span class=nf>sender3</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>seq_nr</span> <span class=n>next_frame_to_send</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* seq number of next outgoing frame */</span>
</span></span><span class=line><span class=cl>    <span class=n>frame</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* scratch variable */</span>
</span></span><span class=line><span class=cl>    <span class=n>packet</span> <span class=n>buffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* buffer for an outbound packet */</span>
</span></span><span class=line><span class=cl>    <span class=n>event_type</span> <span class=n>event</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>next_frame_to_send</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* initialize outbound sequence numbers */</span>
</span></span><span class=line><span class=cl>    <span class=n>from_network_layer</span><span class=p>(</span><span class=o>&amp;</span><span class=n>buffer</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* fetch first packet */</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=nb>true</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>s</span><span class=p>.</span><span class=n>info</span> <span class=o>=</span> <span class=n>buffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* construct a frame for transmission */</span>
</span></span><span class=line><span class=cl>        <span class=n>s</span><span class=p>.</span><span class=n>seq</span> <span class=o>=</span> <span class=n>next_frame_to_send</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* insert sequence number in frame */</span>
</span></span><span class=line><span class=cl>        <span class=n>to_physical_layer</span><span class=p>(</span><span class=o>&amp;</span><span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* send it on its way */</span>
</span></span><span class=line><span class=cl>        <span class=n>start_timer</span><span class=p>(</span><span class=n>s</span><span class=p>.</span><span class=n>seq</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* if answer takes too long, time out */</span>
</span></span><span class=line><span class=cl>        <span class=n>wait_for_event</span><span class=p>(</span><span class=o>&amp;</span><span class=n>event</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* frame_arrival, cksum_err, timeout */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>event</span> <span class=o>==</span> <span class=n>frame_arrival</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>from_physical_layer</span><span class=p>(</span><span class=o>&amp;</span><span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* get the acknowledgement */</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>s</span><span class=p>.</span><span class=n>ack</span> <span class=o>==</span> <span class=n>next_frame_to_send</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>stop_timer</span><span class=p>(</span><span class=n>s</span><span class=p>.</span><span class=n>ack</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=cm>/* turn the timer off */</span>
</span></span><span class=line><span class=cl>                <span class=n>from_network_layer</span><span class=p>(</span><span class=o>&amp;</span><span class=n>buffer</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=cm>/* get the next one to send */</span>
</span></span><span class=line><span class=cl>                <span class=n>inc</span><span class=p>(</span><span class=n>next_frame_to_send</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=cm>/* invert next_frame_to_send */</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>receiver3</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>seq_nr</span> <span class=n>frame_expected</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>frame</span> <span class=n>r</span><span class=p>,</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>event_type</span> <span class=n>event</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>frame_expected</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=nb>true</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>wait_for_event</span><span class=p>(</span><span class=o>&amp;</span><span class=n>event</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* possibilities: frame_arrival, cksum_err */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>event</span> <span class=o>==</span> <span class=n>frame_arrival</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* a valid frame has arrived */</span>
</span></span><span class=line><span class=cl>            <span class=n>from_physical_layer</span><span class=p>(</span><span class=o>&amp;</span><span class=n>r</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* go get the newly arrived frame */</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>r</span><span class=p>.</span><span class=n>seq</span> <span class=o>==</span> <span class=n>frame_expected</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=cm>/* this is what we have been waiting for */</span>
</span></span><span class=line><span class=cl>                <span class=n>to_network_layer</span><span class=p>(</span><span class=o>&amp;</span><span class=n>r</span><span class=p>.</span><span class=n>info</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=cm>/* pass the data to the network layer */</span>
</span></span><span class=line><span class=cl>                <span class=n>inc</span><span class=p>(</span><span class=n>frame_expected</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=cm>/* next time expect the other sequence nr */</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=n>s</span><span class=p>.</span><span class=n>ack</span> <span class=o>=</span> <span class=mi>1</span> <span class=err>−</span> <span class=n>frame_expected</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* tell which frame is being acked */</span>
</span></span><span class=line><span class=cl>            <span class=n>to_physical_layer</span><span class=p>(</span><span class=o>&amp;</span><span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* send acknowledgement */</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=滑动窗口协议>滑动窗口协议<a hidden class=anchor aria-hidden=true href=#滑动窗口协议>¶</a></h4><p>双工，而不是使用两个单工协议。</p><blockquote><p>piggybacking</p><p>捎带确认，不单独发送确认帧，而是把确认信息放在下一数据帧当中</p></blockquote><p>使用 sending window 和 receiving window。窗口数目对应帧所需缓存区大小</p><ul><li>sending window<ul><li>窗口中保存需要发送的帧</li><li>新到的帧窗口扩张</li><li>收到确认后，窗口缩小</li></ul></li><li>receiving window<ul><li>只接受窗口内序号的帧</li></ul></li></ul><p><img loading=lazy src=/assets/img/note/net/slidingwin.png alt="sliding windows"></p><h5 id=1-位-滑动窗口>1 位 滑动窗口<a hidden class=anchor aria-hidden=true href=#1-位-滑动窗口>¶</a></h5><p><img loading=lazy src=/assets/img/note/net/1bit.png alt=1bit></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/* Protocol 4 (Sliding window) is bidirectional. */</span>
</span></span><span class=line><span class=cl><span class=cp>#define MAX_SEQ 1
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/* must be 1 for protocol 4 */</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>enum</span> <span class=p>{</span><span class=n>frame_arrival</span><span class=p>,</span> <span class=n>cksum_err</span><span class=p>,</span> <span class=n>timeout</span><span class=p>}</span> <span class=n>event_type</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;protocol.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>void</span> <span class=nf>protocol4</span> <span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>seq_nr</span> <span class=n>next_frame_to_send</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 0 or 1 only */</span>
</span></span><span class=line><span class=cl>    <span class=n>seq_nr</span> <span class=n>frame_expected</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 0 or 1 only */</span>
</span></span><span class=line><span class=cl>    <span class=n>frame</span> <span class=n>r</span><span class=p>,</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* scratch variables */</span>
</span></span><span class=line><span class=cl>    <span class=n>packet</span> <span class=n>buffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* current packet being sent */</span>
</span></span><span class=line><span class=cl>    <span class=n>event_type</span> <span class=n>event</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>next_frame_to_send</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* next frame on the outbound stream */</span>
</span></span><span class=line><span class=cl>    <span class=n>frame_expected</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* frame_expected next */</span>
</span></span><span class=line><span class=cl>    <span class=n>from_network_layer</span><span class=p>(</span><span class=o>&amp;</span><span class=n>buffer</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* fetch a packet from the network layer */</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span><span class=p>.</span><span class=n>info</span> <span class=o>=</span> <span class=n>buffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* prepare to send the initial frame */</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span><span class=p>.</span><span class=n>seq</span> <span class=o>=</span> <span class=n>next_frame_to_send</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* insert sequence number into frame */</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span><span class=p>.</span><span class=n>ack</span> <span class=o>=</span> <span class=mi>1</span> <span class=err>−</span> <span class=n>frame_expected</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* piggybacked ack */</span>
</span></span><span class=line><span class=cl>    <span class=n>to_physical_layer</span><span class=p>(</span><span class=o>&amp;</span><span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* transmit the frame */</span>
</span></span><span class=line><span class=cl>    <span class=n>start_timer</span><span class=p>(</span><span class=n>s</span><span class=p>.</span><span class=n>seq</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* start the timer running */</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=nb>true</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>wait_for_event</span><span class=p>(</span><span class=o>&amp;</span><span class=n>event</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* frame_arrival, cksum_err, or timeout */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>event</span> <span class=o>==</span> <span class=n>frame_arrival</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* a frame has arrived undamaged */</span>
</span></span><span class=line><span class=cl>            <span class=n>from_physical_layer</span><span class=p>(</span><span class=o>&amp;</span><span class=n>r</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* go get it */</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>r</span><span class=p>.</span><span class=n>seq</span> <span class=o>==</span> <span class=n>frame_expected</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=cm>/* handle inbound frame stream */</span>
</span></span><span class=line><span class=cl>                <span class=n>to_network_layer</span><span class=p>(</span><span class=o>&amp;</span><span class=n>r</span><span class=p>.</span><span class=n>info</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=cm>/* pass packet to_network_layer */</span>
</span></span><span class=line><span class=cl>                <span class=n>inc</span><span class=p>(</span><span class=n>frame_expected</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=cm>/* invert seq number expected next */</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>r</span><span class=p>.</span><span class=n>ack</span> <span class=o>==</span> <span class=n>next_frame_to_send</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=cm>/* handle outbound frame stream */</span>
</span></span><span class=line><span class=cl>                <span class=n>stop_timer</span><span class=p>(</span><span class=n>r</span><span class=p>.</span><span class=n>ack</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=cm>/* turn the timer off */</span>
</span></span><span class=line><span class=cl>                <span class=n>from_network_layer</span><span class=p>(</span><span class=o>&amp;</span><span class=n>buffer</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=cm>/* fetch new pkt from_network_layer */</span>
</span></span><span class=line><span class=cl>                <span class=n>inc</span><span class=p>(</span><span class=n>next_frame_to_send</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=cm>/* invert sender’s sequence number */</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>s</span><span class=p>.</span><span class=n>info</span> <span class=o>=</span> <span class=n>buffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* construct outbound frame */</span>
</span></span><span class=line><span class=cl>        <span class=n>s</span><span class=p>.</span><span class=n>seq</span> <span class=o>=</span> <span class=n>next_frame_to_send</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* insert sequence number into it */</span>
</span></span><span class=line><span class=cl>        <span class=n>s</span><span class=p>.</span><span class=n>ack</span> <span class=o>=</span> <span class=mi>1</span> <span class=err>−</span> <span class=n>frame_expected</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* seq number of last received frame */</span>
</span></span><span class=line><span class=cl>        <span class=n>to_physical_layer</span><span class=p>(</span><span class=o>&amp;</span><span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* transmit a frame */</span>
</span></span><span class=line><span class=cl>        <span class=n>start_timer</span><span class=p>(</span><span class=n>s</span><span class=p>.</span><span class=n>seq</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* start the timer running */</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h5 id=多位窗口>多位窗口<a hidden class=anchor aria-hidden=true href=#多位窗口>¶</a></h5><p>由于信道传输时间不可忽略，1 位滑动窗口的异常启动问题不可忽略，需要提高带宽利用率。</p><blockquote><p>bandwidth-delya product</p><p>$\text{带宽(bits/sec)}\times \text{单次传输时间}$</p><p>在以帧数为单位时，记作 BD</p></blockquote><p>在阻塞前，一次性发送$w=2BD+1$。如果考虑发送方连续发送帧并且在往返时间内收到一个确认，那么两倍的带宽-延时就是发送方可以连续发送的帧的个数；$+1$是因为必须接收完整个帧之后确认帧才会被发出。pipelining （排队发送帧）就能提高链路利用率。</p><p>$$\text{link utilization}=\frac{w}{1+2BD}$$</p><ul><li>go-back-n：放弃出错帧之后的正确帧（相当于窗口大小 1）</li><li>selective repeat，只放弃错误帧，缓存之后的正确帧</li></ul><p>两种策略分别平衡缓存区和带宽利用率。</p><p><img loading=lazy src=/assets/img/note/net/gobackn.png alt=go-back-n></p><h5 id=go-back-n-回退-n-协议>Go-Back-N 回退 N 协议<a hidden class=anchor aria-hidden=true href=#go-back-n-回退-n-协议>¶</a></h5><p>最多发送$MAX\_SEQ$个帧。虽然不需要缓存出错后到来的帧，但是它也没有因此完全摆脱缓存问题。由于发送方可能在将来的某个时刻要重传所有未被确认的帧，所以，它必须把已经发送出去的帧一直保留，直到它能肯定接收方已经接受了这些帧。对之前的帧，可以用软件模拟每个帧的时间计数器</p><blockquote><p>cumulative acknowledgement</p><p>累计确认，当$n$号帧到达，之前序号的帧自动被确认（因为回退特性）</p></blockquote><p><img loading=lazy src=/assets/img/note/net/stime.png alt="software timer"></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/* Protocol 5 (Go-back-n) allows multiple outstanding frames. The sender may transmit up
</span></span></span><span class=line><span class=cl><span class=cm>to MAX_SEQ frames without waiting for an ack. In addition, unlike in the previous
</span></span></span><span class=line><span class=cl><span class=cm>protocols, the network layer is not assumed to have a new packet all the time. Instead,
</span></span></span><span class=line><span class=cl><span class=cm>the network layer causes a network layer ready event when there is a packet to send. */</span>
</span></span><span class=line><span class=cl><span class=cp>#define MAX_SEQ 7
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>typedef</span> <span class=k>enum</span> <span class=p>{</span><span class=n>frame_arrival</span><span class=p>,</span> <span class=n>cksum_err</span><span class=p>,</span> <span class=n>timeout</span><span class=p>,</span> <span class=n>network_layer_ready</span><span class=p>}</span> <span class=n>event_type</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;protocol.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>static</span> <span class=n>boolean</span> <span class=nf>between</span><span class=p>(</span><span class=n>seq_nr</span> <span class=n>a</span><span class=p>,</span> <span class=n>seq_nr</span> <span class=n>b</span><span class=p>,</span> <span class=n>seq_nr</span> <span class=n>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Return true if a &lt;= b &lt; c circularly; false otherwise. */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(((</span><span class=n>a</span> <span class=o>&lt;=</span> <span class=n>b</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>b</span> <span class=o>&lt;</span> <span class=n>c</span><span class=p>))</span> <span class=o>||</span> <span class=p>((</span><span class=n>c</span> <span class=o>&lt;</span> <span class=n>a</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>a</span> <span class=o>&lt;=</span> <span class=n>b</span><span class=p>))</span> <span class=o>||</span> <span class=p>((</span><span class=n>b</span> <span class=o>&lt;</span> <span class=n>c</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>c</span> <span class=o>&lt;</span> <span class=n>a</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>(</span><span class=nb>true</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>(</span><span class=nb>false</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>send_data</span><span class=p>(</span><span class=n>seq_nr</span> <span class=n>frame_nr</span><span class=p>,</span> <span class=n>seq_nr</span> <span class=n>frame_expected</span><span class=p>,</span> <span class=n>packet</span> <span class=n>buffer</span><span class=p>[</span> <span class=p>])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Construct and send a data frame. */</span>
</span></span><span class=line><span class=cl>    <span class=n>frame</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* scratch variable */</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span><span class=p>.</span><span class=n>info</span> <span class=o>=</span> <span class=n>buffer</span><span class=p>[</span><span class=n>frame_nr</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* insert packet into frame */</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span><span class=p>.</span><span class=n>seq</span> <span class=o>=</span> <span class=n>frame_nr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* insert sequence number into frame */</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span><span class=p>.</span><span class=n>ack</span> <span class=o>=</span> <span class=p>(</span><span class=n>frame_expected</span> <span class=o>+</span> <span class=n>MAX_SEQ</span><span class=p>)</span> <span class=o>%</span> <span class=p>(</span><span class=n>MAX_SEQ</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span><span class=cm>/* piggyback ack */</span>
</span></span><span class=line><span class=cl>    <span class=n>to_physical_layer</span><span class=p>(</span><span class=o>&amp;</span><span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* transmit the frame */</span>
</span></span><span class=line><span class=cl>    <span class=n>start_timer</span><span class=p>(</span><span class=n>frame_nr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* start the timer running */</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>protocol5</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>seq_nr</span> <span class=n>next_frame_to_send</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* MAX_SEQ &gt; 1; used for outbound stream */</span>
</span></span><span class=line><span class=cl>    <span class=n>seq_nr</span> <span class=n>ack_expected</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* oldest frame as yet unacknowledged */</span>
</span></span><span class=line><span class=cl>    <span class=n>seq_nr</span> <span class=n>frame_expected</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* next frame_expected on inbound stream */</span>
</span></span><span class=line><span class=cl>    <span class=n>frame</span> <span class=n>r</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* scratch variable */</span>
</span></span><span class=line><span class=cl>    <span class=n>packet</span> <span class=n>buffer</span><span class=p>[</span><span class=n>MAX_SEQ</span> <span class=o>+</span> <span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* buffers for the outbound stream */</span>
</span></span><span class=line><span class=cl>    <span class=n>seq_nr</span> <span class=n>nbuffered</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* number of output buffers currently in use */</span>
</span></span><span class=line><span class=cl>    <span class=n>seq_nr</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* used to index into the buffer array */</span>
</span></span><span class=line><span class=cl>    <span class=n>event_type</span> <span class=n>event</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>enable_network_layer</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* allow network layer ready events */</span>
</span></span><span class=line><span class=cl>    <span class=n>ack_expected</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* next ack_expected inbound */</span>
</span></span><span class=line><span class=cl>    <span class=n>next_frame_to_send</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* next frame going out */</span>
</span></span><span class=line><span class=cl>    <span class=n>frame_expected</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* number of frame_expected inbound */</span>
</span></span><span class=line><span class=cl>    <span class=n>nbuffered</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* initially no packets are buffered */</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=nb>true</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>wait_for_event</span><span class=p>(</span><span class=o>&amp;</span><span class=n>event</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* four possibilities: see event_type above */</span>
</span></span><span class=line><span class=cl>        <span class=k>switch</span><span class=p>(</span><span class=n>event</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>network_layer_ready</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* the network layer has a packet to send */</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* Accept, save, and transmit a new frame. */</span>
</span></span><span class=line><span class=cl>            <span class=n>from_network_layer</span><span class=p>(</span><span class=o>&amp;</span><span class=n>buffer</span><span class=p>[</span><span class=n>next_frame_to_send</span><span class=p>]);</span> <span class=cm>/* fetch new packet */</span>
</span></span><span class=line><span class=cl>            <span class=n>nbuffered</span> <span class=o>=</span> <span class=n>nbuffered</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* expand the sender’s window */</span>
</span></span><span class=line><span class=cl>            <span class=n>send_data</span><span class=p>(</span><span class=n>next_frame_to_send</span><span class=p>,</span> <span class=n>frame_expected</span><span class=p>,</span> <span class=n>buffer</span><span class=p>);</span><span class=cm>/* transmit the frame */</span>
</span></span><span class=line><span class=cl>            <span class=n>inc</span><span class=p>(</span><span class=n>next_frame_to_send</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* advance sender’s upper window edge */</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>frame_arrival</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* a data or control frame has arrived */</span>
</span></span><span class=line><span class=cl>            <span class=n>from_physical_layer</span><span class=p>(</span><span class=o>&amp;</span><span class=n>r</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* get incoming frame from_physical_layer */</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>r</span><span class=p>.</span><span class=n>seq</span> <span class=o>==</span> <span class=n>frame_expected</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=cm>/* Frames are accepted only in order. */</span>
</span></span><span class=line><span class=cl>                <span class=n>to_network_layer</span><span class=p>(</span><span class=o>&amp;</span><span class=n>r</span><span class=p>.</span><span class=n>info</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=cm>/* pass packet to_network_layer */</span>
</span></span><span class=line><span class=cl>                <span class=n>inc</span><span class=p>(</span><span class=n>frame_expected</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=cm>/* advance lower edge of receiver’s window */</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* Ack n implies n − 1, n − 2, etc. Check for this. */</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=p>(</span><span class=n>between</span><span class=p>(</span><span class=n>ack_expected</span><span class=p>,</span> <span class=n>r</span><span class=p>.</span><span class=n>ack</span><span class=p>,</span> <span class=n>next_frame_to_send</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=cm>/* Handle piggybacked ack. */</span>
</span></span><span class=line><span class=cl>                <span class=n>nbuffered</span> <span class=o>=</span> <span class=n>nbuffered</span> <span class=err>−</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=cm>/* one frame fewer buffered */</span>
</span></span><span class=line><span class=cl>                <span class=n>stop_timer</span><span class=p>(</span><span class=n>ack_expected</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=cm>/* frame arrived intact; stop_timer */</span>
</span></span><span class=line><span class=cl>                <span class=n>inc</span><span class=p>(</span><span class=n>ack_expected</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=cm>/* contract sender’s window */</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>cksum_err</span><span class=p>:</span> <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* just ignore bad frames */</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>timeout</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* trouble; retransmit all outstanding frames */</span>
</span></span><span class=line><span class=cl>            <span class=n>next_frame_to_send</span> <span class=o>=</span> <span class=n>ack_expected</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* start retransmitting here */</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>nbuffered</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>send_data</span><span class=p>(</span><span class=n>next_frame_to_send</span><span class=p>,</span> <span class=n>frame_expected</span><span class=p>,</span> <span class=n>buffer</span><span class=p>);</span><span class=cm>/* resend_frame */</span>
</span></span><span class=line><span class=cl>                <span class=n>inc</span><span class=p>(</span><span class=n>next_frame_to_send</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=cm>/* prepare to send the next one */</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>nbuffered</span> <span class=o>&lt;</span> <span class=n>MAX_SEQ</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>enable_network_layer</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=n>disable_network_layer</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h5 id=selective-repeat-选择重传>selective repeat 选择重传<a hidden class=anchor aria-hidden=true href=#selective-repeat-选择重传>¶</a></h5><p>针对错误更加频繁的情景。窗口移动后，和老的不重叠，防止老的重传和新的帧混淆。$\frac{(MAX\_SEQ+1)}{2}$。启用一个辅助计时器，在没有反向数据帧时候单独发出确认帧。</p><blockquote><p>NAK</p><p>negative acknowledgement，否认确定记号。触发某一帧的重传</p></blockquote><p><img loading=lazy src=/assets/img/note/net/wsize.png alt="window size"></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span><span class=lnt>145
</span><span class=lnt>146
</span><span class=lnt>147
</span><span class=lnt>148
</span><span class=lnt>149
</span><span class=lnt>150
</span><span class=lnt>151
</span><span class=lnt>152
</span><span class=lnt>153
</span><span class=lnt>154
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/* Protocol 6 (Selective repeat) accepts frames out of order but passes packets to the
</span></span></span><span class=line><span class=cl><span class=cm>network layer in order. Associated with each outstanding frame is a timer. When the timer
</span></span></span><span class=line><span class=cl><span class=cm>expires, only that frame is retransmitted, not all the outstanding frames, as in protocol 5. */</span>
</span></span><span class=line><span class=cl><span class=cp>#define MAX_SEQ 7
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/* should be 2ˆn − 1 */</span>
</span></span><span class=line><span class=cl><span class=cp>#define NR_BUFS ((MAX_SEQ + 1)/2)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>typedef</span> <span class=k>enum</span> <span class=p>{</span><span class=n>frame_arrival</span><span class=p>,</span> <span class=n>cksum_err</span><span class=p>,</span> <span class=n>timeout</span><span class=p>,</span> <span class=n>network_layer_ready</span><span class=p>,</span> <span class=n>ack_timeout</span><span class=p>}</span> <span class=n>event_type</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;protocol.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=n>boolean</span> <span class=n>no_nak</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cm>/* no_nak has been sent yet */</span>
</span></span><span class=line><span class=cl><span class=n>seq_nr</span> <span class=n>oldest_frame</span> <span class=o>=</span> <span class=n>MAX_SEQ</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cm>/* initial value is only for the simulator */</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=n>boolean</span> <span class=nf>between</span><span class=p>(</span><span class=n>seq_nr</span> <span class=n>a</span><span class=p>,</span> <span class=n>seq_nr</span> <span class=n>b</span><span class=p>,</span> <span class=n>seq_nr</span> <span class=n>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Same as between in protocol 5, but shorter and more obscure. */</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>((</span><span class=n>a</span> <span class=o>&lt;=</span> <span class=n>b</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>b</span> <span class=o>&lt;</span> <span class=n>c</span><span class=p>))</span> <span class=o>||</span> <span class=p>((</span><span class=n>c</span> <span class=o>&lt;</span> <span class=n>a</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>a</span> <span class=o>&lt;=</span> <span class=n>b</span><span class=p>))</span> <span class=o>||</span> <span class=p>((</span><span class=n>b</span> <span class=o>&lt;</span> <span class=n>c</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>c</span> <span class=o>&lt;</span> <span class=n>a</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>send_frame</span><span class=p>(</span><span class=n>frame_kind</span> <span class=n>fk</span><span class=p>,</span> <span class=n>seq_nr</span> <span class=n>frame_nr</span><span class=p>,</span> <span class=n>seq_nr</span> <span class=n>frame_expected</span><span class=p>,</span> <span class=n>packet</span> <span class=n>buffer</span><span class=p>[</span> <span class=p>])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Construct and send a data, ack, or nak frame. */</span>
</span></span><span class=line><span class=cl>    <span class=n>frame</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* scratch variable */</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span><span class=p>.</span><span class=n>kind</span> <span class=o>=</span> <span class=n>fk</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* kind == data, ack, or nak */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>fk</span> <span class=o>==</span> <span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>s</span><span class=p>.</span><span class=n>info</span> <span class=o>=</span> <span class=n>buffer</span><span class=p>[</span><span class=n>frame_nr</span> <span class=o>%</span> <span class=n>NR_BUFS</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>s</span><span class=p>.</span><span class=n>seq</span> <span class=o>=</span> <span class=n>frame_nr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* only meaningful for data frames */</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span><span class=p>.</span><span class=n>ack</span> <span class=o>=</span> <span class=p>(</span><span class=n>frame_expected</span> <span class=o>+</span> <span class=n>MAX_SEQ</span><span class=p>)</span> <span class=o>%</span> <span class=p>(</span><span class=n>MAX_SEQ</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>fk</span> <span class=o>==</span> <span class=n>nak</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>no_nak</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* one nak per frame, please */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>to_physical_layer</span><span class=p>(</span><span class=o>&amp;</span><span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* transmit the frame */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>fk</span> <span class=o>==</span> <span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>start_timer</span><span class=p>(</span><span class=n>frame_nr</span> <span class=o>%</span> <span class=n>NR_BUFS</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>stop_ack_timer</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* no need for separate ack frame */</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>protocol6</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>seq_nr</span> <span class=n>ack_expected</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* lower edge of sender’s window */</span>
</span></span><span class=line><span class=cl>    <span class=n>seq_nr</span> <span class=n>next_frame_to_send</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* upper edge of sender’s window + 1 */</span>
</span></span><span class=line><span class=cl>    <span class=n>seq_nr</span> <span class=n>frame_expected</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* lower edge of receiver’s window */</span>
</span></span><span class=line><span class=cl>    <span class=n>seq_nr</span> <span class=n>too</span> <span class=n>far</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* upper edge of receiver’s window + 1 */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* index into buffer pool */</span>
</span></span><span class=line><span class=cl>    <span class=n>frame</span> <span class=n>r</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* scratch variable */</span>
</span></span><span class=line><span class=cl>    <span class=n>packet</span> <span class=n>out_buf</span><span class=p>[</span><span class=n>NR_BUFS</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* buffers for the outbound stream */</span>
</span></span><span class=line><span class=cl>    <span class=n>packet</span> <span class=n>in_buf</span><span class=p>[</span><span class=n>NR_BUFS</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* buffers for the inbound stream */</span>
</span></span><span class=line><span class=cl>    <span class=n>boolean</span> <span class=n>arrived</span><span class=p>[</span><span class=n>NR_BUFS</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* inbound bit map */</span>
</span></span><span class=line><span class=cl>    <span class=n>seq_nr</span> <span class=n>nbuffered</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* how many output buffers currently used */</span>
</span></span><span class=line><span class=cl>    <span class=n>event_type</span> <span class=n>event</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>enable_network_layer</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* initialize */</span>
</span></span><span class=line><span class=cl>    <span class=n>ack_expected</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* next ack_expected on the inbound stream */</span>
</span></span><span class=line><span class=cl>    <span class=n>next_frame_to_send</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* number of next outgoing frame */</span>
</span></span><span class=line><span class=cl>    <span class=n>frame_expected</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>too_far</span> <span class=o>=</span> <span class=n>NR_BUFS</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>nbuffered</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* initially no packets are buffered */</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>NR_BUFS</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=n>arrived</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=nb>true</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>wait_for_event</span><span class=p>(</span><span class=o>&amp;</span><span class=n>event</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* five possibilities: see event_type above */</span>
</span></span><span class=line><span class=cl>        <span class=k>switch</span><span class=p>(</span><span class=n>event</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>network_layer_ready</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* accept, save, and transmit a new frame */</span>
</span></span><span class=line><span class=cl>            <span class=n>nbuffered</span> <span class=o>=</span> <span class=n>nbuffered</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* expand the window */</span>
</span></span><span class=line><span class=cl>            <span class=n>from_network_layer</span><span class=p>(</span><span class=o>&amp;</span><span class=n>out_buf</span><span class=p>[</span><span class=n>next_frame_to_send</span> <span class=o>%</span> <span class=n>NR_BUFS</span><span class=p>]);</span> <span class=cm>/* fetch new packet */</span>
</span></span><span class=line><span class=cl>            <span class=n>send_frame</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>next_frame_to_send</span><span class=p>,</span> <span class=n>frame_expected</span><span class=p>,</span> <span class=n>out_buf</span><span class=p>);</span><span class=cm>/* transmit the frame */</span>
</span></span><span class=line><span class=cl>            <span class=n>inc</span><span class=p>(</span><span class=n>next_frame_to_send</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* advance upper window edge */</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>frame_arrival</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* a data or control frame has arrived */</span>
</span></span><span class=line><span class=cl>            <span class=n>from_physical_layer</span><span class=p>(</span><span class=o>&amp;</span><span class=n>r</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* fetch incoming frame from_physical_layer */</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>r</span><span class=p>.</span><span class=n>kind</span> <span class=o>==</span> <span class=n>data</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=cm>/* An undamaged frame has arrived. */</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>((</span><span class=n>r</span><span class=p>.</span><span class=n>seq</span> <span class=o>!=</span> <span class=n>frame_expected</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>no_nak</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=n>send_frame</span><span class=p>(</span><span class=n>nak</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>frame_expected</span><span class=p>,</span> <span class=n>out_buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=k>else</span>
</span></span><span class=line><span class=cl>                    <span class=n>start_ack_timer</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>between</span><span class=p>(</span><span class=n>frame_expected</span><span class=p>,</span><span class=n>r</span><span class=p>.</span><span class=n>seq</span><span class=p>,</span><span class=n>too</span> <span class=n>far</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>arrived</span><span class=p>[</span><span class=n>r</span><span class=p>.</span><span class=n>seq</span><span class=o>%</span><span class=n>NR_BUFS</span><span class=p>]</span><span class=o>==</span><span class=nb>false</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=cm>/* Frames may be accepted in any order. */</span>
</span></span><span class=line><span class=cl>                    <span class=n>arrived</span><span class=p>[</span><span class=n>r</span><span class=p>.</span><span class=n>seq</span> <span class=o>%</span> <span class=n>NR_BUFS</span><span class=p>]</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=cm>/* mark buffer as full */</span>
</span></span><span class=line><span class=cl>                    <span class=n>in_buf</span><span class=p>[</span><span class=n>r</span><span class=p>.</span><span class=n>seq</span> <span class=o>%</span> <span class=n>NR_BUFS</span><span class=p>]</span> <span class=o>=</span> <span class=n>r</span><span class=p>.</span><span class=n>info</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=cm>/* insert data into buffer */</span>
</span></span><span class=line><span class=cl>                    <span class=k>while</span> <span class=p>(</span><span class=n>arrived</span><span class=p>[</span><span class=n>frame_expected</span> <span class=o>%</span> <span class=n>NR_BUFS</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=cm>/* Pass frames and advance window. */</span>
</span></span><span class=line><span class=cl>                        <span class=n>to_network_layer</span><span class=p>(</span><span class=o>&amp;</span><span class=n>in_buf</span><span class=p>[</span><span class=n>frame_expected</span> <span class=o>%</span> <span class=n>NR_BUFS</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>                        <span class=n>no_nak</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                        <span class=n>arrived</span><span class=p>[</span><span class=n>frame_expected</span> <span class=o>%</span> <span class=n>NR_BUFS</span><span class=p>]</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                        <span class=n>inc</span><span class=p>(</span><span class=n>frame_expected</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                        <span class=cm>/* advance lower edge of receiver’s window */</span>
</span></span><span class=line><span class=cl>                        <span class=n>inc</span><span class=p>(</span><span class=n>too</span> <span class=n>far</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                        <span class=cm>/* advance upper edge of receiver’s window */</span>
</span></span><span class=line><span class=cl>                        <span class=n>start_ack_timer</span><span class=p>();</span>
</span></span><span class=line><span class=cl>                        <span class=cm>/* to see if a separate ack is needed */</span>
</span></span><span class=line><span class=cl>                    <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>((</span><span class=n>r</span><span class=p>.</span><span class=n>kind</span><span class=o>==</span><span class=n>nak</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>between</span><span class=p>(</span><span class=n>ack_expected</span><span class=p>,(</span><span class=n>r</span><span class=p>.</span><span class=n>ack</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span><span class=o>%</span><span class=p>(</span><span class=n>MAX_SEQ</span><span class=o>+</span><span class=mi>1</span><span class=p>),</span><span class=n>next_frame_to_send</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                <span class=n>send_frame</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=p>(</span><span class=n>r</span><span class=p>.</span><span class=n>ack</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=p>(</span><span class=n>MAX_SEQ</span> <span class=o>+</span> <span class=mi>1</span><span class=p>),</span> <span class=n>frame_expected</span><span class=p>,</span> <span class=n>out_buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=p>(</span><span class=n>between</span><span class=p>(</span><span class=n>ack_expected</span><span class=p>,</span> <span class=n>r</span><span class=p>.</span><span class=n>ack</span><span class=p>,</span> <span class=n>next_frame_to_send</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>nbuffered</span> <span class=o>=</span> <span class=n>nbuffered</span> <span class=err>−</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=cm>/* handle piggybacked ack */</span>
</span></span><span class=line><span class=cl>                <span class=n>stop_timer</span><span class=p>(</span><span class=n>ack_expected</span> <span class=o>%</span> <span class=n>NR_BUFS</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=cm>/* frame arrived intact */</span>
</span></span><span class=line><span class=cl>                <span class=n>inc</span><span class=p>(</span><span class=n>ack_expected</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* advance lower edge of sender’s window */</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>cksum_err</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>no_nak</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>send_frame</span><span class=p>(</span><span class=n>nak</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>frame_expected</span><span class=p>,</span> <span class=n>out_buf</span><span class=p>);</span> <span class=cm>/* damaged frame */</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>timeout</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>send_frame</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>oldest_frame</span><span class=p>,</span> <span class=n>frame_expected</span><span class=p>,</span> <span class=n>out_buf</span><span class=p>);</span> <span class=cm>/* we timed out */</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>ack_timeout</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>send_frame</span><span class=p>(</span><span class=n>ack</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=n>frame_expected</span><span class=p>,</span> <span class=n>out_buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* ack timer expired; send ack */</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>nbuffered</span> <span class=o>&lt;</span> <span class=n>NR_BUFS</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>enable_network_layer</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=n>disable_network_layer</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=ch4-介质访问控制子层>ch4 介质访问控制子层<a hidden class=anchor aria-hidden=true href=#ch4-介质访问控制子层>¶</a></h2><blockquote><p>MAC</p><p>Medium Access Control</p></blockquote><p>在多用户之间分配单广播信道。FDM（频分复用）效率不高。信道速度 $C \rm{bps}$ ，每帧 $1/\mu\rm{bit}$ ，帧到达速度 $\lambda\rm{frames/sec}$ 。实际延时</p><p>$$T=\frac{1}{\mu C -\lambda}$$</p><p>如果信道等分 $N$ 份，延时大幅度增加。因此需要动态分配信道</p><p>$$T_N=\frac{1}{\mu (C/N) -(\lambda/N)}=\frac{N}{\mu C -\lambda}=NT$$</p><ol><li>流量独立，在 $\Delta_t$ 时间间隔中，帧数期望为 $\lambda\Delta_t$ （假定是泊松分布，而暂时不考虑突发流量）</li><li>单信道，核心，没有其他外部手段通信/核对信息</li><li>冲突可观察</li><li>时间连续/分槽 slotted</li><li>载波侦听 carrirer sense 或不听</li></ol><h3 id=多路访问协议>多路访问协议<a hidden class=anchor aria-hidden=true href=#多路访问协议>¶</a></h3><blockquote><p>contention system</p><p>竞争系统：共享信道，被同时发送帧而都失效</p></blockquote><p><img loading=lazy src=/assets/img/note/net/thorouput.png alt=thorouput></p><h4 id=aloha>ALOHA<a hidden class=anchor aria-hidden=true href=#aloha>¶</a></h4><p>有数据直接发，如果碰撞，在等待随机时间之后重发。</p><p>假设帧等长，发送用时$t$，帧产生服从泊松分布，一个“帧时”平均有 G 帧，实际产生 k 帧概率为</p><p>$$\mathrm{Pr[k]}=\frac{G^ke^{-G}}{k!}$$</p><p>一帧在$2t$中任意有 1 帧产生都会损毁，因此吞吐量最终为</p><p>$$S=Ge^{-2G}$$</p><p><img loading=lazy src=/assets/img/note/net/aloha.png alt=aloha></p><h4 id=分槽-aloha>分槽 ALOHA<a hidden class=anchor aria-hidden=true href=#分槽-aloha>¶</a></h4><p>要求每帧必须在时间槽开始时才能尝试发送，不能在任意时刻发送，只需要考虑单槽$t$内的碰撞。吞吐量</p><p>$$S=Ge^{-G}$$</p><p>1 帧需要 k 次尝试的几率为</p><p>$$P_k=e^{-G}(1-e^{-G})^{k-1}$$</p><p>传输次数期望为</p><p>$$E=\sum kP_k=\sum ke^{-G}(1-e^{-G})^{k-1}=e^G$$</p><h4 id=csma>CSMA<a hidden class=anchor aria-hidden=true href=#csma>¶</a></h4><blockquote><p>CSMA</p><p>Carrier Sense Multiple Access，载波侦听多路访问协议</p></blockquote><p>在发送自己帧之前，监听是否信道被占用，不占用再发送；如果占用</p><h5 id=persistent等到占用结束直接开始发>Persistent：等到占用结束直接开始发<a hidden class=anchor aria-hidden=true href=#persistent等到占用结束直接开始发>¶</a></h5><p>会在同时多站等发时候冲突</p><h5 id=nonpersistent>Nonpersistent<a hidden class=anchor aria-hidden=true href=#nonpersistent>¶</a></h5><p>等待一段时间后再检测</p><h5 id=p-persistent>p-persistent<a hidden class=anchor aria-hidden=true href=#p-persistent>¶</a></h5><p>针对分槽时间，每个槽如果空闲，以$p$的概率发，$1-p$的概率等下个时间槽。</p><p>如果有 k 个站需要传数据，站得发送的概率$P$为</p><p>$$P=kp(1-p)^{k-1}$$</p><p>在$p=\frac{1}{k}$时候有$P_\max$为</p><p>$$P_\max=(\frac{k-1}{k})^{k-1}$$</p><p>而且$k\to\infty$时候有$P\to\frac{1}{e}$。</p><h4 id=csmacd-collision-detection>CSMA/CD collision detection<a hidden class=anchor aria-hidden=true href=#csmacd-collision-detection>¶</a></h4><p>在发送前，信道空闲时候，发送竞争信号，竞争胜利者发送数据帧</p><p><img loading=lazy src=/assets/img/note/net/csmacd.png alt=CSMA/CD></p><h4 id=csmaca-collision-avoidance>CSMA/CA collision avoidance<a hidden class=anchor aria-hidden=true href=#csmaca-collision-avoidance>¶</a></h4><blockquote><p>binary exponential backoff</p><p>二进制指数后退。在$i$次碰撞后，在<a href=#p-persistent>p-persistent CSMA</a>基础上改为等待$0\sim2^i-1$个时间槽</p></blockquote><p>实际中，有时间槽次数上限和碰撞次数上限</p><p>竞争时间间隔为$j$的概率</p><p>$$P_{t=jT_0}=P(1-P)^{j-1}$$</p><p>每次竞争平均时间槽数为</p><p>$$E=\sum_{j=0} jP(1-P)^{j-1}=\frac{1}{P}$$</p><h4 id=bit-map-位图协议-无冲突>Bit-Map 位图协议 无冲突<a hidden class=anchor aria-hidden=true href=#bit-map-位图协议-无冲突>¶</a></h4><p>信道中有公共信息广播时间。在该时间里，每个站有一个槽，发送信息表示接下来需要发送数据帧；沉默表示接下来不发。然后站按照申请的结果发。平均等待$N$个槽时间</p><h4 id=token-ring-令牌环-无冲突>token ring 令牌环 无冲突<a hidden class=anchor aria-hidden=true href=#token-ring-令牌环-无冲突>¶</a></h4><p>所有站连接成一个单环结构，传递令牌。得到令牌的发数据，发完继续传；如果不用发数据直接向下传</p><h4 id=binary-countdown-二进制计数-无冲突>binary countdown 二进制计数 无冲突<a hidden class=anchor aria-hidden=true href=#binary-countdown-二进制计数-无冲突>¶</a></h4><p>信道中有公共信息广播时间，所有站监听。如果需要发数据，从高位开始，在对应时间槽中发送自己优先级（唯一，二进制表示）消息，消息之间是<strong>或</strong>关系。只有知道自己是优先级最高的才能接下来发送。竞争用时$\log_2N$</p><h4 id=the-adaptive-tree-walk-protocol-自适应树遍历协议>The Adaptive Tree Walk Protocol 自适应树遍历协议<a hidden class=anchor aria-hidden=true href=#the-adaptive-tree-walk-protocol-自适应树遍历协议>¶</a></h4><p>注意到，如果竞争站的数目$k$比较小时候，<a href=#p-persistent>p-persistent CSMA 的获得信道概率</a>会上升。因此可以通过分组减少竞争，极大提升信道使用效果</p><p>自适应树中，将站看作是二叉树的叶节点，从根节点开始搜索。如果某个节点冲突，向下探寻左、右子节点；如果左节点不冲突了，给左节点下需求站发送数据；下一时间槽给右节点的站。在公共广播期间，站按照自身的父节点被搜索到的顺序竞争时间槽。</p><p>如果$q$个站随机均匀分布，在让每个槽中参与竞争的平均站数为 1 时，得到最优树高$1+\log_2q$</p><h3 id=以太网>以太网<a hidden class=anchor aria-hidden=true href=#以太网>¶</a></h3><h4 id=设施>设施<a hidden class=anchor aria-hidden=true href=#设施>¶</a></h4><table><thead><tr><th></th><th>hub 集线器</th><th>switch 交换机</th></tr></thead><tbody><tr><td>pro</td><td>易排错</td><td>扩容；无冲突；安全</td></tr><tr><td>con</td><td>不能扩容，逻辑上等同单线缆</td><td>自带 buffer 防止同时发送端口</td></tr></tbody></table><h2 id=ch5-网络层>ch5 网络层<a hidden class=anchor aria-hidden=true href=#ch5-网络层>¶</a></h2><ol><li>向上提供的服务应该独立于路由器技术</li><li>应该向传输层屏蔽路由器的数量、类型和拓扑关系</li><li>传输层可用的网络地址应该有一个统一编址方案，甚至可以跨越 LAN 和 WAN</li></ol><blockquote><p>datagram</p><p>数据报网络，所有的数据包都被独立地注入到网络中，并且每个数据包独立路由，不需要提前建立任何设置</p></blockquote><blockquote><p>virtual circuit</p><p>虚电路网络，在发送数据包之前，必须首先建立起一条从源路由器到目标路由器之间的路径</p></blockquote><table><thead><tr><th></th><th>datagram</th><th style=text-align:left>virtual-circuit</th></tr></thead><tbody><tr><td>线路初始化</td><td>不需要</td><td style=text-align:left>需要</td></tr><tr><td>寻址</td><td>包带有源和目标地址</td><td style=text-align:left>包带有短 VC 号</td></tr><tr><td>状态信息</td><td>路由不包含连接信息</td><td style=text-align:left>每条虚电路（VC）需要路由记录每个连接</td></tr><tr><td>路由</td><td>每个包单独路由</td><td style=text-align:left>VC 设置时候路由，包遵守</td></tr><tr><td>路由失效影响</td><td>无，除了因为崩溃丢的包</td><td style=text-align:left>故障路由相关 VC 均中断</td></tr><tr><td>服务质量</td><td>困难</td><td style=text-align:left>简单，如果建立 VC 时候资源足够</td></tr><tr><td>拥塞控制</td><td>困难</td><td style=text-align:left>简单，如果建立 VC 时候资源足够</td></tr></tbody></table><h3 id=路由算法>路由算法<a hidden class=anchor aria-hidden=true href=#路由算法>¶</a></h3><blockquote><p>routing algorithm</p><p>路由算法。网络层软件决定入境数据包在哪条线外发</p></blockquote><blockquote><p>optimality principle</p><p>路由最优化原理。如果路由 J 在 I 到 K 最优路径，那么 J 到 K 最优路径也是同样的路由</p></blockquote><blockquote><p>sink tree</p><p>汇集树。从所有的源到一个指定目标的最优路径的集合构成了一棵以目标节点为根的树/DAG（有向无环图）</p></blockquote><blockquote><p>spanning tree</p><p>包含所有路由器的树，不一定是最优路径（和汇集树相区别）</p></blockquote><h4 id=dijstra-最短路径>Dijstra 最短路径<a hidden class=anchor aria-hidden=true href=#dijstra-最短路径>¶</a></h4><p>每次找到距离源距离最近（距离=到已发现集合的某点距离+该点距离源距离）的新节点，加入发现集合</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define MAX_NODES 1024
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/* maximum number of nodes */</span>
</span></span><span class=line><span class=cl><span class=cp>#define INFINITY 1000000000
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/* a number larger than every maximum path */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=n>dist</span><span class=p>[</span><span class=n>MAX_NODES</span><span class=p>][</span><span class=n>MAX_NODES</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=cm>/* dist[i][j] is the distance from i to j */</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>shortest</span> <span class=nf>path</span><span class=p>(</span><span class=kt>int</span> <span class=n>s</span><span class=p>,</span> <span class=kt>int</span> <span class=n>t</span><span class=p>,</span> <span class=kt>int</span> <span class=n>path</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>state</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* the path being worked on */</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>predecessor</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* previous node */</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>length</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* length from source to this node */</span>
</span></span><span class=line><span class=cl>        <span class=k>enum</span> <span class=p>{</span><span class=n>permanent</span><span class=p>,</span> <span class=n>tentative</span><span class=p>}</span> <span class=n>label</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* label state */</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=n>state</span><span class=p>[</span><span class=n>MAX_NODES</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=n>k</span><span class=p>,</span> <span class=n>min</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>state</span> <span class=o>*</span><span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>p</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>state</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span> <span class=n>p</span> <span class=o>&lt;</span> <span class=o>&amp;</span><span class=n>state</span><span class=p>[</span><span class=n>n</span><span class=p>];</span> <span class=n>p</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* initialize state */</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span><span class=o>-&gt;</span><span class=n>predecessor</span> <span class=o>=</span> <span class=err>−</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span><span class=o>-&gt;</span><span class=n>length</span> <span class=o>=</span> <span class=n>INFINITY</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span><span class=o>-&gt;</span><span class=n>label</span> <span class=o>=</span> <span class=n>tentative</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>state</span><span class=p>[</span><span class=n>t</span><span class=p>].</span><span class=n>length</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>state</span><span class=p>[</span><span class=n>t</span><span class=p>].</span><span class=n>label</span> <span class=o>=</span> <span class=n>permanent</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>k</span> <span class=o>=</span> <span class=n>t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* k is the initial working node */</span>
</span></span><span class=line><span class=cl>    <span class=k>do</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* Is there a better path from k? */</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span> <span class=c1>//n node
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=p>(</span><span class=n>dist</span><span class=p>[</span><span class=n>k</span><span class=p>][</span><span class=n>i</span><span class=p>]</span> <span class=o>!=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>state</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>label</span> <span class=o>==</span> <span class=n>tentative</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>state</span><span class=p>[</span><span class=n>k</span><span class=p>].</span><span class=n>length</span> <span class=o>+</span> <span class=n>dist</span><span class=p>[</span><span class=n>k</span><span class=p>][</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>state</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>length</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>state</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>predecessor</span> <span class=o>=</span> <span class=n>k</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=n>state</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>length</span> <span class=o>=</span> <span class=n>state</span><span class=p>[</span><span class=n>k</span><span class=p>].</span><span class=n>length</span> <span class=o>+</span> <span class=n>dist</span><span class=p>[</span><span class=n>k</span><span class=p>][</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* Find the tentatively labeled node with the smallest label. */</span>
</span></span><span class=line><span class=cl>        <span class=n>k</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>min</span> <span class=o>=</span> <span class=n>INFINITY</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>state</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>label</span> <span class=o>==</span> <span class=n>tentative</span> <span class=o>&amp;&amp;</span> <span class=n>state</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>length</span> <span class=o>&lt;</span> <span class=n>min</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>min</span> <span class=o>=</span> <span class=n>state</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>length</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>k</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>state</span><span class=p>[</span><span class=n>k</span><span class=p>].</span><span class=n>label</span> <span class=o>=</span> <span class=n>permanent</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=n>k</span> <span class=o>!=</span> <span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Copy the path into the output array. */</span>
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>k</span> <span class=o>=</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>do</span> <span class=p>{</span><span class=n>path</span><span class=p>[</span><span class=n>i</span><span class=o>++</span><span class=p>]</span> <span class=o>=</span> <span class=n>k</span><span class=p>;</span> <span class=n>k</span> <span class=o>=</span> <span class=n>state</span><span class=p>[</span><span class=n>k</span><span class=p>].</span><span class=n>predecessor</span><span class=p>;</span> <span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=n>k</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=flooding-泛洪>flooding 泛洪<a hidden class=anchor aria-hidden=true href=#flooding-泛洪>¶</a></h4><p>每一个入境数据包发送到除了该数据包到达的那条线路以外的每条出境线路</p><ol><li>泛洪包带有寿命，计数减到 0 之后不再发</li><li>追踪泛洪包防止二次发送。泛洪包带序号，一个序号对应一次泛洪，一次泛洪只发送一次</li></ol><ul><li>保证广播</li><li>robust</li></ul><h4 id=distance-vector-routing-距离向量路由>distance vector routing 距离向量路由<a hidden class=anchor aria-hidden=true href=#distance-vector-routing-距离向量路由>¶</a></h4><p>每个路由器维护一张表（即一个矢量)，表中列出了当前已知的到每个目标的最佳距离，以及所使用的链路。这些表通过邻居之间相互交换信息而不断被更新，最终每个路由器都了解到达每个目的地的最佳链路。</p><p>又名 Bellman-Fold 算法</p><blockquote><p>Count-to-Infinity</p><p>无穷计数问题。坏消息传递慢，距离每次增 1 而已（没有一个路由器具有一个比它所有邻居的最小值还大于 1 的值，从邻居获得道路信息不包含自身是否在道路上）</p></blockquote><h4 id=link-state-routing-链路状态路由>link state routing 链路状态路由<a hidden class=anchor aria-hidden=true href=#link-state-routing-链路状态路由>¶</a></h4><ol><li>发现它的邻居节点，并了解其网络地址</li><li>设置到每个邻居节点的距离或者成本度量值</li><li>构造一个包含所有刚刚获知的链路信息包</li><li>将这个包发送给所有其他的路由器，并接收来自所有其他路由器的信息包</li><li>计算出到每个其他路由器的最短路径</li></ol><p>每个路由都知道网络拓扑结构，每个路由自行完成<a href=#dijstra-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84>Dijstra 最短路径算法</a></p><h4 id=层次路由>层次路由<a hidden class=anchor aria-hidden=true href=#层次路由>¶</a></h4><p>分层。可以证明对于 $N$ 路由数目网络最优层数 $\ln N$，每个路由器查找表条目 $e\ln N$。</p><h4 id=广播路由>广播路由<a hidden class=anchor aria-hidden=true href=#广播路由>¶</a></h4><blockquote><p>multidestination routing</p><p>多目标路由。每个数据包包含一组目标地址，路由对于某条线上转发时候只保留线连接区域地址，直到只发给 1 个目标地址</p></blockquote><blockquote><p>reverse path forwarding</p><p>逆向路径转发。检测数据包是否来自汇集树（或者放宽为优化的生成树），否则丢弃，结合<a href=#flooding-%E6%B3%9B%E6%B4%AA>泛洪</a></p></blockquote><ol><li>每个路由单独发包</li><li><a href=#flooding-%E6%B3%9B%E6%B4%AA>泛洪</a></li><li>多目标路由</li></ol><h3 id=组播路由>组播路由<a hidden class=anchor aria-hidden=true href=#组播路由>¶</a></h3><blockquote><p>core-based tree</p><p>基于核心树。只对核心（core/root）建生成树</p></blockquote><ol><li>干脆 <a href=#%E5%B9%BF%E6%92%AD%E8%B7%AF%E7%94%B1>广播路由</a></li><li>修建生成树，按需要传播</li><li>其他路由先发到核心，核心走核心树</li></ol><h4 id=anycast-routing-选播路由>anycast routing 选播路由<a hidden class=anchor aria-hidden=true href=#anycast-routing-选播路由>¶</a></h4><blockquote><p>anycast</p><p>数据包发送到特定一个组中最近的一个路由</p></blockquote><h3 id=拥塞控制算法>拥塞控制算法<a hidden class=anchor aria-hidden=true href=#拥塞控制算法>¶</a></h3><blockquote><p>bufferfloat</p><p>路由内存充足反而容易导致拥塞。数据包（本来会因为内存不足丢弃）排到队列前面时，它们早己经超时（重复地）并且它们的副本也己经发送</p></blockquote><p><img loading=lazy src=/assets/img/note/net/congestc.png alt="congestion control"></p><h4 id=traffic-aware-routing>Traffic-Aware Routing<a hidden class=anchor aria-hidden=true href=#traffic-aware-routing>¶</a></h4><p>流量感知路由。将负载考虑到路由选择上，但不能直接使用流量调整，防止路由选择波动。</p><h4 id=admission-control>admission control<a hidden class=anchor aria-hidden=true href=#admission-control>¶</a></h4><p>准入控制。只能针对虚电路网络，在可承担负载情况下才建立新连接。</p><h4 id=load-shedding>load shedding<a hidden class=anchor aria-hidden=true href=#load-shedding>¶</a></h4><p>负载脱落。直接抛弃负载保证不拥塞。抛弃优先级可以结合流量费用设定。</p><blockquote><p>wine</p><p>旧数据包保留：如文件传输</p></blockquote><blockquote><p>milk</p><p>新数据包保留：如流媒体</p></blockquote><h4 id=traffic-shaping>traffic shaping<a hidden class=anchor aria-hidden=true href=#traffic-shaping>¶</a></h4><p>流量整形。</p><p>桶容量 $B$ ，数据速率 $R$</p><blockquote><p>leaky bucket</p><p>漏桶。向缓冲区发包，包以 $R$ 离开缓冲区</p></blockquote><blockquote><p>token bucket</p><p>令牌桶。令牌以 $R$ 速度累计， 得到令牌才能发包</p></blockquote><p>流量突发时长 $S$ ，突发产生速率 $M$ ，则桶算法有</p><p>$$B+RS=MS$$</p><p>还可以级联桶，调控平均速率和突发最大速率。</p><p><img loading=lazy src=/assets/img/note/net/bucket.png alt="bucket algorithm"></p><h4 id=active-queue-management-主动队列管理>active queue management 主动队列管理<a hidden class=anchor aria-hidden=true href=#active-queue-management-主动队列管理>¶</a></h4><p>主动管理负载避免拥塞，路由监控自己使用的资源。期待延迟为 $d$ ，队列长度 $s$ ，有关系式</p><p>$$d_{new}=\alpha d_{old}+(1-\alpha)s$$</p><blockquote><p>Exponentially Weighted Moving Average</p><p>EWMA，指数加权移动平均。 $\alpha$ 是路由遗忘历史信息的常数。等同于低通滤波器。 期待延迟 $d$ 超过阈值预示拥塞发生</p></blockquote><h4 id=random-early-detection-随机早期检测>Random Early Detection 随机早期检测<a hidden class=anchor aria-hidden=true href=#random-early-detection-随机早期检测>¶</a></h4><p>RED。因为路由难以得到显式信息通知拥塞，只有包丢失是容易感知的，但是包丢失对于避免拥塞太晚了。当某条链路上的平均队列长度超过某个阈值时，该链路就被认为即将拥塞，因此路由器随机丢弃一小部分数据包。隐含传递拥塞信号</p><h4 id=choke-packets>choke packets<a hidden class=anchor aria-hidden=true href=#choke-packets>¶</a></h4><p>直接向发送方回传拥塞发生的通知数据包。</p><h4 id=explicit-congestion-notification-显式拥塞通知>Explicit Congestion Notification 显式拥塞通知<a hidden class=anchor aria-hidden=true href=#explicit-congestion-notification-显式拥塞通知>¶</a></h4><p>ECN。不单独<a href=#choke-packets>发拥塞通知包</a>，在包中间标志位标记拥塞信息。</p><h4 id=hop-by-hop-backpressure>Hop-by-Hop Backpressure<a hidden class=anchor aria-hidden=true href=#hop-by-hop-backpressure>¶</a></h4><p>防止路程过长，拥塞通知延迟太久。同时用<a href=#choke-packets>choke packets（拥塞通知包）</a>通知中间路由控制流量。</p><h2 id=ch6-传输层>ch6 传输层<a hidden class=anchor aria-hidden=true href=#ch6-传输层>¶</a></h2><p>传输层主要跑在用户机上，而<a href=#ch5-%E7%BD%91%E7%BB%9C%E5%B1%82>网络层</a>跑在路由器上</p><h3 id=socket>Socket<a hidden class=anchor aria-hidden=true href=#socket>¶</a></h3><h4 id=原语>原语<a hidden class=anchor aria-hidden=true href=#原语>¶</a></h4><table><thead><tr><th>原语</th><th>含义</th></tr></thead><tbody><tr><td>socket</td><td>建立一个新通讯端点</td></tr><tr><td>bind</td><td>将 socket 与一个本地地址关联</td></tr><tr><td>listen</td><td>声明愿意接受连接；给出队列长度</td></tr><tr><td>accept</td><td>被动创建一个入境连接</td></tr><tr><td>connect</td><td>主动尝试创建连接</td></tr><tr><td>send</td><td>通过连接传输数据</td></tr><tr><td>receive</td><td>通过连接接受数据</td></tr><tr><td>close</td><td>断开连接</td></tr></tbody></table><h4 id=文件传输程序>文件传输程序<a hidden class=anchor aria-hidden=true href=#文件传输程序>¶</a></h4><h5 id=客户端>客户端<a hidden class=anchor aria-hidden=true href=#客户端>¶</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/* This page contains a client program that can request a file from the server program
</span></span></span><span class=line><span class=cl><span class=cm> * on the next page. The server responds by sending the whole file.
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;netdb.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;netinet/in.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/socket.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define SERVER_PORT 8080
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/* arbitrar y, but client &amp; server must agree */</span>
</span></span><span class=line><span class=cl><span class=cp>#define BUF_SIZE 4096
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/* block transfer size */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>**</span> <span class=n>argv</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>c</span><span class=p>,</span> <span class=n>s</span><span class=p>,</span> <span class=n>bytes</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=n>BUF_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* buffer for incoming file */</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>hostent</span><span class=o>*</span> <span class=n>h</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* info about server */</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>sockaddr</span> <span class=n>in_channel</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* holds IP address */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>argc</span> <span class=o>!=</span> <span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Usage: client server-name file-name&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>h</span> <span class=o>=</span> <span class=n>gethostbyname</span><span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* look up host’s IP address */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>h</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;gethostbyname failed to locate %s&#34;</span><span class=p>,</span> <span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span> <span class=o>=</span> <span class=n>socket</span><span class=p>(</span><span class=n>PF_INET</span><span class=p>,</span> <span class=n>SOCK_STREAM</span><span class=p>,</span> <span class=n>IPPROTO_TCP</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>s</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;socket call failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>memset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>channel</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>channel</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>channel</span><span class=p>.</span><span class=n>sin_family</span> <span class=o>=</span> <span class=n>AF_INET</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>memcpy</span><span class=p>(</span><span class=o>&amp;</span><span class=n>channel</span><span class=p>.</span><span class=n>sin_addr</span><span class=p>.</span><span class=n>s_addr</span><span class=p>,</span> <span class=n>h</span><span class=o>-&gt;</span><span class=n>h_addr</span><span class=p>,</span> <span class=n>h</span><span class=o>-&gt;</span><span class=n>h_length</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>channel</span><span class=p>.</span><span class=n>sin_port</span> <span class=o>=</span> <span class=n>htons</span><span class=p>(</span><span class=n>SERVER_PORT</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>c</span> <span class=o>=</span> <span class=n>connect</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=p>(</span><span class=k>struct</span> <span class=nc>sockaddr</span><span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>channel</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>channel</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>c</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;connect failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Connection is now established. Send file name including 0 byte at end. */</span>
</span></span><span class=line><span class=cl>    <span class=n>write</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>argv</span><span class=p>[</span><span class=mi>2</span><span class=p>],</span> <span class=n>strlen</span><span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=mi>2</span><span class=p>])</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Go get the file and write it to standard output. */</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>bytes</span> <span class=o>=</span> <span class=n>read</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>BUF_SIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* read from socket */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>bytes</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* check for end of file */</span>
</span></span><span class=line><span class=cl>        <span class=n>write</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>bytes</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* wr ite to standard output */</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h5 id=服务器端>服务器端<a hidden class=anchor aria-hidden=true href=#服务器端>¶</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span><span class=lnt>79
</span><span class=lnt>80
</span><span class=lnt>81
</span><span class=lnt>82
</span><span class=lnt>83
</span><span class=lnt>84
</span><span class=lnt>85
</span><span class=lnt>86
</span><span class=lnt>87
</span><span class=lnt>88
</span><span class=lnt>89
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/* This is the server code */</span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;netdb.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;netinet/in.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/fcntl.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/socket.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define SERVER_PORT 8080
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/* arbitrar y, but client &amp; server must agree */</span>
</span></span><span class=line><span class=cl><span class=cp>#define BUF_SIZE 4096
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/* block transfer size */</span>
</span></span><span class=line><span class=cl><span class=cp>#define QUEUE_SIZE 10
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>s</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>l</span><span class=p>,</span> <span class=n>fd</span><span class=p>,</span> <span class=n>sa</span><span class=p>,</span> <span class=n>bytes</span><span class=p>,</span> <span class=n>on</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=n>BUF_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* buffer for outgoing file */</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>sockaddr_in</span> <span class=n>channel</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* holds IP address */</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Build address structure to bind to socket. */</span>
</span></span><span class=line><span class=cl>    <span class=n>memset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>channel</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>channel</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* zero channel */</span>
</span></span><span class=line><span class=cl>    <span class=n>channel</span><span class=p>.</span><span class=n>sin_family</span> <span class=o>=</span> <span class=n>AF_INET</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>channel</span><span class=p>.</span><span class=n>sin_addr</span><span class=p>.</span><span class=n>s_addr</span> <span class=o>=</span> <span class=n>htonl</span><span class=p>(</span><span class=n>INADDR_ANY</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>channel</span><span class=p>.</span><span class=n>sin</span> <span class=o>+</span> <span class=n>port</span> <span class=o>=</span> <span class=n>htons</span><span class=p>(</span><span class=n>SERVER_PORT</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Passive open. Wait for connection. */</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span> <span class=o>=</span> <span class=n>socket</span><span class=p>(</span><span class=n>AF_INET</span><span class=p>,</span> <span class=n>SOCK_STREAM</span><span class=p>,</span> <span class=n>IPPROTO_TCP</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* create socket */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>s</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;socket call failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>setsockopt</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>SOL_SOCKET</span><span class=p>,</span> <span class=n>SO_REUSEADDR</span><span class=p>,</span> <span class=p>(</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>on</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>on</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span> <span class=o>=</span> <span class=n>bind</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=p>(</span><span class=k>struct</span> <span class=nc>sockaddr</span><span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>channel</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>channel</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>b</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;bind failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>l</span> <span class=o>=</span> <span class=n>listen</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>QUEUE_SIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* specify queue size */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>l</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;listen failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Socket is now set up and bound. Wait for connection and process it. */</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>sa</span> <span class=o>=</span> <span class=n>accept</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* block for connection request */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>sa</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>printf</span><span class=p>(</span><span class=s>&#34;accept failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>read</span><span class=p>(</span><span class=n>sa</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>BUF_SIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* read file name from socket */</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* Get and return the file. */</span>
</span></span><span class=line><span class=cl>        <span class=n>fd</span> <span class=o>=</span> <span class=n>open</span><span class=p>(</span><span class=n>buf</span><span class=p>,</span> <span class=n>O_RDONLY</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* open the file to be sent back */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>fd</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>printf</span><span class=p>(</span><span class=s>&#34;open failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>bytes</span> <span class=o>=</span> <span class=n>read</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>BUF_SIZE</span><span class=p>);</span> <span class=cm>/* read from file */</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>bytes</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* check for end of file */</span>
</span></span><span class=line><span class=cl>            <span class=n>write</span><span class=p>(</span><span class=n>sa</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>bytes</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* wr ite bytes to socket */</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>close</span><span class=p>(</span><span class=n>fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* close file */</span>
</span></span><span class=line><span class=cl>        <span class=n>close</span><span class=p>(</span><span class=n>sa</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* close connection */</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://livypad.github.io/tags/%E6%95%99%E7%A8%8B/>教程</a></li><li><a href=https://livypad.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/>读书笔记</a></li></ul><nav class=paginav><a class=prev href=https://livypad.github.io/post/2022-08-31-ddia/><span class=title>« Prev Page</span><br><span>笔记：Designing data-intensive applications(开始记录）</span></a>
<a class=next href=https://livypad.github.io/post/2022-08-15-empathy/><span class=title>Next Page »</span><br><span>启动共情的责任人</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://livypad.github.io>zhh's blog</a></span><span style=display:inline-block;margin-left:1em>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
    <a href=https://github.com/reorx/hugo-PaperModX/ rel=noopener target=_blank>PaperModX</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>MathJax={tex:{inlineMath:[["$","$"]],displayMath:[["$$","$$"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}},svg:{fontCache:"global"}}</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js></script>
<script>(function(){const t=""=="1";if(t)return;let e=document.getElementById("theme-toggle");e.removeEventListener("click",toggleThemeListener),e.addEventListener("click",toggleThemeListener)})()</script><script>(function(){let e=document.getElementById("menu");e&&(e.scrollLeft=localStorage.getItem("menu-scroll-position"),e.onscroll=function(){localStorage.setItem("menu-scroll-position",e.scrollLeft)});const t=""=="1",n=""=="1";if(window.matchMedia("(prefers-reduced-motion: reduce)").matches||t||n)return;document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})})()</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>if(window.scrollListeners)for(const e of scrollListeners)window.removeEventListener("scroll",e);window.scrollListeners=[]</script><script src=/js/medium-zoom.min.js data-no-instant></script>
<script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>(function(){const r="1"=="1";if(!r)return;if(!document.querySelector(".toc")){console.log("no toc found, ignore toc scroll");return}const c=window.scrollListeners,n=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id]"),s="active";let e=n[0];o(e).classList.add(s);const a=()=>{const t=[];for(const e of n)if(l(e)<5)t.push(e);else break;t.length>0?newActiveHeading=t[t.length-1]:newActiveHeading=n[0],e!=newActiveHeading&&(o(e).classList.remove(s),e=newActiveHeading,o(e).classList.add(s))};let t=null;const i=()=>{t!==null&&clearTimeout(t),t=setTimeout(a,50)};window.addEventListener("scroll",i,!1),c.push(i);function o(e){const t=encodeURI(e.getAttribute("id")).toLowerCase();return document.querySelector(`.toc ul li a[href="#${t}"]`)}function l(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect();return t.top}})()</script></body></html>