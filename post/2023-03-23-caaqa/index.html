<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>笔记：Computer Architecture A Quantatative Approach（更新到第2/A章） | zhh's blog</title><meta name=keywords content="教程,读书笔记"><meta name=description content="Computer architecture: a quantitative approach ch 1 Fundamentals ch 2/B Memory Hierarchy Design 基础知识 cache 性能优化 虚拟存储 virtual machine Fallacy Pitfall ch 3/C Instruction-Level Parallelism and Its Exploitation 5 级流水 中断 ch A Instruction Set Principles ISA 特性 编译器优化 ISA 统计和对应的 RISC-V 设计 Fallacy Pitfall Computer architecture:"><meta name=author content="livypad"><link rel=canonical href=https://livypad.github.io/post/2023-03-23-caaqa/><link crossorigin=anonymous href=/assets/css/stylesheet.min.7ca4c3dd9394a71fbe69a066b9fbc3dcfe7fb50ce978b051497ffe24c8e1c49a.css integrity="sha256-fKTD3ZOUpx++aaBmufvD3P5/tQzpeLBRSX/+JMjhxJo=" rel="preload stylesheet" as=style><link rel=icon href=https://livypad.github.io/assets/icon/favicon.ico><link rel=apple-touch-icon href=https://livypad.github.io/assets/icon/apple-touch-icon.png><link rel=manifest href=https://livypad.github.io/assets/icon/site.webmanifest><meta name=twitter:title content="笔记：Computer Architecture A Quantatative Approach（更新到第2/A章） | zhh's blog"><meta name=twitter:description content="Computer architecture: a quantitative approach ch 1 Fundamentals ch 2/B Memory Hierarchy Design 基础知识 cache 性能优化 虚拟存储 virtual machine Fallacy Pitfall ch 3/C Instruction-Level Parallelism and Its Exploitation 5 级流水 中断 ch A Instruction Set Principles ISA 特性 编译器优化 ISA 统计和对应的 RISC-V 设计 Fallacy Pitfall Computer architecture:"><meta name=twitter:site content="@novoreorx"><meta name=twitter:creator content="@novoreorx"><meta property="og:title" content><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary-bg:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript></head><body id=top><script data-no-instant>function switchTheme(e){switch(e){case"light":document.body.classList.remove("dark");break;case"dark":document.body.classList.add("dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")}}function isDarkTheme(){return document.body.className.includes("dark")}function getPrefTheme(){return localStorage.getItem("pref-theme")}function setPrefTheme(e){switchTheme(e),localStorage.setItem("pref-theme",e)}const toggleThemeCallbacks={};toggleThemeCallbacks.main=e=>{setPrefTheme(e?"light":"dark")},window.addEventListener("toggle-theme",function(){const e=isDarkTheme();for(const t in toggleThemeCallbacks)toggleThemeCallbacks[t](e)});function toggleThemeListener(){window.dispatchEvent(new CustomEvent("toggle-theme"))}</script><script>(function(){const t="auto",e=getPrefTheme(),n=e||t;switchTheme(n)})()</script><header class=header><nav class=nav><div class=logo><a href=https://livypad.github.io accesskey=h title="zhh's blog (Alt + H)">zhh's blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://livypad.github.io/about/ title=About>About</a></li><li><a href=https://livypad.github.io/tags/ title=Tags>Tags</a></li><li><a href=https://livypad.github.io/archives/ title=Archive>Archive</a></li><li><a href=https://livypad.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/ title=Note>Note</a></li></ul></nav></header><main class="main post"><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://livypad.github.io>Home</a>&nbsp;»&nbsp;<a href=https://livypad.github.io/post/>Posts</a></div><h1 class=post-title>笔记：Computer Architecture A Quantatative Approach（更新到第2/A章）</h1><div class=post-meta><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>2023-03-23</span></span><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<a href=https://livypad.github.io/tags/%E6%95%99%E7%A8%8B/>教程 </a><a href=https://livypad.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/>读书笔记</a>
</span><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select:text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z" style="user-select:text"/><polyline points="14 2 14 8 20 8" style="user-select:text"/><line x1="16" y1="13" x2="8" y2="13" style="user-select:text"/><line x1="16" y1="17" x2="8" y2="17" style="user-select:text"/><polyline points="10 9 9 9 8 9" style="user-select:text"/></svg><span>3854 words</span></span><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>8 min</span></span></div></header><div class="toc side left"><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#computer-architecture-a-quantitative-approach aria-label="Computer architecture: a quantitative approach">Computer architecture: a quantitative approach</a><ul><li><a href=#ch-1-fundamentals aria-label="ch 1 Fundamentals">ch 1 Fundamentals</a></li><li><a href=#ch-2b-memory-hierarchy-design aria-label="ch 2/B Memory Hierarchy Design">ch 2/B Memory Hierarchy Design</a><ul><li><a href=#%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86 aria-label=基础知识>基础知识</a></li><li><a href=#cache-%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96 aria-label="cache 性能优化">cache 性能优化</a></li><li><a href=#%e8%99%9a%e6%8b%9f%e5%ad%98%e5%82%a8 aria-label=虚拟存储>虚拟存储</a></li><li><a href=#virtual-machine aria-label="virtual machine">virtual machine</a></li><li><a href=#fallacy aria-label=Fallacy>Fallacy</a></li><li><a href=#pitfall aria-label=Pitfall>Pitfall</a></li></ul></li><li><a href=#ch-3c-instruction-level-parallelism-and-its-exploitation aria-label="ch 3/C Instruction-Level Parallelism and Its Exploitation">ch 3/C Instruction-Level Parallelism and Its Exploitation</a><ul><li><a href=#5-%e7%ba%a7%e6%b5%81%e6%b0%b4 aria-label="5 级流水">5 级流水</a></li><li><a href=#%e4%b8%ad%e6%96%ad aria-label=中断>中断</a></li></ul></li><li><a href=#ch-a-instruction-set-principles aria-label="ch A Instruction Set Principles">ch A Instruction Set Principles</a><ul><li><a href=#isa-%e7%89%b9%e6%80%a7 aria-label="ISA 特性">ISA 特性</a></li><li><a href=#%e7%bc%96%e8%af%91%e5%99%a8%e4%bc%98%e5%8c%96 aria-label=编译器优化>编译器优化</a></li><li><a href=#isa-%e7%bb%9f%e8%ae%a1%e5%92%8c%e5%af%b9%e5%ba%94%e7%9a%84-risc-v-%e8%ae%be%e8%ae%a1 aria-label="ISA 统计和对应的 RISC-V 设计">ISA 统计和对应的 RISC-V 设计</a></li><li><a href=#fallacy-1 aria-label=Fallacy>Fallacy</a></li><li><a href=#pitfall-1 aria-label=Pitfall>Pitfall</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><ul><li><a href=#computer-architecture-a-quantitative-approach>Computer architecture: a quantitative approach</a><ul><li><a href=#ch-1-fundamentals>ch 1 Fundamentals</a></li><li><a href=#ch-2b-memory-hierarchy-design>ch 2/B Memory Hierarchy Design</a><ul><li><a href=#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86>基础知识</a></li><li><a href=#cache-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96>cache 性能优化</a></li><li><a href=#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8>虚拟存储</a></li><li><a href=#virtual-machine>virtual machine</a></li><li><a href=#fallacy>Fallacy</a></li><li><a href=#pitfall>Pitfall</a></li></ul></li><li><a href=#ch-3c-instruction-level-parallelism-and-its-exploitation>ch 3/C Instruction-Level Parallelism and Its Exploitation</a><ul><li><a href=#5-%E7%BA%A7%E6%B5%81%E6%B0%B4>5 级流水</a></li><li><a href=#%E4%B8%AD%E6%96%AD>中断</a></li></ul></li><li><a href=#ch-a-instruction-set-principles>ch A Instruction Set Principles</a><ul><li><a href=#isa-%E7%89%B9%E6%80%A7>ISA 特性</a></li><li><a href=#%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96>编译器优化</a></li><li><a href=#isa-%E7%BB%9F%E8%AE%A1%E5%92%8C%E5%AF%B9%E5%BA%94%E7%9A%84-risc-v-%E8%AE%BE%E8%AE%A1>ISA 统计和对应的 RISC-V 设计</a></li><li><a href=#fallacy-1>Fallacy</a></li><li><a href=#pitfall-1>Pitfall</a></li></ul></li></ul></li></ul><h1 id=computer-architecture-a-quantitative-approach>Computer architecture: a quantitative approach<a hidden class=anchor aria-hidden=true href=#computer-architecture-a-quantitative-approach>¶</a></h1><h2 id=ch-1-fundamentals>ch 1 Fundamentals<a hidden class=anchor aria-hidden=true href=#ch-1-fundamentals>¶</a></h2><ul><li>Internet of Things/Embedded Computers：缺乏量化基准</li><li>Personal Mobile Device：soft real time（对实时性的要求），功耗优化</li><li>Desktop Computing：性价比</li><li>Servers：可用性，可拓展性，有效吞吐</li><li>Warehouse：性价比，功耗</li></ul><h2 id=ch-2b-memory-hierarchy-design>ch 2/B Memory Hierarchy Design<a hidden class=anchor aria-hidden=true href=#ch-2b-memory-hierarchy-design>¶</a></h2><h3 id=基础知识>基础知识<a hidden class=anchor aria-hidden=true href=#基础知识>¶</a></h3><p>cache 基本配置有</p><ol><li><p>block 可放置位置</p><ol><li>direct mapped：直接映射，$(Block\ Address)\mod(Number\ of\ blocks)$</li><li>fully associative：全相联，cache 中任意位置</li><li>set associative：组相联，在对应组中的任意位置，$(Block\ Address)\mod(Number\ of\ sets)$</li></ol></li><li><p>替换算法</p><ol><li>random：效果不差，但是缺乏确定性，对程序优化不友好</li><li>FIFO：first-in-first-out，可能导致抖动</li><li>LRU：Least recently used，较优，但算法复杂，一般采用简化版，如 clock 算法</li></ol></li><li><p>写策略</p><ul><li>写命中 cache 时候<ol><li>write through：写穿透，cache 和底层都写，保持一致性容易</li><li>write back：写回，只写 cache，之后 cache 写回底层，性能较好</li></ol></li><li>写不命中时候，常常使用<code>write buffer</code>减少写带来的 stall<ol><li>write allocate：写分配</li><li>No-write allocate：写不分配</li></ol></li></ul></li></ol><h3 id=cache-性能优化>cache 性能优化<a hidden class=anchor aria-hidden=true href=#cache-性能优化>¶</a></h3><p>优化目标为平均访问时间，有</p><p>$$
\mathrm{Average\ memory\ access\ time}=\mathrm{Hit\ time} + \mathrm{Miss\ rate}\times \mathrm{Miss\ penalty}
$$</p><p>当中，可以把 miss 分类有</p><ol><li>compulsory miss：第一次访存必然 miss</li><li>capacity miss：cache 容量有限，一些 block 被丢弃后再被访问</li><li>conflict miss：cache 不是全相联，set 满而部分 block 被丢弃后再被访问</li><li>coherence miss：多核时候，其他核修改导致数据过时而失效</li></ol><p>简单优化有</p><ol><li>增大 block ，减少 miss rate<ul><li>利用 spacial locality：空间局部性，可以减少 compulsory miss</li><li>可能增大 miss penalty</li><li>在 cache 大小固定时候，过大的 block 大小会增加 conflict miss</li></ul></li><li>增大 cache ，减少 miss rate<ul><li>可能增加 hit time</li><li>可能增加成本和功耗</li></ul></li><li>增加关联度<ul><li>比较电路设计麻烦，可能提高 hit time</li><li>8-way 组相联和全相联一般表现类似</li><li><blockquote><p>2:1 cache rule of thumb</p><p>大小 N 的 direct mapped 和$\frac{N}{2}$的 2-way set associative 一般 miss rate 相似（经验公式）</p></blockquote></li><li>可能增加 hit time，高关联性会要求更低的时钟频率</li></ul></li><li>多级 cache<ul><li>multilevel inclusion/ multilevel exclusion</li><li>平衡 fast hit 和 few misses</li></ul></li><li>read miss 优先于 write miss， 减少 miss penalty<ul><li>read miss 一般和取指，取数计算有关，优先可以减少程序的 stall</li><li>写缓存可能导致数据不一致，等写回内存用时过长</li></ul></li><li>在 cache 内索引时避开地址翻译， 降低 hit time<ul><li>VIVT 对于保护,重名不利</li><li>VIPT 需要如 page coloring 页着色等消除重名/使用 PID 进程号来记录 cache 对应关系</li><li>加大相联度，强行保证无需地址翻译</li><li>对于 L2 以下的 cache 不重要,因为访问 L2 时候必然已经经过了地址翻译</li></ul></li></ol><p>复杂优化有</p><ol><li>简单的 L1 缓存， 减少 hit time 和功耗<ul><li>为了更高的时钟频率和功耗限制</li><li>高相联性有助于不加大尺寸提高性能，但会提高功耗<ol><li>处理器本身 cache 访问慢</li><li>为了不地址翻译，cache 大小受限于页大小</li><li>多线程程序容易引发 conflict miss</li></ol></li><li>加大 block 大小减少行数以减少索引能耗，但会提高 miss rate</li><li>组织 banks， 分块激活</li></ul></li><li>预测组相联的具体 way，加速访问速度，降低 conflict miss<ul><li>I-cache 更容易被预测</li><li>way-selection：使用预测结果决定实际 cache 访问，适用于低功耗</li></ul></li><li>流水线化缓存访问，多 banks 独立<ul><li>流水线可提高 L1 时钟频率，会增加延迟，一般针对 I-cache</li><li>多 banks 独立针对，对于下级缓存，可以同时处理多个上级缓存缺失</li></ul></li><li>nonblocking cache， 提高带宽<ul><li><blockquote><p><strong>hit under miss</strong> 允许乱序执行规避 stall</p></blockquote></li><li>乱序执行刻意部分掩盖高层次的 cache miss，但对于高延迟的低层 miss 无效</li><li><blockquote><p><code>Miss Status Handling Registers(MSHRs)</code>记录缓存 miss 信息，一对一处理</p></blockquote></li></ul></li><li>关键词优先，更快重启<ul><li>cache line 比起一次 cache miss 要求的 word 更大，因此只要需要的数据可用，立即返回</li></ul></li><li>融合写缓存<ul><li>写相近地址的多字比多次写一个字快速</li><li><strong>内存映射的 IO 不能写融合</strong></li></ul></li><li>编译器优化<ul><li>循环展开</li><li>blocking 访问</li></ul></li><li>硬件预取<ul><li>注意预取可能会遇到虚拟内存缺页、权限错误等问题</li><li>可能取来无用数据而影响功耗，在高负载下影响性能</li></ul></li><li>编译器控制预取<ul><li>不能干扰程序执行（比如 register perfetch）</li></ul></li><li>HBM：high bandwidth memory<ul><li>大的 L4 缓存：<ol><li>大 block：内部碎片，使用 subblocking 只激活一部分缓解</li><li>tag 存储开销大：tag 和数据放在 HBM 同一行中，使用 memory 的行缓存加速访问</li></ol></li></ul></li></ol><h3 id=虚拟存储>虚拟存储<a hidden class=anchor aria-hidden=true href=#虚拟存储>¶</a></h3><ol><li>保护，保护机制在 page 上</li><li>共享,如系统库</li><li>管理内存使用和硬盘的 swap</li></ol><table><thead><tr><th></th><th>Page</th><th>Segment</th></tr></thead><tbody><tr><td>Words per address</td><td>One</td><td>Two (segment and offset)</td></tr><tr><td>Programmer visible?</td><td>Invisible to application programmer</td><td>May be visible to application programmer</td></tr><tr><td>Replacing a block</td><td>Trivial (all blocks are the same size)</td><td>Difficult (must find contiguous, variable-size, unused portion of main memory)</td></tr><tr><td>Memory use</td><td>inefficiency Internal fragmentation (unused portion of page)</td><td>External fragmentation (unused pieces of main memory)</td></tr><tr><td>Efficient disk traffic</td><td>Yes (adjust page size to balance access time and transfer time)</td><td>Not always (small segments may transfer just a few bytes)</td></tr></tbody></table><blockquote><p>Translation Look Aside buffer</p><p>TLB，快表，作为页表的缓存</p></blockquote><table><thead><tr><th>bit</th><th>usage</th></tr></thead><tbody><tr><td>Presence</td><td>page is present in memory</td></tr><tr><td>Read/write</td><td>whether page is read-only or read-write</td></tr><tr><td>User/supervisor</td><td>whether a user can access the page or if it is limited to the upper three privilege levels</td></tr><tr><td>Dirty</td><td>if page has been modified</td></tr><tr><td>Accessed</td><td>if page has been read or written since the bit was last cleared</td></tr><tr><td>Page size</td><td>whether the last level is for 4 KiB pages or 4 MiB pages; if it&rsquo;s the latter, then the Opteron only uses three instead of four levels of pages</td></tr><tr><td>No execute</td><td>Not found in the 80386 protection scheme, this bit was added to prevent code from executing in some pages</td></tr><tr><td>Page level cache disable</td><td>whether the page can be cached or not</td></tr><tr><td>Page level write through</td><td>whether the page allows write back or write through for data caches</td></tr></tbody></table><h3 id=virtual-machine>virtual machine<a hidden class=anchor aria-hidden=true href=#virtual-machine>¶</a></h3><ol><li>用虚拟机隔离 os<ol><li>可能有 bug 的操作系统</li><li>云用户</li><li>芯片性能足够开销</li></ol></li><li>兼容和管理软件</li><li>管理硬件（可以跨越单台机器）</li></ol><p>ISA 设计最好考虑虚拟机，<strong>virtualizable</strong>。保证特权指令在裸 os 和虚拟机的 os 下效果一致。也可以设计更多的特权级（RISCV 的 M、S、U 三态）。TLB 带进程号防止切换 os 频繁刷新。IO 设备也需要 vmm 来划分（如网络）和虚拟化（如硬盘）</p><blockquote><p>shadow page table</p><p>减少 软件-os-vmm 2 次地址翻译开销，os-vmm 之间直接映射。需要 trap 所有的 os 对页表的改写</p></blockquote><blockquote><p>software guard extension</p><p>由进程定义的对内存的加密。上层 os 和 vmm 可以移动数据，不能解密数据</p></blockquote><h3 id=fallacy>Fallacy<a hidden class=anchor aria-hidden=true href=#fallacy>¶</a></h3><ol><li>使用一个程序的访存推断其他程序。程序之间差异很大</li></ol><h3 id=pitfall>Pitfall<a hidden class=anchor aria-hidden=true href=#pitfall>¶</a></h3><ol><li>地址空间太小<ul><li>程序寻址空间大小$2^\text{address}$，太小的地址空间限制大程序</li><li>地址空间和<code>PC</code>，寄存器等多方面相关，难以后期改变</li></ul></li><li>忽略 os 对存储的性能影响，os 也会造成存储负载</li><li>依赖 os 智能调整页大小。os 一般只会针对如数据库和内存映射使用大页，os 不够智能</li><li>模拟指令来衡量访存性能<ol><li>cache 尺寸对于一小部分指令来说太大</li><li>程序不同阶段局部性不一样</li><li>程序对于不同输入局部性不一样</li></ol></li><li>用 cache 但是内存带宽不够</li><li>在<strong>virtualizable</strong>有问题的 ISA 上设计虚拟机<ul><li>eg，80x86 的<code>POPF</code>指令，在 user mode 下不改变<code>IE</code>；在 system mode 下改变。但<code>POPF</code>不是特权级指令，vmm 无法 trap 来保证虚拟化</li></ul></li></ol><h2 id=ch-3c-instruction-level-parallelism-and-its-exploitation>ch 3/C Instruction-Level Parallelism and Its Exploitation<a hidden class=anchor aria-hidden=true href=#ch-3c-instruction-level-parallelism-and-its-exploitation>¶</a></h2><h3 id=5-级流水>5 级流水<a hidden class=anchor aria-hidden=true href=#5-级流水>¶</a></h3><table><thead><tr><th>全称</th><th>简称</th><th>效果</th><th>伪代码</th></tr></thead><tbody><tr><td>instruction fetch cycle</td><td>IF</td><td>按照<code>pc</code>取指令，并<code>pc+=4</code></td><td><code>IR&lt;-Mem[PC],NPC&lt;-PC+4</code></td></tr><tr><td>instruction decode/register fetch cycle</td><td>ID</td><td>指令译码，符号拓展偏移值，预测<code>pc</code>跳转地址，读寄存器（RISCV 的寄存器和立即数位置固定，可以在不在意功耗场合默认读取）</td><td><code>A&lt;-Regs[rs1],B&lt;-Regs[rs2], Imm&lt;-sign-extended immediate field of IR;</code></td></tr><tr><td>execution/effective address cycle</td><td>EX</td><td>1. 内存访问：ALU 计算基址+偏移 2. 寄存器-寄存器 ALU 3. 寄存器-立即数 ALU 4. 条件跳转：判断是否跳转。 对于 load-store 的 ISA（如 RISCV）执行和计算地址可以合并为一个周期</td><td><code>ALUOutput&lt;- A + Imm;ALUOutput&lt;-A func B;ALUOutput&lt;-A op Imm;ALUOutput&lt;-NPC+(Imm&lt;&lt;2),Cond&lt;-(A?=B)</code></td></tr><tr><td>memory access</td><td>MEM</td><td>访存</td><td><code>LMD&lt;-Mem[ALUOutput] or Mem[ALUOutput]&lt;-B;if(Cond)PC&lt;-ALUOutput else PC&lt;-NPC</code></td></tr><tr><td>write-back cycle</td><td>WB</td><td>访存/ALU 运算结果写回寄存器文件</td><td><code>Regs[rd]&lt;-ALUOutput;Regs[rd]&lt;-LMD</code></td></tr></tbody></table><p>有一些注意事项</p><ol><li>分开 Icache 和 Dcache 保证一个 cycle 内取指和访存指令的访存不冲突</li><li>对于流水的 CPU，访存频率更高，要求更高的内存带宽</li><li>寄存器文件在 ID 时候需要 2 个读端口，WB 时候 1 个写端口</li><li>中间结果需要 pipeline registers 缓存下来，<code>IF/ID,ID/EX,EX/MEM,MEM/WB</code></li><li>流水线的单一指令延迟会增加<ol><li>最慢的阶段限制整体时钟频率</li><li>pipeline register 读写和传播时间</li></ol></li></ol><p>流水线会遭遇 hazard 使得性能不如理论值</p><ol><li>structural hazard：功能部件不能满足同时访问</li><li>data hazard：数据依赖（按照正确执行应该保持的顺序来命名）<ol><li>Read After Write：RAW，真相关</li><li>Write After Read：WAR，只有乱序时候出现</li><li>Write After Write：WAW，只有乱序时候出现</li></ol></li><li>control hazard：跳转和其他改变<code>pc</code>的指令</li></ol><h3 id=中断>中断<a hidden class=anchor aria-hidden=true href=#中断>¶</a></h3><table><thead><tr><th>Exception Type</th><th>Synchronous（和具体代码、数据有关） vs Asynchronous</th><th>User Request vs Coerced</th><th>User Maskable vs Nonmaskable</th><th>within（指令本身引发，需要重启指令） vs between Instructions</th><th>Resume vs Terminate</th></tr></thead><tbody><tr><td>I/O device request</td><td>Asynchronous</td><td>Coerced</td><td>Nonmaskable</td><td>Between</td><td>Resume</td></tr><tr><td>Invoke operating system</td><td>Synchronous</td><td>User request</td><td>Nonmaskable</td><td>Between</td><td>Resume</td></tr><tr><td>Tracing instruction execution</td><td>Synchronous</td><td>User request</td><td>User maskable</td><td>Between</td><td>Resume</td></tr><tr><td>Breakpoint</td><td>Synchronous</td><td>User request</td><td>User maskable</td><td>Between</td><td>Resume</td></tr><tr><td>Integer arithmetic overflow</td><td>Synchronous</td><td>Coerced</td><td>User maskable</td><td>Within</td><td>Resume</td></tr><tr><td>Floating-point arithmetic overflow or underflow</td><td>Synchronous</td><td>Coerced</td><td>User maskable</td><td>Within</td><td>Resume</td></tr><tr><td>Page fault</td><td>Synchronous</td><td>Coerced</td><td>Nonmaskable</td><td>Within</td><td>Resume</td></tr><tr><td>Misaligned memory accesses</td><td>Synchronous</td><td>Coerced</td><td>User maskable</td><td>Within</td><td>Resume</td></tr><tr><td>Memory protection violations</td><td>Synchronous</td><td>Coerced</td><td>Nonmaskable</td><td>Within</td><td>Resume</td></tr><tr><td>Using undefined instructions</td><td>Synchronous</td><td>Coerced</td><td>Nonmaskable</td><td>Within</td><td>Terminate</td></tr><tr><td>Hardware malfunctions</td><td>Asynchronous</td><td>Coerced</td><td>Nonmaskable</td><td>Within</td><td>Terminate</td></tr><tr><td>Power failure</td><td>Asynchronous</td><td>Coerced</td><td>Nonmaskable</td><td>Within</td><td>Terminate</td></tr></tbody></table><h2 id=ch-a-instruction-set-principles>ch A Instruction Set Principles<a hidden class=anchor aria-hidden=true href=#ch-a-instruction-set-principles>¶</a></h2><h3 id=isa-特性>ISA 特性<a hidden class=anchor aria-hidden=true href=#isa-特性>¶</a></h3><p>对于 ISA 设计，其有如下一些考虑：</p><ol><li>指令集类型<ol><li>栈</li><li>累加器</li><li>寄存器-内存</li><li>寄存器-寄存器/load-store</li></ol></li><li>地址访问：对齐、不对齐</li><li>寻址模式<ol><li>立即数 <code>3</code></li><li>寄存器 <code>Regs[R4]</code></li><li>寄存器访存 <code>Mem[Regs[R4]]</code></li><li>寄存器+偏移访存 <code>Mem[Regs[R4]+10]</code></li><li>寄存器+寄存器访存 <code>Mem[Regs[R3]+Regs[R4]]</code></li><li>立即数访存 <code>Mem[1001]</code></li><li>PC 相关 <code>pc</code></li><li>寄存器间接访存 <code>Mem[Mem[Regs[R4]]]</code></li><li>自增自减 <code>Mem[Regs[R2]+=d]</code></li><li>寄存器+寄存器倍增访存 <code>Mem[Regs[R2]+Regs[R3]*d]</code></li></ol></li><li>操作数类型：<ol><li>整型 <code>u8,i8,u16,i16,u32,i32,u64,i64</code></li><li>浮点数<code>f32,f64</code></li><li>拓展浮点数 80 位</li></ol></li><li>指令类型<ol><li>运算和逻辑</li><li>访存</li><li>控制</li><li>系统特权有关</li><li>浮点数指令</li><li>decimal 指令</li><li>字符串指令</li><li>图像指令</li><li>SIMD</li></ol></li><li>控制流指令<ol><li>无条件跳转</li><li>条件转移</li><li>函数调用</li><li>函数 return</li></ol></li><li>ISA 编码：<ol><li>寄存器数目：对应编译器分配，解依赖，编码长度</li><li>定长，变长</li><li>寄存器编码位置固定/不固定</li></ol></li></ol><h3 id=编译器优化>编译器优化<a hidden class=anchor aria-hidden=true href=#编译器优化>¶</a></h3><table><thead><tr><th>编译器层次</th><th>依赖</th><th>功能</th></tr></thead><tbody><tr><td>front end per language</td><td>语言相关，和机器无关</td><td>语言翻译成通用 intermediate 形式</td></tr><tr><td>high-level optimizations</td><td>语言相关，基本和机器无关</td><td>eg，循环展开，函数内连</td></tr><tr><td>global optimizer</td><td>基本语言无关，和机器有关（寄存器数目和类型）</td><td>优化和寄存器分配</td></tr><tr><td>code generator</td><td>语言无关，机器相关</td><td>具体的机器特定优化和指令选择</td></tr></tbody></table><ol><li>寄存器数目$\ge 16$个以方便启发性的 group coloring 的寄存器分配算法（本质是个$\mathcal{NP}$问题，只有近似线性的启发式算法）</li><li>保证常见场景优化+罕见场景正确</li><li>操作，数据类型和寻址 3 者可以正交组合</li><li>提供 primitive 原语，而不是方案，防止过于适配高层语言</li><li>简化 trade-off 的选择</li><li>保证编译期常量能直接绑定到指令</li></ol><p>SIMD 指令基本上违背所有原则（vec 寄存器数目少，寻址模式过于简单，vec 类型不常见 etc.）。因此 SIMD 一般只有用在人工编写的底层库</p><h3 id=isa-统计和对应的-risc-v-设计>ISA 统计和对应的 RISC-V 设计<a hidden class=anchor aria-hidden=true href=#isa-统计和对应的-risc-v-设计>¶</a></h3><h3 id=fallacy-1>Fallacy<a hidden class=anchor aria-hidden=true href=#fallacy-1>¶</a></h3><ol><li>存在一个典型程序：不同程序对 ISA 的使用差异巨大</li><li>有缺陷的 ISA 不能成功（80x86）</li><li>存在完美的体系结构<ul><li>trade-off 永存</li><li>不同技术和时代强调目标不同</li></ul></li></ol><h3 id=pitfall-1>Pitfall<a hidden class=anchor aria-hidden=true href=#pitfall-1>¶</a></h3><ol><li>设计一个高层次指令来支持高层语言的结构<ul><li>semantic gap：过于复杂，功能过剩，或者是对于其他语言其约定有差异</li></ul></li><li>设计 ISA 时候不考虑编译器优化<ul><li>编译器优化等级对于体积优化和性能优化结果差异很大</li></ul></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://livypad.github.io/tags/%E6%95%99%E7%A8%8B/>教程</a></li><li><a href=https://livypad.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/>读书笔记</a></li></ul><nav class=paginav><a class=prev href=https://livypad.github.io/post/2023-02-27-adalg/><span class=title>« Prev Page</span><br><span>高级算法设计-课堂笔记（更新到第7次课）</span></a>
<a class=next href=https://livypad.github.io/post/2022-11-02-mbqueue/><span class=title>Next Page »</span><br><span>Michael&Scott 无锁队列</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://livypad.github.io>zhh's blog</a></span><span style=display:inline-block;margin-left:1em>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
    <a href=https://github.com/reorx/hugo-PaperModX/ rel=noopener target=_blank>PaperModX</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>MathJax={tex:{inlineMath:[["$","$"]],displayMath:[["$$","$$"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}},svg:{fontCache:"global"}}</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js></script>
<script>(function(){const t=""=="1";if(t)return;let e=document.getElementById("theme-toggle");e.removeEventListener("click",toggleThemeListener),e.addEventListener("click",toggleThemeListener)})()</script><script>(function(){let e=document.getElementById("menu");e&&(e.scrollLeft=localStorage.getItem("menu-scroll-position"),e.onscroll=function(){localStorage.setItem("menu-scroll-position",e.scrollLeft)});const t=""=="1",n=""=="1";if(window.matchMedia("(prefers-reduced-motion: reduce)").matches||t||n)return;document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})})()</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>if(window.scrollListeners)for(const e of scrollListeners)window.removeEventListener("scroll",e);window.scrollListeners=[]</script><script src=/js/medium-zoom.min.js data-no-instant></script>
<script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>(function(){const r="1"=="1";if(!r)return;if(!document.querySelector(".toc")){console.log("no toc found, ignore toc scroll");return}const c=window.scrollListeners,n=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id]"),s="active";let e=n[0];o(e).classList.add(s);const a=()=>{const t=[];for(const e of n)if(l(e)<5)t.push(e);else break;t.length>0?newActiveHeading=t[t.length-1]:newActiveHeading=n[0],e!=newActiveHeading&&(o(e).classList.remove(s),e=newActiveHeading,o(e).classList.add(s))};let t=null;const i=()=>{t!==null&&clearTimeout(t),t=setTimeout(a,50)};window.addEventListener("scroll",i,!1),c.push(i);function o(e){const t=encodeURI(e.getAttribute("id")).toLowerCase();return document.querySelector(`.toc ul li a[href="#${t}"]`)}function l(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect();return t.top}})()</script></body></html>